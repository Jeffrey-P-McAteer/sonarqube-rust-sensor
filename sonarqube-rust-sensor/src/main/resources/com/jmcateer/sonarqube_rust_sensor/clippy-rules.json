[
  {
    "rule_id": "absolute_paths",
    "rule_name": "absolute_paths",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of items through absolute paths, like <code>std::env::current_dir</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Many codebases have their own style when it comes to importing, but one that is seldom used\nis using absolute paths <em>everywhere</em>. This is generally considered unidiomatic, and you\nshould add a <code>use</code> statement.</p>\n<p>The default maximum segments (2) is pretty strict, you may want to increase this in\n<code>clippy.toml</code>.</p>\n<p>Note: One exception to this is code from macro expansion - this does not lint such cases, as\nusing absolute paths is the proper way of referencing items in one.</p>\n<h3>Known issues</h3>\n<p>There are currently a few cases which are not caught by this lint:</p>\n<ul>\n<li>Macro calls. e.g. <code>path::to::macro!()</code></li>\n<li>Derive macros. e.g. <code>#[derive(path::to::macro)]</code></li>\n<li>Attribute macros. e.g. <code>#[path::to::macro]</code></li>\n</ul>\n<h3>Example</h3>\n<pre><code>let x = std::f64::consts::PI;\n</code></pre>\n<p>Use any of the below instead, or anything else:</p>\n<pre><code>use std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>absolute-paths-allowed-crates</code>:  Which crates to allow absolute paths from</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n<li>\n<p><code>absolute-paths-max-segments</code>:  The maximum number of segments a path can have before being linted, anything above this will\nbe linted.</p>\n<p>(default: <code>2</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "absurd_extreme_comparisons",
    "rule_name": "absurd_extreme_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for comparisons where one side of the relation is\neither the minimum or maximum value for its type and warns if it involves a\ncase that is always true or always false. Only integer and boolean types are\nchecked.</p>\n<h3>Why is this bad?</h3>\n<p>An expression like <code>min <= x</code> may misleadingly imply\nthat it is possible for <code>x</code> to be less than the minimum. Expressions like\n<code>max < x</code> are probably mistakes.</p>\n<h3>Known problems</h3>\n<p>For <code>usize</code> the size of the current compile target will\nbe assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\na comparison to detect target pointer width will trigger this lint. One can\nuse <code>mem::sizeof</code> and compare its value or conditional compilation\nattributes\nlike <code>#[cfg(target_pointer_width = \"64\")] ..</code> instead.</p>\n<h3>Example</h3>\n<pre><code>let vec: Vec<isize> = Vec::new();\nif vec.len() <= 0 {}\nif 100 > i32::MAX {}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "alloc_instead_of_core",
    "rule_name": "alloc_instead_of_core",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds items imported through <code>alloc</code> when available through <code>core</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Crates which have <code>no_std</code> compatibility and may optionally require alloc may wish to ensure types are\nimported from core to ensure disabling <code>alloc</code> does not cause the crate to fail to compile. This lint\nis also useful for crates migrating to become <code>no_std</code> compatible.</p>\n<h3>Known problems</h3>\n<p>The lint is only partially aware of the required MSRV for items that were originally in <code>std</code> but moved\nto <code>core</code>.</p>\n<h3>Example</h3>\n<pre><code>use alloc::slice::from_ref;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use core::slice::from_ref;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "allow_attributes",
    "rule_name": "allow_attributes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of the <code>#[allow]</code> attribute and suggests replacing it with\nthe <code>#[expect]</code> (See <a>RFC 2383</a>)</p>\n<p>This lint only warns outer attributes (<code>#[allow]</code>), as inner attributes\n(<code>#![allow]</code>) are usually used to enable or disable lints on a global scale.</p>\n<h3>Why is this bad?</h3>\n<p><code>#[expect]</code> attributes suppress the lint emission, but emit a warning, if\nthe expectation is unfulfilled. This can be useful to be notified when the\nlint is no longer triggered.</p>\n<h3>Example</h3>\n<pre><code>#[allow(unused_mut)]\nfn foo() -> usize {\n    let mut a = Vec::new();\n    a.len()\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[expect(unused_mut)]\nfn foo() -> usize {\n    let mut a = Vec::new();\n    a.len()\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "allow_attributes_without_reason",
    "rule_name": "allow_attributes_without_reason",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for attributes that allow lints without a reason.</p>\n<h3>Why restrict this?</h3>\n<p>Justifying each <code>allow</code> helps readers understand the reasoning,\nand may allow removing <code>allow</code> attributes if their purpose is obsolete.</p>\n<h3>Example</h3>\n<pre><code>#![allow(clippy::some_lint)]\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "almost_complete_range",
    "rule_name": "almost_complete_range",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for ranges which almost include the entire range of letters from \u2018a\u2019 to \u2018z\u2019\nor digits from \u20180\u2019 to \u20189\u2019, but don\u2019t because they\u2019re a half open range.</p>\n<h3>Why is this bad?</h3>\n<p>This (<code>'a'..'z'</code>) is almost certainly a typo meant to include all letters.</p>\n<h3>Example</h3>\n<pre><code>let _ = 'a'..'z';\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = 'a'..='z';\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>almost_complete_letter_range</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "almost_swapped",
    "rule_name": "almost_swapped",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>foo = bar; bar = foo</code> sequences.</p>\n<h3>Why is this bad?</h3>\n<p>This looks like a failed attempt to swap.</p>\n<h3>Example</h3>\n<pre><code>a = b;\nb = a;\n</code></pre>\n<p>If swapping is intended, use <code>swap()</code> instead:</p>\n<pre><code>std::mem::swap(&mut a, &mut b);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "approx_constant",
    "rule_name": "approx_constant",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for floating point literals that approximate\nconstants which are defined in\n<a><code>std::f32::consts</code></a>\nor\n<a><code>std::f64::consts</code></a>,\nrespectively, suggesting to use the predefined constant.</p>\n<h3>Why is this bad?</h3>\n<p>Usually, the definition in the standard library is more\nprecise than what people come up with. If you find that your definition is\nactually more precise, please <a>file a Rust\nissue</a>.</p>\n<h3>Example</h3>\n<pre><code>let x = 3.14;\nlet y = 1_f64 / x;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = std::f32::consts::PI;\nlet y = std::f64::consts::FRAC_1_PI;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "arbitrary_source_item_ordering",
    "rule_name": "arbitrary_source_item_ordering",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Confirms that items are sorted in source files as per configuration.</p>\n<h3>Why restrict this?</h3>\n<p>Keeping a consistent ordering throughout the codebase helps with working\nas a team, and possibly improves maintainability of the codebase. The\nidea is that by defining a consistent and enforceable rule for how\nsource files are structured, less time will be wasted during reviews on\na topic that is (under most circumstances) not relevant to the logic\nimplemented in the code. Sometimes this will be referred to as\n\u201cbikeshedding\u201d.</p>\n<h3>Default Ordering and Configuration</h3>\n<p>As there is no generally applicable rule, and each project may have\ndifferent requirements, the lint can be configured with high\ngranularity. The configuration is split into two stages:</p>\n<ol>\n<li>Which item kinds that should have an internal order enforced.</li>\n<li>Individual ordering rules per item kind.</li>\n</ol>\n<p>The item kinds that can be linted are:</p>\n<ul>\n<li>Module (with customized groupings, alphabetical within)</li>\n<li>Trait (with customized order of associated items, alphabetical within)</li>\n<li>Enum, Impl, Struct (purely alphabetical)</li>\n</ul>\n<h4>Module Item Order</h4>\n<p>Due to the large variation of items within modules, the ordering can be\nconfigured on a very granular level. Item kinds can be grouped together\narbitrarily, items within groups will be ordered alphabetically. The\nfollowing table shows the default groupings:</p>\n<table><thead><tr><th>Group</th><th>Item Kinds</th></tr></thead><tbody>\n<tr><td><code>modules</code></td><td>\u201cmod\u201d, \u201cforeign_mod\u201d</td></tr>\n<tr><td><code>use</code></td><td>\u201cuse\u201d</td></tr>\n<tr><td><code>macros</code></td><td>\u201cmacro\u201d</td></tr>\n<tr><td><code>global_asm</code></td><td>\u201cglobal_asm\u201d</td></tr>\n<tr><td><code>UPPER_SNAKE_CASE</code></td><td>\u201cstatic\u201d, \u201cconst\u201d</td></tr>\n<tr><td><code>PascalCase</code></td><td>\u201cty_alias\u201d, \u201copaque_ty\u201d, \u201cenum\u201d, \u201cstruct\u201d, \u201cunion\u201d, \u201ctrait\u201d, \u201ctrait_alias\u201d, \u201cimpl\u201d</td></tr>\n<tr><td><code>lower_snake_case</code></td><td>\u201cfn\u201d</td></tr>\n</tbody></table>\n<p>All item kinds must be accounted for to create an enforceable linting\nrule set.</p>\n<h3>Known Problems</h3>\n<h4>Performance Impact</h4>\n<p>Keep in mind, that ordering source code alphabetically can lead to\nreduced performance in cases where the most commonly used enum variant\nisn\u2019t the first entry anymore, and similar optimizations that can reduce\nbranch misses, cache locality and such. Either don\u2019t use this lint if\nthat\u2019s relevant, or disable the lint in modules or items specifically\nwhere it matters. Other solutions can be to use profile guided\noptimization (PGO), post-link optimization (e.g. using BOLT for LLVM),\nor other advanced optimization methods. A good starting point to dig\ninto optimization is <a>cargo-pgo</a>.</p>\n<h4>Lints on a Contains basis</h4>\n<p>The lint can be disabled only on a \u201ccontains\u201d basis, but not per element\nwithin a \u201ccontainer\u201d, e.g. the lint works per-module, per-struct,\nper-enum, etc. but not for \u201cdon\u2019t order this particular enum variant\u201d.</p>\n<h4>Module documentation</h4>\n<p>Module level rustdoc comments are not part of the resulting syntax tree\nand as such cannot be linted from within <code>check_mod</code>. Instead, the\n<code>rustdoc::missing_documentation</code> lint may be used.</p>\n<h4>Module Tests</h4>\n<p>This lint does not implement detection of module tests (or other feature\ndependent elements for that matter). To lint the location of mod tests,\nthe lint <code>items_after_test_module</code> can be used instead.</p>\n<h3>Example</h3>\n<pre><code>trait TraitUnordered {\n    const A: bool;\n    const C: bool;\n    const B: bool;\n\n    type SomeType;\n\n    fn a();\n    fn c();\n    fn b();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>trait TraitOrdered {\n    const A: bool;\n    const B: bool;\n    const C: bool;\n\n    type SomeType;\n\n    fn a();\n    fn b();\n    fn c();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>module-item-order-groupings</code>:  The named groupings of different source item kinds within modules.</p>\n<p>(default: <code>[[\"modules\", [\"extern_crate\", \"mod\", \"foreign_mod\"]], [\"use\", [\"use\"]], [\"macros\", [\"macro\"]], [\"global_asm\", [\"global_asm\"]], [\"UPPER_SNAKE_CASE\", [\"static\", \"const\"]], [\"PascalCase\", [\"ty_alias\", \"enum\", \"struct\", \"union\", \"trait\", \"trait_alias\", \"impl\"]], [\"lower_snake_case\", [\"fn\"]]]</code>)</p>\n</li>\n<li>\n<p><code>source-item-ordering</code>:  Which kind of elements should be ordered internally, possible values being <code>enum</code>, <code>impl</code>, <code>module</code>, <code>struct</code>, <code>trait</code>.</p>\n<p>(default: <code>[\"enum\", \"impl\", \"module\", \"struct\", \"trait\"]</code>)</p>\n</li>\n<li>\n<p><code>trait-assoc-item-kinds-order</code>:  The order of associated items in traits.</p>\n<p>(default: <code>[\"const\", \"type\", \"fn\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "arc_with_non_send_sync",
    "rule_name": "arc_with_non_send_sync",
    "rule_description_html": "<div><h3>What it does.</h3>\n<p>This lint warns when you use <code>Arc</code> with a type that does not implement <code>Send</code> or <code>Sync</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>Arc<T></code> is a thread-safe <code>Rc<T></code> and guarantees that updates to the reference counter\nuse atomic operations. To send an <code>Arc<T></code> across thread boundaries and\nshare ownership between multiple threads, <code>T</code> must be <a>both <code>Send</code> and <code>Sync</code></a>,\nso either <code>T</code> should be made <code>Send + Sync</code> or an <code>Rc</code> should be used instead of an <code>Arc</code>.</p>\n<h3>Example</h3>\n<pre><code>\nfn main() {\n    // This is fine, as `i32` implements `Send` and `Sync`.\n    let a = Arc::new(42);\n\n    // `RefCell` is `!Sync`, so either the `Arc` should be replaced with an `Rc`\n    // or the `RefCell` replaced with something like a `RwLock`\n    let b = Arc::new(RefCell::new(42));\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "arithmetic_side_effects",
    "rule_name": "arithmetic_side_effects",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks any kind of arithmetic operation of any type.</p>\n<p>Operators like <code>+</code>, <code>-</code>, <code>*</code> or <code><<</code> are usually capable of overflowing according to the <a>Rust\nReference</a>,\nor can panic (<code>/</code>, <code>%</code>).</p>\n<p>Known safe built-in types like <code>Wrapping</code> or <code>Saturating</code>, floats, operations in constant\nenvironments, allowed types and non-constant operations that won\u2019t overflow are ignored.</p>\n<h3>Why restrict this?</h3>\n<p>For integers, overflow will trigger a panic in debug builds or wrap the result in\nrelease mode; division by zero will cause a panic in either mode. As a result, it is\ndesirable to explicitly call checked, wrapping or saturating arithmetic methods.</p>\n<h4>Example</h4>\n<pre><code>// `n` can be any number, including `i32::MAX`.\nfn foo(n: i32) -> i32 {\n    n + 1\n}\n</code></pre>\n<p>Third-party types can also overflow or present unwanted side-effects.</p>\n<h4>Example</h4>\n<pre><code>use rust_decimal::Decimal;\nlet _n = Decimal::MAX + Decimal::MAX;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>integer_arithmetic</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li><code>arithmetic-side-effects-allowed</code>:  Suppress checking of the passed type names in all types of operations.</li>\n</ul>\n<p>If a specific operation is desired, consider using <code>arithmetic_side_effects_allowed_binary</code> or <code>arithmetic_side_effects_allowed_unary</code> instead.</p>\n<h4>Example</h4>\n<pre><code>arithmetic-side-effects-allowed = [\"SomeType\", \"AnotherType\"]\n</code></pre>\n<h4>Noteworthy</h4>\n<p>A type, say <code>SomeType</code>, listed in this configuration has the same behavior of\n<code>[\"SomeType\" , \"*\"], [\"*\", \"SomeType\"]</code> in <code>arithmetic_side_effects_allowed_binary</code>.</p>\n<p>(default: <code>[]</code>)</p>\n<ul>\n<li><code>arithmetic-side-effects-allowed-binary</code>:  Suppress checking of the passed type pair names in binary operations like addition or\nmultiplication.</li>\n</ul>\n<p>Supports the \u201c*\u201d wildcard to indicate that a certain type won\u2019t trigger the lint regardless\nof the involved counterpart. For example, <code>[\"SomeType\", \"*\"]</code> or <code>[\"*\", \"AnotherType\"]</code>.</p>\n<p>Pairs are asymmetric, which means that <code>[\"SomeType\", \"AnotherType\"]</code> is not the same as\n<code>[\"AnotherType\", \"SomeType\"]</code>.</p>\n<h4>Example</h4>\n<pre><code>arithmetic-side-effects-allowed-binary = [[\"SomeType\" , \"f32\"], [\"AnotherType\", \"*\"]]\n</code></pre>\n<p>(default: <code>[]</code>)</p>\n<ul>\n<li><code>arithmetic-side-effects-allowed-unary</code>:  Suppress checking of the passed type names in unary operations like \u201cnegation\u201d (<code>-</code>).</li>\n</ul>\n<h4>Example</h4>\n<pre><code>arithmetic-side-effects-allowed-unary = [\"SomeType\", \"AnotherType\"]\n</code></pre>\n<p>(default: <code>[]</code>)</p>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "as_conversions",
    "rule_name": "as_conversions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>as</code> conversions.</p>\n<p>Note that this lint is specialized in linting <em>every single</em> use of <code>as</code>\nregardless of whether good alternatives exist or not.\nIf you want more precise lints for <code>as</code>, please consider using these separate lints:\n<code>unnecessary_cast</code>, <code>cast_lossless/cast_possible_truncation/cast_possible_wrap/cast_precision_loss/cast_sign_loss</code>,\n<code>fn_to_numeric_cast(_with_truncation)</code>, <code>char_lit_as_u8</code>, <code>ref_to_mut</code> and <code>ptr_as_ptr</code>.\nThere is a good explanation the reason why this lint should work in this way and how it is useful\n<a>in this issue</a>.</p>\n<h3>Why restrict this?</h3>\n<p><code>as</code> conversions will perform many kinds of\nconversions, including silently lossy conversions and dangerous coercions.\nThere are cases when it makes sense to use <code>as</code>, so the lint is\nAllow by default.</p>\n<h3>Example</h3>\n<pre><code>let a: u32;\n...\nf(a as u16);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>f(a.try_into()?);\n\n// or\n\nf(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "as_pointer_underscore",
    "rule_name": "as_pointer_underscore",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of <code>as *const _</code> or <code>as *mut _</code> conversion using inferred type.</p>\n<h3>Why restrict this?</h3>\n<p>The conversion might include a dangerous cast that might go undetected due to the type being inferred.</p>\n<h3>Example</h3>\n<pre><code>fn as_usize<T>(t: &T) -> usize {\n    // BUG: `t` is already a reference, so we will here\n    // return a dangling pointer to a temporary value instead\n    &t as *const _ as usize\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn as_usize<T>(t: &T) -> usize {\n    t as *const T as usize\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "as_ptr_cast_mut",
    "rule_name": "as_ptr_cast_mut",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the result of a <code>&self</code>-taking <code>as_ptr</code> being cast to a mutable pointer.</p>\n<h3>Why is this bad?</h3>\n<p>Since <code>as_ptr</code> takes a <code>&self</code>, the pointer won\u2019t have write permissions unless interior\nmutability is used, making it unlikely that having it as a mutable pointer is correct.</p>\n<h3>Example</h3>\n<pre><code>let mut vec = Vec::<u8>::with_capacity(1);\nlet ptr = vec.as_ptr() as *mut u8;\nunsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut vec = Vec::<u8>::with_capacity(1);\nlet ptr = vec.as_mut_ptr();\nunsafe { ptr.write(4) };\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "as_underscore",
    "rule_name": "as_underscore",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of <code>as _</code> conversion using inferred type.</p>\n<h3>Why restrict this?</h3>\n<p>The conversion might include lossy conversion or a dangerous cast that might go\nundetected due to the type being inferred.</p>\n<p>The lint is allowed by default as using <code>_</code> is less wordy than always specifying the type.</p>\n<h3>Example</h3>\n<pre><code>fn foo(n: usize) {}\nlet n: u16 = 256;\nfoo(n as _);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(n: usize) {}\nlet n: u16 = 256;\nfoo(n as usize);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "assertions_on_constants",
    "rule_name": "assertions_on_constants",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>assert!(true)</code> and <code>assert!(false)</code> calls.</p>\n<h3>Why is this bad?</h3>\n<p>Will be optimized out by the compiler or should probably be replaced by a\n<code>panic!()</code> or <code>unreachable!()</code></p>\n<h3>Example</h3>\n<pre><code>assert!(false)\nassert!(true)\nconst B: bool = false;\nassert!(B)\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "assertions_on_result_states",
    "rule_name": "assertions_on_result_states",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>assert!(r.is_ok())</code> or <code>assert!(r.is_err())</code> calls.</p>\n<h3>Why restrict this?</h3>\n<p>This form of assertion does not show any of the information present in the <code>Result</code>\nother than which variant it isn\u2019t.</p>\n<h3>Known problems</h3>\n<p>The suggested replacement decreases the readability of code and log output.</p>\n<h3>Example</h3>\n<pre><code>assert!(r.is_ok());\nassert!(r.is_err());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>r.unwrap();\nr.unwrap_err();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "assign_op_pattern",
    "rule_name": "assign_op_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>a = a op b</code> or <code>a = b commutative_op a</code>\npatterns.</p>\n<h3>Why is this bad?</h3>\n<p>These can be written as the shorter <code>a op= b</code>.</p>\n<h3>Known problems</h3>\n<p>While forbidden by the spec, <code>OpAssign</code> traits may have\nimplementations that differ from the regular <code>Op</code> impl.</p>\n<h3>Example</h3>\n<pre><code>let mut a = 5;\nlet b = 0;\n// ...\n\na = a + b;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut a = 5;\nlet b = 0;\n// ...\n\na += b;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "assign_ops",
    "rule_name": "assign_ops",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p>Compound operators are harmless and linting on them is not in scope for clippy.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "assigning_clones",
    "rule_name": "assigning_clones",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for code like <code>foo = bar.clone();</code></p>\n<h3>Why is this bad?</h3>\n<p>Custom <code>Clone::clone_from()</code> or <code>ToOwned::clone_into</code> implementations allow the objects\nto share resources and therefore avoid allocations.</p>\n<h3>Example</h3>\n<pre><code>struct Thing;\n\nimpl Clone for Thing {\n    fn clone(&self) -> Self { todo!() }\n    fn clone_from(&mut self, other: &Self) { todo!() }\n}\n\npub fn assign_to_ref(a: &mut Thing, b: Thing) {\n    *a = b.clone();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Thing;\n\nimpl Clone for Thing {\n    fn clone(&self) -> Self { todo!() }\n    fn clone_from(&mut self, other: &Self) { todo!() }\n}\n\npub fn assign_to_ref(a: &mut Thing, b: Thing) {\n    a.clone_from(&b);\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "async_yields_async",
    "rule_name": "async_yields_async",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for async blocks that yield values of types\nthat can themselves be awaited.</p>\n<h3>Why is this bad?</h3>\n<p>An await is likely missing.</p>\n<h3>Example</h3>\n<pre><code>async fn foo() {}\n\nfn bar() {\n  let x = async {\n    foo()\n  };\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn foo() {}\n\nfn bar() {\n  let x = async {\n    foo().await\n  };\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "await_holding_invalid_type",
    "rule_name": "await_holding_invalid_type",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Allows users to configure types which should not be held across await\nsuspension points.</p>\n<h3>Why is this bad?</h3>\n<p>There are some types which are perfectly safe to use concurrently from\na memory access perspective, but that will cause bugs at runtime if\nthey are held in such a way.</p>\n<h3>Example</h3>\n<pre><code>await-holding-invalid-types = [\n  # You can specify a type name\n  \"CustomLockType\",\n  # You can (optionally) specify a reason\n  { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n]\n</code></pre>\n<pre><code>struct CustomLockType;\nstruct OtherCustomLockType;\nasync fn foo() {\n  let _x = CustomLockType;\n  let _y = OtherCustomLockType;\n  baz().await; // Lint violation\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>await-holding-invalid-types</code>:  The list of types which may not be held across an await point.</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "await_holding_lock",
    "rule_name": "await_holding_lock",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>await</code> while holding a non-async-aware\n<code>MutexGuard</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The Mutex types found in <a><code>std::sync</code></a> and\n<a><code>parking_lot</code></a> are\nnot designed to operate in an async context across await points.</p>\n<p>There are two potential solutions. One is to use an async-aware <code>Mutex</code>\ntype. Many asynchronous foundation crates provide such a <code>Mutex</code> type.\nThe other solution is to ensure the mutex is unlocked before calling\n<code>await</code>, either by introducing a scope or an explicit call to\n<a><code>Drop::drop</code></a>.</p>\n<h3>Known problems</h3>\n<p>Will report false positive for explicitly dropped guards\n(<a>#6446</a>). A\nworkaround for this is to wrap the <code>.lock()</code> call in a block instead of\nexplicitly dropping the guard.</p>\n<h3>Example</h3>\n<pre><code>async fn foo(x: &Mutex<u32>) {\n  let mut guard = x.lock().unwrap();\n  *guard += 1;\n  baz().await;\n}\n\nasync fn bar(x: &Mutex<u32>) {\n  let mut guard = x.lock().unwrap();\n  *guard += 1;\n  drop(guard); // explicit drop\n  baz().await;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn foo(x: &Mutex<u32>) {\n  {\n    let mut guard = x.lock().unwrap();\n    *guard += 1;\n  }\n  baz().await;\n}\n\nasync fn bar(x: &Mutex<u32>) {\n  {\n    let mut guard = x.lock().unwrap();\n    *guard += 1;\n  } // guard dropped here at end of scope\n  baz().await;\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "await_holding_refcell_ref",
    "rule_name": "await_holding_refcell_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>await</code> while holding a <code>RefCell</code>, <code>Ref</code>, or <code>RefMut</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>RefCell</code> refs only check for exclusive mutable access\nat runtime. Holding a <code>RefCell</code> ref across an await suspension point\nrisks panics from a mutable ref shared while other refs are outstanding.</p>\n<h3>Known problems</h3>\n<p>Will report false positive for explicitly dropped refs\n(<a>#6353</a>). A workaround for this is\nto wrap the <code>.borrow[_mut]()</code> call in a block instead of explicitly dropping the ref.</p>\n<h3>Example</h3>\n<pre><code>async fn foo(x: &RefCell<u32>) {\n  let mut y = x.borrow_mut();\n  *y += 1;\n  baz().await;\n}\n\nasync fn bar(x: &RefCell<u32>) {\n  let mut y = x.borrow_mut();\n  *y += 1;\n  drop(y); // explicit drop\n  baz().await;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn foo(x: &RefCell<u32>) {\n  {\n     let mut y = x.borrow_mut();\n     *y += 1;\n  }\n  baz().await;\n}\n\nasync fn bar(x: &RefCell<u32>) {\n  {\n    let mut y = x.borrow_mut();\n    *y += 1;\n  } // y dropped here at end of scope\n  baz().await;\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "bad_bit_mask",
    "rule_name": "bad_bit_mask",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for incompatible bit masks in comparisons.</p>\n<p>The formula for detecting if an expression of the type <code>_ <bit_op> m <cmp_op> c</code> (where <code><bit_op></code> is one of {<code>&</code>, <code>|</code>} and <code><cmp_op></code> is one of\n{<code>!=</code>, <code>>=</code>, <code>></code>, <code>!=</code>, <code>>=</code>, <code>></code>}) can be determined from the following\ntable:</p>\n<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>is always</th><th>Formula</th></tr></thead><tbody>\n<tr><td><code>==</code> or <code>!=</code></td><td><code>&</code></td><td><code>x & 2 == 3</code></td><td><code>false</code></td><td><code>c & m != c</code></td></tr>\n<tr><td><code><</code>  or <code>>=</code></td><td><code>&</code></td><td><code>x & 2 < 3</code></td><td><code>true</code></td><td><code>m < c</code></td></tr>\n<tr><td><code>></code>  or <code><=</code></td><td><code>&</code></td><td><code>x & 1 > 1</code></td><td><code>false</code></td><td><code>m <= c</code></td></tr>\n<tr><td><code>==</code> or <code>!=</code></td><td><code>|</code></td><td><code>x | 1 == 0</code></td><td><code>false</code></td><td><code>c | m != c</code></td></tr>\n<tr><td><code><</code>  or <code>>=</code></td><td><code>|</code></td><td><code>x | 1 < 1</code></td><td><code>false</code></td><td><code>m >= c</code></td></tr>\n<tr><td><code><=</code> or <code>></code></td><td><code>|</code></td><td><code>x | 1 > 0</code></td><td><code>true</code></td><td><code>m > c</code></td></tr>\n</tbody></table>\n<h3>Why is this bad?</h3>\n<p>If the bits that the comparison cares about are always\nset to zero or one by the bit mask, the comparison is constant <code>true</code> or\n<code>false</code> (depending on mask, compared value, and operators).</p>\n<p>So the code is actively misleading, and the only reason someone would write\nthis intentionally is to win an underhanded Rust contest or create a\ntest-case for this lint.</p>\n<h3>Example</h3>\n<pre><code>if (x & 1 == 2) { }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "big_endian_bytes",
    "rule_name": "big_endian_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of the <code>to_be_bytes</code> method and/or the function <code>from_be_bytes</code>.</p>\n<h3>Why restrict this?</h3>\n<p>To ensure use of little-endian or the target\u2019s endianness rather than big-endian.</p>\n<h3>Example</h3>\n<pre><code>let _x = 2i32.to_be_bytes();\nlet _y = 2i64.to_be_bytes();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "bind_instead_of_map",
    "rule_name": "bind_instead_of_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.and_then(|x| Some(y))</code>, <code>_.and_then(|x| Ok(y))</code>\nor <code>_.or_else(|x| Err(y))</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This can be written more concisely as <code>_.map(|x| y)</code> or <code>_.map_err(|x| y)</code>.</p>\n<h3>Example</h3>\n<pre><code>let _ = opt().and_then(|s| Some(s.len()));\nlet _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\nlet _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let _ = opt().map(|s| s.len());\nlet _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\nlet _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>option_and_then_some</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "blanket_clippy_restriction_lints",
    "rule_name": "blanket_clippy_restriction_lints",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>warn</code>/<code>deny</code>/<code>forbid</code> attributes targeting the whole clippy::restriction category.</p>\n<h3>Why is this bad?</h3>\n<p>Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\nThese lints should only be enabled on a lint-by-lint basis and with careful consideration.</p>\n<h3>Example</h3>\n<pre><code>#![deny(clippy::restriction)]\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![deny(clippy::as_conversions)]\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "blocks_in_conditions",
    "rule_name": "blocks_in_conditions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>if</code> and <code>match</code> conditions that use blocks containing an\nexpression, statements or conditions that use closures with blocks.</p>\n<h3>Why is this bad?</h3>\n<p>Style, using blocks in the condition makes it hard to read.</p>\n<h3>Examples</h3>\n<pre><code>if { true } { /* ... */ }\n\nif { let x = somefunc(); x } { /* ... */ }\n\nmatch { let e = somefunc(); e } {\n    // ...\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if true { /* ... */ }\n\nlet res = { let x = somefunc(); x };\nif res { /* ... */ }\n\nlet res = { let e = somefunc(); e };\nmatch res {\n    // ...\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>block_in_if_condition_expr</li>\n<li>block_in_if_condition_stmt</li>\n<li>blocks_in_if_conditions</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "bool_assert_comparison",
    "rule_name": "bool_assert_comparison",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns about boolean comparisons in assert-like macros.</p>\n<h3>Why is this bad?</h3>\n<p>It is shorter to use the equivalent.</p>\n<h3>Example</h3>\n<pre><code>assert_eq!(\"a\".is_empty(), false);\nassert_ne!(\"a\".is_empty(), true);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>assert!(!\"a\".is_empty());\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "bool_comparison",
    "rule_name": "bool_comparison",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions of the form <code>x == true</code>,\n<code>x != true</code> and order comparisons such as <code>x < true</code> (or vice versa) and\nsuggest using the variable directly.</p>\n<h3>Why is this bad?</h3>\n<p>Unnecessary code.</p>\n<h3>Example</h3>\n<pre><code>if x == true {}\nif y == false {}\n</code></pre>\n<p>use <code>x</code> directly:</p>\n<pre><code>if x {}\nif !y {}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "bool_to_int_with_if",
    "rule_name": "bool_to_int_with_if",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Instead of using an if statement to convert a bool to an int,\nthis lint suggests using a <code>from()</code> function or an <code>as</code> coercion.</p>\n<h3>Why is this bad?</h3>\n<p>Coercion or <code>from()</code> is another way to convert bool to a number.\nBoth methods are guaranteed to return 1 for true, and 0 for false.</p>\n<p>See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E</p>\n<h3>Example</h3>\n<pre><code>if condition {\n    1_i64\n} else {\n    0\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>i64::from(condition);\n</code></pre>\n<p>or</p>\n<pre><code>condition as i64;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "borrow_as_ptr",
    "rule_name": "borrow_as_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of <code>&expr as *const T</code> or\n<code>&mut expr as *mut T</code>, and suggest using <code>&raw const</code> or\n<code>&raw mut</code> instead.</p>\n<h3>Why is this bad?</h3>\n<p>This would improve readability and avoid creating a reference\nthat points to an uninitialized value or unaligned place.\nRead the <code>&raw</code> explanation in the Reference for more information.</p>\n<h3>Example</h3>\n<pre><code>let val = 1;\nlet p = &val as *const i32;\n\nlet mut val_mut = 1;\nlet p_mut = &mut val_mut as *mut i32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let val = 1;\nlet p = &raw const val;\n\nlet mut val_mut = 1;\nlet p_mut = &raw mut val_mut;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "borrow_deref_ref",
    "rule_name": "borrow_deref_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>&*(&T)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Dereferencing and then borrowing a reference value has no effect in most cases.</p>\n<h3>Known problems</h3>\n<p>False negative on such code:</p>\n<pre><code>let x = &12;\nlet addr_x = &x as *const _ as usize;\nlet addr_y = &&*x as *const _ as usize; // assert ok now, and lint triggered.\n                                        // But if we fix it, assert will fail.\nassert_ne!(addr_x, addr_y);\n</code></pre>\n<h3>Example</h3>\n<pre><code>let s = &String::new();\n\nlet a: &String = &* s;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a: &String = s;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "borrow_interior_mutable_const",
    "rule_name": "borrow_interior_mutable_const",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if <code>const</code> items which is interior mutable (e.g.,\ncontains a <code>Cell</code>, <code>Mutex</code>, <code>AtomicXxxx</code>, etc.) has been borrowed directly.</p>\n<h3>Why is this bad?</h3>\n<p>Consts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the <code>Cell</code> or <code>Mutex</code>\nor <code>AtomicXxxx</code> will be created, which defeats the whole purpose of using\nthese types in the first place.</p>\n<p>The <code>const</code> value should be stored inside a <code>static</code> item.</p>\n<h3>Known problems</h3>\n<p>When an enum has variants with interior mutability, use of its non\ninterior mutable variants can generate false positives. See issue\n<a>#3962</a></p>\n<p>Types that have underlying or potential interior mutability trigger the lint whether\nthe interior mutable field is used or not. See issues\n<a>#5812</a> and\n<a>#3825</a></p>\n<h3>Example</h3>\n<pre><code>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n\nstatic STATIC_ATOM: AtomicUsize = CONST_ATOM;\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>\n<p>(default: <code>[\"bytes::Bytes\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "borrowed_box",
    "rule_name": "borrowed_box",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>&Box<T></code> anywhere in the code.\nCheck the <a>Box documentation</a> for more information.</p>\n<h3>Why is this bad?</h3>\n<p>A <code>&Box<T></code> parameter requires the function caller to box <code>T</code> first before passing it to a function.\nUsing <code>&T</code> defines a concrete type for the parameter and generalizes the function, this would also\nauto-deref to <code>&T</code> at the function call site if passed a <code>&Box<T></code>.</p>\n<h3>Example</h3>\n<pre><code>fn foo(bar: &Box<T>) { ... }\n</code></pre>\n<p>Better:</p>\n<pre><code>fn foo(bar: &T) { ... }\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "box_collection",
    "rule_name": "box_collection",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Box<T></code> where T is a collection such as Vec anywhere in the code.\nCheck the <a>Box documentation</a> for more information.</p>\n<h3>Why is this bad?</h3>\n<p>Collections already keeps their contents in a separate area on\nthe heap. So if you <code>Box</code> them, you just add another level of indirection\nwithout any benefit whatsoever.</p>\n<h3>Example</h3>\n<pre><code>struct X {\n    values: Box<Vec<Foo>>,\n}\n</code></pre>\n<p>Better:</p>\n<pre><code>struct X {\n    values: Vec<Foo>,\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>box_vec</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "box_default",
    "rule_name": "box_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>checks for <code>Box::new(Default::default())</code>, which can be written as\n<code>Box::default()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>Box::default()</code> is equivalent and more concise.</p>\n<h3>Example</h3>\n<pre><code>let x: Box<String> = Box::new(Default::default());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Box<String> = Box::default();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "boxed_local",
    "rule_name": "boxed_local",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Box<T></code> where an unboxed <code>T</code> would\nwork fine.</p>\n<h3>Why is this bad?</h3>\n<p>This is an unnecessary allocation, and bad for\nperformance. It is only necessary to allocate if you wish to move the box\ninto something.</p>\n<h3>Example</h3>\n<pre><code>fn foo(x: Box<u32>) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(x: u32) {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>too-large-for-stack</code>:  The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap</p>\n<p>(default: <code>200</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "branches_sharing_code",
    "rule_name": "branches_sharing_code",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if the <code>if</code> and <code>else</code> block contain shared code that can be\nmoved out of the blocks.</p>\n<h3>Why is this bad?</h3>\n<p>Duplicate code is less maintainable.</p>\n<h3>Known problems</h3>\n<ul>\n<li>The lint doesn\u2019t check if the moved expressions modify values that are being used in\nthe if condition. The suggestion can in that case modify the behavior of the program.\nSee <a>rust-clippy#7452</a></li>\n</ul>\n<h3>Example</h3>\n<pre><code>let foo = if \u2026 {\n    println!(\"Hello World\");\n    13\n} else {\n    println!(\"Hello World\");\n    42\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!(\"Hello World\");\nlet foo = if \u2026 {\n    13\n} else {\n    42\n};\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "builtin_type_shadow",
    "rule_name": "builtin_type_shadow",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if a generic shadows a built-in type.</p>\n<h3>Why is this bad?</h3>\n<p>This gives surprising type errors.</p>\n<h3>Example</h3>\n<pre><code>impl<u32> Foo<u32> {\n    fn impl_func(&self) -> u32 {\n        42\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "byte_char_slices",
    "rule_name": "byte_char_slices",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for hard to read slices of byte characters, that could be more easily expressed as a\nbyte string.</p>\n<h3>Why is this bad?</h3>\n<p>Potentially makes the string harder to read.</p>\n<h3>Example</h3>\n<pre><code>&[b'H', b'e', b'l', b'l', b'o'];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>b\"Hello\"\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "bytes_count_to_len",
    "rule_name": "bytes_count_to_len",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It checks for <code>str::bytes().count()</code> and suggests replacing it with\n<code>str::len()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>str::bytes().count()</code> is longer and may not be as performant as using\n<code>str::len()</code>.</p>\n<h3>Example</h3>\n<pre><code>\"hello\".bytes().count();\nString::from(\"hello\").bytes().count();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\"hello\".len();\nString::from(\"hello\").len();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "bytes_nth",
    "rule_name": "bytes_nth",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>.bytes().nth()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.as_bytes().get()</code> is more efficient and more\nreadable.</p>\n<h3>Example</h3>\n<pre><code>\"Hello\".bytes().nth(3);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\"Hello\".as_bytes().get(3);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "cargo_common_metadata",
    "rule_name": "cargo_common_metadata",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks to see if all common metadata is defined in\n<code>Cargo.toml</code>. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata</p>\n<h3>Why is this bad?</h3>\n<p>It will be more difficult for users to discover the\npurpose of the crate, and key information related to it.</p>\n<h3>Example</h3>\n<pre><code>[package]\nname = \"clippy\"\nversion = \"0.0.212\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n</code></pre>\n<p>Should include a description field like:</p>\n<pre><code>[package]\nname = \"clippy\"\nversion = \"0.0.212\"\ndescription = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>cargo-ignore-publish</code>:  For internal testing only, ignores the current <code>publish</code> settings in the Cargo manifest.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "cargo",
    "lint_level": "allow"
  },
  {
    "rule_id": "case_sensitive_file_extension_comparisons",
    "rule_name": "case_sensitive_file_extension_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>ends_with</code> with possible file extensions\nand suggests to use a case-insensitive approach instead.</p>\n<h3>Why is this bad?</h3>\n<p><code>ends_with</code> is case-sensitive and may not detect files with a valid extension.</p>\n<h3>Example</h3>\n<pre><code>fn is_rust_file(filename: &str) -> bool {\n    filename.ends_with(\".rs\")\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn is_rust_file(filename: &str) -> bool {\n    let filename = std::path::Path::new(filename);\n    filename.extension()\n        .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_abs_to_unsigned",
    "rule_name": "cast_abs_to_unsigned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of the <code>abs()</code> method that cast the result to unsigned.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>unsigned_abs()</code> method avoids panic when called on the MIN value.</p>\n<h3>Example</h3>\n<pre><code>let x: i32 = -42;\nlet y: u32 = x.abs() as u32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: i32 = -42;\nlet y: u32 = x.unsigned_abs();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "cast_enum_constructor",
    "rule_name": "cast_enum_constructor",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts from an enum tuple constructor to an integer.</p>\n<h3>Why is this bad?</h3>\n<p>The cast is easily confused with casting a c-like enum value to an integer.</p>\n<h3>Example</h3>\n<pre><code>enum E { X(i32) };\nlet _ = E::X as usize;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "cast_enum_truncation",
    "rule_name": "cast_enum_truncation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts from an enum type to an integral type that will definitely truncate the\nvalue.</p>\n<h3>Why is this bad?</h3>\n<p>The resulting integral value will not match the value of the variant it came from.</p>\n<h3>Example</h3>\n<pre><code>enum E { X = 256 };\nlet _ = E::X as u8;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "cast_lossless",
    "rule_name": "cast_lossless",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts between numeric types that can be replaced by safe\nconversion functions.</p>\n<h3>Why is this bad?</h3>\n<p>Rust\u2019s <code>as</code> keyword will perform many kinds of conversions, including\nsilently lossy conversions. Conversion functions such as <code>i32::from</code>\nwill only perform lossless conversions. Using the conversion functions\nprevents conversions from becoming silently lossy if the input types\never change, and makes it clear for people reading the code that the\nconversion is lossless.</p>\n<h3>Example</h3>\n<pre><code>fn as_u64(x: u8) -> u64 {\n    x as u64\n}\n</code></pre>\n<p>Using <code>::from</code> would look like this:</p>\n<pre><code>fn as_u64(x: u8) -> u64 {\n    u64::from(x)\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_nan_to_int",
    "rule_name": "cast_nan_to_int",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a known NaN float being cast to an integer</p>\n<h3>Why is this bad?</h3>\n<p>NaNs are cast into zero, so one could simply use this and make the\ncode more readable. The lint could also hint at a programmer error.</p>\n<h3>Example</h3>\n<pre><code>let _ = (0.0_f32 / 0.0) as u64;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = 0_u64;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "cast_possible_truncation",
    "rule_name": "cast_possible_truncation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts between numeric types that may\ntruncate large values. This is expected behavior, so the cast is <code>Allow</code> by\ndefault. It suggests user either explicitly ignore the lint,\nor use <code>try_from()</code> and handle the truncation, default, or panic explicitly.</p>\n<h3>Why is this bad?</h3>\n<p>In some problem domains, it is good practice to avoid\ntruncation. This lint can be activated to help assess where additional\nchecks could be beneficial.</p>\n<h3>Example</h3>\n<pre><code>fn as_u8(x: u64) -> u8 {\n    x as u8\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn as_u8(x: u64) -> u8 {\n    if let Ok(x) = u8::try_from(x) {\n        x\n    } else {\n        todo!();\n    }\n}\n// Or\n#[allow(clippy::cast_possible_truncation)]\nfn as_u16(x: u64) -> u16 {\n    x as u16\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_possible_wrap",
    "rule_name": "cast_possible_wrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts from an unsigned type to a signed type of\nthe same size, or possibly smaller due to target-dependent integers.\nPerforming such a cast is a no-op for the compiler (that is, nothing is\nchanged at the bit level), and the binary representation of the value is\nreinterpreted. This can cause wrapping if the value is too big\nfor the target signed type. However, the cast works as defined, so this lint\nis <code>Allow</code> by default.</p>\n<h3>Why is this bad?</h3>\n<p>While such a cast is not bad in itself, the results can\nbe surprising when this is not the intended behavior:</p>\n<h3>Example</h3>\n<pre><code>u32::MAX as i32; // will yield a value of `-1`\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_precision_loss",
    "rule_name": "cast_precision_loss",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts from any numeric type to a float type where\nthe receiving type cannot store all values from the original type without\nrounding errors. This possible rounding is to be expected, so this lint is\n<code>Allow</code> by default.</p>\n<p>Basically, this warns on casting any integer with 32 or more bits to <code>f32</code>\nor any 64-bit integer to <code>f64</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s not bad at all. But in some applications it can be\nhelpful to know where precision loss can take place. This lint can help find\nthose places in the code.</p>\n<h3>Example</h3>\n<pre><code>let x = u64::MAX;\nx as f64;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_ptr_alignment",
    "rule_name": "cast_ptr_alignment",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts, using <code>as</code> or <code>pointer::cast</code>, from a\nless strictly aligned pointer to a more strictly aligned pointer.</p>\n<h3>Why is this bad?</h3>\n<p>Dereferencing the resulting pointer may be undefined behavior.</p>\n<h3>Known problems</h3>\n<p>Using <a><code>std::ptr::read_unaligned</code></a> and <a><code>std::ptr::write_unaligned</code></a> or\nsimilar on the resulting pointer is fine. Is over-zealous: casts with\nmanual alignment checks or casts like <code>u64</code> -> <code>u8</code> -> <code>u16</code> can be\nfine. Miri is able to do a more in-depth analysis.</p>\n<h3>Example</h3>\n<pre><code>let _ = (&1u8 as *const u8) as *const u16;\nlet _ = (&mut 1u8 as *mut u8) as *mut u16;\n\n(&1u8 as *const u8).cast::<u16>();\n(&mut 1u8 as *mut u8).cast::<u16>();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_sign_loss",
    "rule_name": "cast_sign_loss",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts from a signed to an unsigned numeric\ntype. In this case, negative values wrap around to large positive values,\nwhich can be quite surprising in practice. However, since the cast works as\ndefined, this lint is <code>Allow</code> by default.</p>\n<h3>Why is this bad?</h3>\n<p>Possibly surprising results. You can activate this lint\nas a one-time check to see where numeric wrapping can arise.</p>\n<h3>Example</h3>\n<pre><code>let y: i8 = -1;\ny as u128; // will return 18446744073709551615\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cast_slice_different_sizes",
    "rule_name": "cast_slice_different_sizes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>as</code> casts between raw pointers to slices with differently sized elements.</p>\n<h3>Why is this bad?</h3>\n<p>The produced raw pointer to a slice does not update its length metadata. The produced\npointer will point to a different number of bytes than the original pointer because the\nlength metadata of a raw slice pointer is in elements rather than bytes.\nProducing a slice reference from the raw pointer will either create a slice with\nless data (which can be surprising) or create a slice with more data and cause Undefined Behavior.</p>\n<h3>Example</h3>\n<p>// Missing data</p>\n<pre><code>let a = [1_i32, 2, 3, 4];\nlet p = &a as *const [i32] as *const [u8];\nunsafe {\n    println!(\"{:?}\", &*p);\n}\n</code></pre>\n<p>// Undefined Behavior (note: also potential alignment issues)</p>\n<pre><code>let a = [1_u8, 2, 3, 4];\nlet p = &a as *const [u8] as *const [u32];\nunsafe {\n    println!(\"{:?}\", &*p);\n}\n</code></pre>\n<p>Instead use <code>ptr::slice_from_raw_parts</code> to construct a slice from a data pointer and the correct length</p>\n<pre><code>let a = [1_i32, 2, 3, 4];\nlet old_ptr = &a as *const [i32];\n// The data pointer is cast to a pointer to the target `u8` not `[u8]`\n// The length comes from the known length of 4 i32s times the 4 bytes per i32\nlet new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\nunsafe {\n    println!(\"{:?}\", &*new_ptr);\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "cast_slice_from_raw_parts",
    "rule_name": "cast_slice_from_raw_parts",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a raw slice being cast to a slice pointer</p>\n<h3>Why is this bad?</h3>\n<p>This can result in multiple <code>&mut</code> references to the same location when only a pointer is\nrequired.\n<code>ptr::slice_from_raw_parts</code> is a safe alternative that doesn\u2019t require\nthe same <a>safety requirements</a> to be upheld.</p>\n<h3>Example</h3>\n<pre><code>let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\nlet _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\nlet _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "cfg_not_test",
    "rule_name": "cfg_not_test",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>cfg</code> that excludes code from <code>test</code> builds. (i.e., <code>#[cfg(not(test))]</code>)</p>\n<h3>Why is this bad?</h3>\n<p>This may give the false impression that a codebase has 100% coverage, yet actually has untested code.\nEnabling this also guards against excessive mockery as well, which is an anti-pattern.</p>\n<h3>Example</h3>\n<pre><code>#[cfg(not(test))]\nimportant_check(); // I'm not actually tested, but not including me will falsely increase coverage!\n</code></pre>\n<p>Use instead:</p>\n<pre><code>important_check();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "char_lit_as_u8",
    "rule_name": "char_lit_as_u8",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions where a character literal is cast\nto <code>u8</code> and suggests using a byte literal instead.</p>\n<h3>Why is this bad?</h3>\n<p>In general, casting values to smaller types is\nerror-prone and should be avoided where possible. In the particular case of\nconverting a character literal to <code>u8</code>, it is easy to avoid by just using a\nbyte literal instead. As an added bonus, <code>b'a'</code> is also slightly shorter\nthan <code>'a' as u8</code>.</p>\n<h3>Example</h3>\n<pre><code>'x' as u8\n</code></pre>\n<p>A better version, using the byte literal:</p>\n<pre><code>b'x'\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "chars_last_cmp",
    "rule_name": "chars_last_cmp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.chars().last()</code> or\n<code>_.chars().next_back()</code> on a <code>str</code> to check if it ends with a given char.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.ends_with(_)</code>.</p>\n<h3>Example</h3>\n<pre><code>name.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n</code></pre>\n<p>Use instead:</p>\n<pre><code>name.ends_with('_') || name.ends_with('-');\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "chars_next_cmp",
    "rule_name": "chars_next_cmp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.chars().next()</code> on a <code>str</code> to check\nif it starts with a given char.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.starts_with(_)</code>.</p>\n<h3>Example</h3>\n<pre><code>let name = \"foo\";\nif name.chars().next() == Some('_') {};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let name = \"foo\";\nif name.starts_with('_') {};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "checked_conversions",
    "rule_name": "checked_conversions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for explicit bounds checking when casting.</p>\n<h3>Why is this bad?</h3>\n<p>Reduces the readability of statements & is error prone.</p>\n<h3>Example</h3>\n<pre><code>foo <= i32::MAX as u32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>i32::try_from(foo).is_ok();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "clear_with_drain",
    "rule_name": "clear_with_drain",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.drain(..)</code> for the sole purpose of clearing a container.</p>\n<h3>Why is this bad?</h3>\n<p>This creates an unnecessary iterator that is dropped immediately.</p>\n<p>Calling <code>.clear()</code> also makes the intent clearer.</p>\n<h3>Example</h3>\n<pre><code>let mut v = vec![1, 2, 3];\nv.drain(..);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut v = vec![1, 2, 3];\nv.clear();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "clone_on_copy",
    "rule_name": "clone_on_copy",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.clone()</code> on a <code>Copy</code> type.</p>\n<h3>Why is this bad?</h3>\n<p>The only reason <code>Copy</code> types implement <code>Clone</code> is for\ngenerics, not for using the <code>clone</code> method on a concrete type.</p>\n<h3>Example</h3>\n<pre><code>42u64.clone();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "clone_on_ref_ptr",
    "rule_name": "clone_on_ref_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.clone()</code> on a ref-counted pointer,\n(<code>Rc</code>, <code>Arc</code>, <code>rc::Weak</code>, or <code>sync::Weak</code>), and suggests calling Clone via unified\nfunction syntax instead (e.g., <code>Rc::clone(foo)</code>).</p>\n<h3>Why restrict this?</h3>\n<p>Calling <code>.clone()</code> on an <code>Rc</code>, <code>Arc</code>, or <code>Weak</code>\ncan obscure the fact that only the pointer is being cloned, not the underlying\ndata.</p>\n<h3>Example</h3>\n<pre><code>let x = Rc::new(1);\n\nx.clone();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>Rc::clone(&x);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "cloned_instead_of_copied",
    "rule_name": "cloned_instead_of_copied",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>cloned()</code> on an <code>Iterator</code> or <code>Option</code> where\n<code>copied()</code> could be used instead.</p>\n<h3>Why is this bad?</h3>\n<p><code>copied()</code> is better because it guarantees that the type being cloned\nimplements <code>Copy</code>.</p>\n<h3>Example</h3>\n<pre><code>[1, 2, 3].iter().cloned();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>[1, 2, 3].iter().copied();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "cmp_null",
    "rule_name": "cmp_null",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for equality comparisons with <code>ptr::null</code></p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s easier and more readable to use the inherent\n<code>.is_null()</code>\nmethod instead</p>\n<h3>Example</h3>\n<pre><code>use std::ptr;\n\nif x == ptr::null {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x.is_null() {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "cmp_owned",
    "rule_name": "cmp_owned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for conversions to owned values just for the sake\nof a comparison.</p>\n<h3>Why is this bad?</h3>\n<p>The comparison can operate on a reference, so creating\nan owned value effectively throws it away directly afterwards, which is\nneedlessly consuming code and heap space.</p>\n<h3>Example</h3>\n<pre><code>if x.to_owned() == y {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x == y {}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "cognitive_complexity",
    "rule_name": "cognitive_complexity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for methods with high cognitive complexity.</p>\n<h3>Why is this bad?</h3>\n<p>Methods of high cognitive complexity tend to be hard to\nboth read and maintain. Also LLVM will tend to optimize small methods better.</p>\n<h3>Known problems</h3>\n<p>Sometimes it\u2019s hard to find a way to reduce the\ncomplexity.</p>\n<h3>Example</h3>\n<p>You\u2019ll see it when you get the warning.</p>\n<h3>Past names</h3>\n<ul>\n<li>cyclomatic_complexity</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>cognitive-complexity-threshold</code>:  The maximum cognitive complexity a function can have</p>\n<p>(default: <code>25</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "collapsible_else_if",
    "rule_name": "collapsible_else_if",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for collapsible <code>else { if ... }</code> expressions\nthat can be collapsed to <code>else if ...</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Each <code>if</code>-statement adds one level of nesting, which\nmakes code look more complex than it really is.</p>\n<h3>Example</h3>\n<pre><code>\nif x {\n    \u2026\n} else {\n    if y {\n        \u2026\n    }\n}\n</code></pre>\n<p>Should be written:</p>\n<pre><code>if x {\n    \u2026\n} else if y {\n    \u2026\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "collapsible_if",
    "rule_name": "collapsible_if",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for nested <code>if</code> statements which can be collapsed\nby <code>&&</code>-combining their conditions.</p>\n<h3>Why is this bad?</h3>\n<p>Each <code>if</code>-statement adds one level of nesting, which\nmakes code look more complex than it really is.</p>\n<h3>Example</h3>\n<pre><code>if x {\n    if y {\n        // \u2026\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x && y {\n    // \u2026\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "collapsible_match",
    "rule_name": "collapsible_match",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds nested <code>match</code> or <code>if let</code> expressions where the patterns may be \u201ccollapsed\u201d together\nwithout adding any branches.</p>\n<p>Note that this lint is not intended to find <em>all</em> cases where nested match patterns can be merged, but only\ncases where merging would most likely make the code more readable.</p>\n<h3>Why is this bad?</h3>\n<p>It is unnecessarily verbose and complex.</p>\n<h3>Example</h3>\n<pre><code>fn func(opt: Option<Result<u64, String>>) {\n    let n = match opt {\n        Some(n) => match n {\n            Ok(n) => n,\n            _ => return,\n        }\n        None => return,\n    };\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn func(opt: Option<Result<u64, String>>) {\n    let n = match opt {\n        Some(Ok(n)) => n,\n        _ => return,\n    };\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "collapsible_str_replace",
    "rule_name": "collapsible_str_replace",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for consecutive calls to <code>str::replace</code> (2 or more)\nthat can be collapsed into a single call.</p>\n<h3>Why is this bad?</h3>\n<p>Consecutive <code>str::replace</code> calls scan the string multiple times\nwith repetitive code.</p>\n<h3>Example</h3>\n<pre><code>let hello = \"hesuo worpd\"\n    .replace('s', \"l\")\n    .replace(\"u\", \"l\")\n    .replace('p', \"l\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let hello = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\");\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "collection_is_never_read",
    "rule_name": "collection_is_never_read",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for collections that are never queried.</p>\n<h3>Why is this bad?</h3>\n<p>Putting effort into constructing a collection but then never querying it might indicate that\nthe author forgot to do whatever they intended to do with the collection. Example: Clone\na vector, sort it for iteration, but then mistakenly iterate the original vector\ninstead.</p>\n<h3>Example</h3>\n<pre><code>let mut sorted_samples = samples.clone();\nsorted_samples.sort();\nfor sample in &samples { // Oops, meant to use `sorted_samples`.\n    println!(\"{sample}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut sorted_samples = samples.clone();\nsorted_samples.sort();\nfor sample in &sorted_samples {\n    println!(\"{sample}\");\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "comparison_chain",
    "rule_name": "comparison_chain",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks comparison chains written with <code>if</code> that can be\nrewritten with <code>match</code> and <code>cmp</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>if</code> is not guaranteed to be exhaustive and conditionals can get\nrepetitive</p>\n<h3>Known problems</h3>\n<p>The match statement may be slower due to the compiler\nnot inlining the call to cmp. See issue <a>#5354</a></p>\n<h3>Example</h3>\n<pre><code>fn f(x: u8, y: u8) {\n    if x > y {\n        a()\n    } else if x < y {\n        b()\n    } else {\n        c()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::cmp::Ordering;\nfn f(x: u8, y: u8) {\n     match x.cmp(&y) {\n         Ordering::Greater => a(),\n         Ordering::Less => b(),\n         Ordering::Equal => c()\n     }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "comparison_to_empty",
    "rule_name": "comparison_to_empty",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for comparing to an empty slice such as <code>\"\"</code> or <code>[]</code>,\nand suggests using <code>.is_empty()</code> where applicable.</p>\n<h3>Why is this bad?</h3>\n<p>Some structures can answer <code>.is_empty()</code> much faster\nthan checking for equality. So it is good to get into the habit of using\n<code>.is_empty()</code>, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.</p>\n<h3>Example</h3>\n<pre><code>if s == \"\" {\n    ..\n}\n\nif arr == [] {\n    ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if s.is_empty() {\n    ..\n}\n\nif arr.is_empty() {\n    ..\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "const_is_empty",
    "rule_name": "const_is_empty",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It identifies calls to <code>.is_empty()</code> on constant values.</p>\n<h3>Why is this bad?</h3>\n<p>String literals and constant values are known at compile time. Checking if they\nare empty will always return the same value. This might not be the intention of\nthe expression.</p>\n<h3>Example</h3>\n<pre><code>let value = \"\";\nif value.is_empty() {\n    println!(\"the string is empty\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!(\"the string is empty\");\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "copy_iterator",
    "rule_name": "copy_iterator",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for types that implement <code>Copy</code> as well as\n<code>Iterator</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Implicit copies can be confusing when working with\niterator combinators.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Copy, Clone)]\nstruct Countdown(u8);\n\nimpl Iterator for Countdown {\n    // ...\n}\n\nlet a: Vec<_> = my_iterator.take(1).collect();\nlet b: Vec<_> = my_iterator.collect();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "crate_in_macro_def",
    "rule_name": "crate_in_macro_def",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>crate</code> as opposed to <code>$crate</code> in a macro definition.</p>\n<h3>Why is this bad?</h3>\n<p><code>crate</code> refers to the macro call\u2019s crate, whereas <code>$crate</code> refers to the macro definition\u2019s\ncrate. Rarely is the former intended. See:\nhttps://doc.rust-lang.org/reference/macros-by-example.html#hygiene</p>\n<h3>Example</h3>\n<pre><code>#[macro_export]\nmacro_rules! print_message {\n    () => {\n        println!(\"{}\", crate::MESSAGE);\n    };\n}\npub const MESSAGE: &str = \"Hello!\";\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[macro_export]\nmacro_rules! print_message {\n    () => {\n        println!(\"{}\", $crate::MESSAGE);\n    };\n}\npub const MESSAGE: &str = \"Hello!\";\n</code></pre>\n<p>Note that if the use of <code>crate</code> is intentional, an <code>allow</code> attribute can be applied to the\nmacro definition, e.g.:</p>\n<pre><code>#[allow(clippy::crate_in_macro_def)]\nmacro_rules! ok { ... crate::foo ... }\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "create_dir",
    "rule_name": "create_dir",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks usage of <code>std::fs::create_dir</code> and suggest using <code>std::fs::create_dir_all</code> instead.</p>\n<h3>Why restrict this?</h3>\n<p>Sometimes <code>std::fs::create_dir</code> is mistakenly chosen over <code>std::fs::create_dir_all</code>,\nresulting in failure when more than one directory needs to be created or when the directory already exists.\nCrates which never need to specifically create a single directory may wish to prevent this mistake.</p>\n<h3>Example</h3>\n<pre><code>std::fs::create_dir(\"foo\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>std::fs::create_dir_all(\"foo\");\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "crosspointer_transmute",
    "rule_name": "crosspointer_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes between a type <code>T</code> and <code>*T</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s easy to mistakenly transmute between a type and a\npointer to that type.</p>\n<h3>Example</h3>\n<pre><code>core::intrinsics::transmute(t) // where the result type is the same as\n                               // `*t` or `&t`'s\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "dbg_macro",
    "rule_name": "dbg_macro",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of the <a><code>dbg!</code></a> macro.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>dbg!</code> macro is intended as a debugging tool. It should not be present in released\nsoftware or committed to a version control system.</p>\n<h3>Example</h3>\n<pre><code>dbg!(true)\n</code></pre>\n<p>Use instead:</p>\n<pre><code>true\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-dbg-in-tests</code>:  Whether <code>dbg!</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "debug_assert_with_mut_call",
    "rule_name": "debug_assert_with_mut_call",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for function/method calls with a mutable\nparameter in <code>debug_assert!</code>, <code>debug_assert_eq!</code> and <code>debug_assert_ne!</code> macros.</p>\n<h3>Why is this bad?</h3>\n<p>In release builds <code>debug_assert!</code> macros are optimized out by the\ncompiler.\nTherefore mutating something in a <code>debug_assert!</code> macro results in different behavior\nbetween a release and debug build.</p>\n<h3>Example</h3>\n<pre><code>debug_assert_eq!(vec![3].pop(), Some(3));\n\n// or\n\ndebug_assert!(takes_a_mut_parameter(&mut x));\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "decimal_literal_representation",
    "rule_name": "decimal_literal_representation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if there is a better representation for a numeric literal.</p>\n<h3>Why restrict this?</h3>\n<p>Especially for big powers of 2, a hexadecimal representation is usually more\nreadable than a decimal representation.</p>\n<h3>Example</h3>\n<pre><code>`255` => `0xFF`\n`65_535` => `0xFFFF`\n`4_042_322_160` => `0xF0F0_F0F0`\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>literal-representation-threshold</code>:  The lower bound for linting decimal literals</p>\n<p>(default: <code>16384</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "declare_interior_mutable_const",
    "rule_name": "declare_interior_mutable_const",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for declaration of <code>const</code> items which is interior\nmutable (e.g., contains a <code>Cell</code>, <code>Mutex</code>, <code>AtomicXxxx</code>, etc.).</p>\n<h3>Why is this bad?</h3>\n<p>Consts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the <code>Cell</code> or <code>Mutex</code>\nor <code>AtomicXxxx</code> will be created, which defeats the whole purpose of using\nthese types in the first place.</p>\n<p>The <code>const</code> should better be replaced by a <code>static</code> item if a global\nvariable is wanted, or replaced by a <code>const fn</code> if a constructor is wanted.</p>\n<h3>Known problems</h3>\n<p>A \u201cnon-constant\u201d const item is a legacy way to supply an\ninitialized value to downstream <code>static</code> items (e.g., the\n<code>std::sync::ONCE_INIT</code> constant). In this case the use of <code>const</code> is legit,\nand this lint should be suppressed.</p>\n<p>Even though the lint avoids triggering on a constant whose type has enums that have variants\nwith interior mutability, and its value uses non interior mutable variants (see\n<a>#3962</a> and\n<a>#3825</a> for examples);\nit complains about associated constants without default values only based on its types;\nwhich might not be preferable.\nThere\u2019re other enums plus associated constants cases that the lint cannot handle.</p>\n<p>Types that have underlying or potential interior mutability trigger the lint whether\nthe interior mutable field is used or not. See issue\n<a>#5812</a></p>\n<h3>Example</h3>\n<pre><code>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n</code></pre>\n<p>Use instead:</p>\n<pre><code>static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>\n<p>(default: <code>[\"bytes::Bytes\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "default_constructed_unit_structs",
    "rule_name": "default_constructed_unit_structs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for construction on unit struct using <code>default</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This adds code complexity and an unnecessary function call.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Default)]\nstruct S<T> {\n    _marker: PhantomData<T>\n}\n\nlet _: S<i32> = S {\n    _marker: PhantomData::default()\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct S<T> {\n    _marker: PhantomData<T>\n}\n\nlet _: S<i32> = S {\n    _marker: PhantomData\n};\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "default_instead_of_iter_empty",
    "rule_name": "default_instead_of_iter_empty",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It checks for <code>std::iter::Empty::default()</code> and suggests replacing it with\n<code>std::iter::empty()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>std::iter::empty()</code> is the more idiomatic way.</p>\n<h3>Example</h3>\n<pre><code>let _ = std::iter::Empty::<usize>::default();\nlet iter: std::iter::Empty<usize> = std::iter::Empty::default();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = std::iter::empty::<usize>();\nlet iter: std::iter::Empty<usize> = std::iter::empty();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "default_numeric_fallback",
    "rule_name": "default_numeric_fallback",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\ninference.</p>\n<p>Default numeric fallback means that if numeric types have not yet been bound to concrete\ntypes at the end of type inference, then integer type is bound to <code>i32</code>, and similarly\nfloating type is bound to <code>f64</code>.</p>\n<p>See <a>RFC0212</a> for more information about the fallback.</p>\n<h3>Why restrict this?</h3>\n<p>To ensure that every numeric type is chosen explicitly rather than implicitly.</p>\n<h3>Known problems</h3>\n<p>This lint is implemented using a custom algorithm independent of rustc\u2019s inference,\nwhich results in many false positives and false negatives.</p>\n<h3>Example</h3>\n<pre><code>let i = 10;\nlet f = 1.23;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let i = 10_i32;\nlet f = 1.23_f64;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "default_trait_access",
    "rule_name": "default_trait_access",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for literal calls to <code>Default::default()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s easier for the reader if the name of the type is used, rather than the\ngeneric <code>Default</code>.</p>\n<h3>Example</h3>\n<pre><code>let s: String = Default::default();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s = String::default();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "default_union_representation",
    "rule_name": "default_union_representation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Displays a warning when a union is declared with the default representation (without a <code>#[repr(C)]</code> attribute).</p>\n<h3>Why restrict this?</h3>\n<p>Unions in Rust have unspecified layout by default, despite many people thinking that they\nlay out each field at the start of the union (like C does). That is, there are no guarantees\nabout the offset of the fields for unions with multiple non-ZST fields without an explicitly\nspecified layout. These cases may lead to undefined behavior in unsafe blocks.</p>\n<h3>Example</h3>\n<pre><code>union Foo {\n    a: i32,\n    b: u32,\n}\n\nfn main() {\n    let _x: u32 = unsafe {\n        Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n    };\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[repr(C)]\nunion Foo {\n    a: i32,\n    b: u32,\n}\n\nfn main() {\n    let _x: u32 = unsafe {\n        Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n    };\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "deprecated_cfg_attr",
    "rule_name": "deprecated_cfg_attr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> and suggests to replace it\nwith <code>#[rustfmt::skip]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Since tool_attributes (<a>rust-lang/rust#44690</a>)\nare stable now, they should be used instead of the old <code>cfg_attr(rustfmt)</code> attributes.</p>\n<h3>Known problems</h3>\n<p>This lint doesn\u2019t detect crate level inner attributes, because they get\nprocessed before the PreExpansionPass lints get executed. See\n<a>#3123</a></p>\n<h3>Example</h3>\n<pre><code>#[cfg_attr(rustfmt, rustfmt_skip)]\nfn main() { }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[rustfmt::skip]\nfn main() { }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "deprecated_clippy_cfg_attr",
    "rule_name": "deprecated_clippy_cfg_attr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[cfg_attr(feature = \"cargo-clippy\", ...)]</code> and for\n<code>#[cfg(feature = \"cargo-clippy\")]</code> and suggests to replace it with\n<code>#[cfg_attr(clippy, ...)]</code> or <code>#[cfg(clippy)]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This feature has been deprecated for years and shouldn\u2019t be used anymore.</p>\n<h3>Example</h3>\n<pre><code>#[cfg(feature = \"cargo-clippy\")]\nstruct Bar;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[cfg(clippy)]\nstruct Bar;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "deprecated_semver",
    "rule_name": "deprecated_semver",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[deprecated]</code> annotations with a <code>since</code>\nfield that is not a valid semantic version. Also allows \u201cTBD\u201d to signal\nfuture deprecation.</p>\n<h3>Why is this bad?</h3>\n<p>For checking the version of the deprecation, it must be\na valid semver. Failing that, the contained information is useless.</p>\n<h3>Example</h3>\n<pre><code>#[deprecated(since = \"forever\")]\nfn something_else() { /* ... */ }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "deref_addrof",
    "rule_name": "deref_addrof",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>*&</code> and <code>*&mut</code> in expressions.</p>\n<h3>Why is this bad?</h3>\n<p>Immediately dereferencing a reference is no-op and\nmakes the code less clear.</p>\n<h3>Known problems</h3>\n<p>Multiple dereference/addrof pairs are not handled so\nthe suggested fix for <code>x = **&&y</code> is <code>x = *&y</code>, which is still incorrect.</p>\n<h3>Example</h3>\n<pre><code>let a = f(*&mut b);\nlet c = *&d;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = f(b);\nlet c = d;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "deref_by_slicing",
    "rule_name": "deref_by_slicing",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for slicing expressions which are equivalent to dereferencing the\nvalue.</p>\n<h3>Why restrict this?</h3>\n<p>Some people may prefer to dereference rather than slice.</p>\n<h3>Example</h3>\n<pre><code>let vec = vec![1, 2, 3];\nlet slice = &vec[..];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let vec = vec![1, 2, 3];\nlet slice = &*vec;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "derivable_impls",
    "rule_name": "derivable_impls",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects manual <code>std::default::Default</code> implementations that are identical to a derived implementation.</p>\n<h3>Why is this bad?</h3>\n<p>It is less concise.</p>\n<h3>Example</h3>\n<pre><code>struct Foo {\n    bar: bool\n}\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Self {\n            bar: false\n        }\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[derive(Default)]\nstruct Foo {\n    bar: bool\n}\n</code></pre>\n<h3>Known problems</h3>\n<p>Derive macros <a>sometimes use incorrect bounds</a>\nin generic types and the user defined <code>impl</code> may be more generalized or\nspecialized than what derive will produce. This lint can\u2019t detect the manual <code>impl</code>\nhas exactly equal bounds, and therefore this lint is disabled for types with\ngeneric parameters.</p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "derive_ord_xor_partial_ord",
    "rule_name": "derive_ord_xor_partial_ord",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints against manual <code>PartialOrd</code> and <code>Ord</code> implementations for types with a derived <code>Ord</code>\nor <code>PartialOrd</code> implementation.</p>\n<h3>Why is this bad?</h3>\n<p>The implementation of these traits must agree (for\nexample for use with <code>sort</code>) so it\u2019s probably a bad idea to use a\ndefault-generated <code>Ord</code> implementation with an explicitly defined\n<code>PartialOrd</code>. In particular, the following must hold for any type\nimplementing <code>Ord</code>:</p>\n<pre><code>k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n</code></pre>\n<h3>Example</h3>\n<pre><code>#[derive(Ord, PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\n    ...\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[derive(PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n       Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Foo {\n    ...\n}\n</code></pre>\n<p>or, if you don\u2019t need a custom ordering:</p>\n<pre><code>#[derive(Ord, PartialOrd, PartialEq, Eq)]\nstruct Foo;\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "derive_partial_eq_without_eq",
    "rule_name": "derive_partial_eq_without_eq",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for types that derive <code>PartialEq</code> and could implement <code>Eq</code>.</p>\n<h3>Why is this bad?</h3>\n<p>If a type <code>T</code> derives <code>PartialEq</code> and all of its members implement <code>Eq</code>,\nthen <code>T</code> can always implement <code>Eq</code>. Implementing <code>Eq</code> allows <code>T</code> to be used\nin APIs that require <code>Eq</code> types. It also allows structs containing <code>T</code> to derive\n<code>Eq</code> themselves.</p>\n<h3>Example</h3>\n<pre><code>#[derive(PartialEq)]\nstruct Foo {\n    i_am_eq: i32,\n    i_am_eq_too: Vec<String>,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[derive(PartialEq, Eq)]\nstruct Foo {\n    i_am_eq: i32,\n    i_am_eq_too: Vec<String>,\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "derived_hash_with_manual_eq",
    "rule_name": "derived_hash_with_manual_eq",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints against manual <code>PartialEq</code> implementations for types with a derived <code>Hash</code>\nimplementation.</p>\n<h3>Why is this bad?</h3>\n<p>The implementation of these traits must agree (for\nexample for use with <code>HashMap</code>) so it\u2019s probably a bad idea to use a\ndefault-generated <code>Hash</code> implementation with an explicitly defined\n<code>PartialEq</code>. In particular, the following must hold for any type:</p>\n<pre><code>k1 == k2 \u21d2 hash(k1) == hash(k2)\n</code></pre>\n<h3>Example</h3>\n<pre><code>#[derive(Hash)]\nstruct Foo;\n\nimpl PartialEq for Foo {\n    ...\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>derive_hash_xor_eq</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "disallowed_macros",
    "rule_name": "disallowed_macros",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Denies the configured macros in clippy.toml</p>\n<p>Note: Even though this lint is warn-by-default, it will only trigger if\nmacros are defined in the clippy.toml file.</p>\n<h3>Why is this bad?</h3>\n<p>Some macros are undesirable in certain contexts, and it\u2019s beneficial to\nlint for them as needed.</p>\n<h3>Example</h3>\n<p>An example clippy.toml configuration:</p>\n<pre><code>disallowed-macros = [\n    # Can use a string as the path of the disallowed macro.\n    \"std::print\",\n    # Can also use an inline table with a `path` key.\n    { path = \"std::println\" },\n    # When using an inline table, can add a `reason` for why the macro\n    # is disallowed.\n    { path = \"serde::Serialize\", reason = \"no serializing\" },\n]\n</code></pre>\n<pre><code>use serde::Serialize;\n\nprintln!(\"warns\");\n\n// The diagnostic will contain the message \"no serializing\"\n#[derive(Serialize)]\nstruct Data {\n    name: String,\n    value: usize,\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>disallowed-macros</code>:  The list of disallowed macros, written as fully qualified paths.</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "disallowed_methods",
    "rule_name": "disallowed_methods",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Denies the configured methods and functions in clippy.toml</p>\n<p>Note: Even though this lint is warn-by-default, it will only trigger if\nmethods are defined in the clippy.toml file.</p>\n<h3>Why is this bad?</h3>\n<p>Some methods are undesirable in certain contexts, and it\u2019s beneficial to\nlint for them as needed.</p>\n<h3>Example</h3>\n<p>An example clippy.toml configuration:</p>\n<pre><code>disallowed-methods = [\n    # Can use a string as the path of the disallowed method.\n    \"std::boxed::Box::new\",\n    # Can also use an inline table with a `path` key.\n    { path = \"std::time::Instant::now\" },\n    # When using an inline table, can add a `reason` for why the method\n    # is disallowed.\n    { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n]\n</code></pre>\n<pre><code>let xs = vec![1, 2, 3, 4];\nxs.leak(); // Vec::leak is disallowed in the config.\n// The diagnostic contains the message \"no leaking memory\".\n\nlet _now = Instant::now(); // Instant::now is disallowed in the config.\n\nlet _box = Box::new(3); // Box::new is disallowed in the config.\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\nxs.push(123); // Vec::push is _not_ disallowed in the config.\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>disallowed_method</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>disallowed-methods</code>:  The list of disallowed methods, written as fully qualified paths.</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "disallowed_names",
    "rule_name": "disallowed_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of disallowed names for variables, such\nas <code>foo</code>.</p>\n<h3>Why is this bad?</h3>\n<p>These names are usually placeholder names and should be\navoided.</p>\n<h3>Example</h3>\n<pre><code>let foo = 3.14;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>blacklisted_name</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>disallowed-names</code>:  The list of disallowed names to lint about. NB: <code>bar</code> is not here since it has legitimate uses. The value\n<code>\"..\"</code> can be used as part of the list to indicate that the configured values should be appended to the\ndefault configuration of Clippy. By default, any configuration will replace the default value.</p>\n<p>(default: <code>[\"foo\", \"baz\", \"quux\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "disallowed_script_idents",
    "rule_name": "disallowed_script_idents",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of unicode scripts other than those explicitly allowed\nby the lint config.</p>\n<p>This lint doesn\u2019t take into account non-text scripts such as <code>Unknown</code> and <code>Linear_A</code>.\nIt also ignores the <code>Common</code> script type.\nWhile configuring, be sure to use official script name <a>aliases</a> from\n<a>the list of supported scripts</a>.</p>\n<p>See also: <a><code>non_ascii_idents</code></a>.</p>\n<h3>Why restrict this?</h3>\n<p>It may be not desired to have many different scripts for\nidentifiers in the codebase.</p>\n<p>Note that if you only want to allow typical English, you might want to use\nbuilt-in <a><code>non_ascii_idents</code></a> lint instead.</p>\n<h3>Example</h3>\n<pre><code>// Assuming that `clippy.toml` contains the following line:\n// allowed-scripts = [\"Latin\", \"Cyrillic\"]\nlet counter = 10; // OK, latin is allowed.\nlet \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\nlet z\u00e4hler = 10; // OK, it's still latin.\nlet \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allowed-scripts</code>:  The list of unicode scripts allowed to be used in the scope.</p>\n<p>(default: <code>[\"Latin\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "disallowed_types",
    "rule_name": "disallowed_types",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Denies the configured types in clippy.toml.</p>\n<p>Note: Even though this lint is warn-by-default, it will only trigger if\ntypes are defined in the clippy.toml file.</p>\n<h3>Why is this bad?</h3>\n<p>Some types are undesirable in certain contexts.</p>\n<h3>Example:</h3>\n<p>An example clippy.toml configuration:</p>\n<pre><code>disallowed-types = [\n    # Can use a string as the path of the disallowed type.\n    \"std::collections::BTreeMap\",\n    # Can also use an inline table with a `path` key.\n    { path = \"std::net::TcpListener\" },\n    # When using an inline table, can add a `reason` for why the type\n    # is disallowed.\n    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n]\n</code></pre>\n<pre><code>use std::collections::BTreeMap;\n// or its use\nlet x = std::collections::BTreeMap::new();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// A similar type that is allowed by the config\nuse std::collections::HashMap;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>disallowed_type</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>disallowed-types</code>:  The list of disallowed types, written as fully qualified paths.</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "diverging_sub_expression",
    "rule_name": "diverging_sub_expression",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for diverging calls that are not match arms or\nstatements.</p>\n<h3>Why is this bad?</h3>\n<p>It is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented.</p>\n<h3>Known problems</h3>\n<p>Someone might want to use <code>some_bool || panic!()</code> as a\nshorthand.</p>\n<h3>Example</h3>\n<pre><code>let a = b() || panic!() || c();\n// `c()` is dead, `panic!()` is only called if `b()` returns `false`\nlet x = (a, b, c, panic!());\n// can simply be replaced by `panic!()`\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "doc_include_without_cfg",
    "rule_name": "doc_include_without_cfg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if included files in doc comments are included only for <code>cfg(doc)</code>.</p>\n<h3>Why restrict this?</h3>\n<p>These files are not useful for compilation but will still be included.\nAlso, if any of these non-source code file is updated, it will trigger a\nrecompilation.</p>\n<h3>Known problems</h3>\n<p>Excluding this will currently result in the file being left out if\nthe item\u2019s docs are inlined from another crate. This may be fixed in a\nfuture version of rustdoc.</p>\n<h3>Example</h3>\n<pre><code>#![doc = include_str!(\"some_file.md\")]\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![cfg_attr(doc, doc = include_str!(\"some_file.md\"))]\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "doc_lazy_continuation",
    "rule_name": "doc_lazy_continuation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>In CommonMark Markdown, the language used to write doc comments, a\nparagraph nested within a list or block quote does not need any line\nafter the first one to be indented or marked. The specification calls\nthis a \u201clazy paragraph continuation.\u201d</p>\n<h3>Why is this bad?</h3>\n<p>This is easy to write but hard to read. Lazy continuations makes\nunintended markers hard to see, and make it harder to deduce the\ndocument\u2019s intended structure.</p>\n<h3>Example</h3>\n<p>This table is probably intended to have two rows,\nbut it does not. It has zero rows, and is followed by\na block quote.</p>\n<pre><code>/// Range | Description\n/// ----- | -----------\n/// >= 1  | fully opaque\n/// < 1   | partially see-through\nfn set_opacity(opacity: f32) {}\n</code></pre>\n<p>Fix it by escaping the marker:</p>\n<pre><code>/// Range | Description\n/// ----- | -----------\n/// \\>= 1 | fully opaque\n/// < 1   | partially see-through\nfn set_opacity(opacity: f32) {}\n</code></pre>\n<p>This example is actually intended to be a list:</p>\n<pre><code>/// * Do nothing.\n/// * Then do something. Whatever it is needs done,\n/// it should be done right now.\n</code></pre>\n<p>Fix it by indenting the list contents:</p>\n<pre><code>/// * Do nothing.\n/// * Then do something. Whatever it is needs done,\n///   it should be done right now.\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "doc_link_with_quotes",
    "rule_name": "doc_link_with_quotes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects the syntax <code>['foo']</code> in documentation comments (notice quotes instead of backticks)\noutside of code blocks</p>\n<h3>Why is this bad?</h3>\n<p>It is likely a typo when defining an intra-doc link</p>\n<h3>Example</h3>\n<pre><code>/// See also: ['foo']\nfn bar() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>/// See also: [`foo`]\nfn bar() {}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "doc_markdown",
    "rule_name": "doc_markdown",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the presence of <code>_</code>, <code>::</code> or camel-case words\noutside ticks in documentation.</p>\n<h3>Why is this bad?</h3>\n<p><em>Rustdoc</em> supports markdown formatting, <code>_</code>, <code>::</code> and\ncamel-case probably indicates some code which should be included between\nticks. <code>_</code> can also be used for emphasis in markdown, this lint tries to\nconsider that.</p>\n<h3>Known problems</h3>\n<p>Lots of bad docs won\u2019t be fixed, what the lint checks\nfor is limited, and there are still false positives. HTML elements and their\ncontent are not linted.</p>\n<p>In addition, when writing documentation comments, including <code>[]</code> brackets\ninside a link text would trip the parser. Therefore, documenting link with\n<code>[</code>SmallVec<[T; INLINE_CAPACITY]><code>]</code> and then [<code>SmallVec<[T; INLINE_CAPACITY]></code>]: SmallVec\nwould fail.</p>\n<h3>Examples</h3>\n<pre><code>/// Do something with the foo_bar parameter. See also\n/// that::other::module::foo.\n// ^ `foo_bar` and `that::other::module::foo` should be ticked.\nfn doit(foo_bar: usize) {}\n</code></pre>\n<pre><code>// Link text with `[]` brackets should be written as following:\n/// Consume the array and return the inner\n/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n/// [SmallVec]: SmallVec\nfn main() {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li><code>doc-valid-idents</code>:  The list of words this lint should not consider as identifiers needing ticks. The value\n<code>\"..\"</code> can be used as part of the list to indicate, that the configured values should be appended to the\ndefault configuration of Clippy. By default, any configuration will replace the default value. For example:</li>\n</ul>\n<ul>\n<li>\n<p><code>doc-valid-idents = [\"ClipPy\"]</code> would replace the default list with <code>[\"ClipPy\"]</code>.</p>\n</li>\n<li>\n<p><code>doc-valid-idents = [\"ClipPy\", \"..\"]</code> would append <code>ClipPy</code> to the default list.</p>\n<p>(default: <code>[\"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"MHz\", \"GHz\", \"THz\", \"AccessKit\", \"CoAP\", \"CoreFoundation\", \"CoreGraphics\", \"CoreText\", \"DevOps\", \"Direct2D\", \"Direct3D\", \"DirectWrite\", \"DirectX\", \"ECMAScript\", \"GPLv2\", \"GPLv3\", \"GitHub\", \"GitLab\", \"IPv4\", \"IPv6\", \"ClojureScript\", \"CoffeeScript\", \"JavaScript\", \"PostScript\", \"PureScript\", \"TypeScript\", \"WebAssembly\", \"NaN\", \"NaNs\", \"OAuth\", \"GraphQL\", \"OCaml\", \"OpenAL\", \"OpenDNS\", \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\", \"OpenTelemetry\", \"OpenType\", \"WebGL\", \"WebGL2\", \"WebGPU\", \"WebRTC\", \"WebSocket\", \"WebTransport\", \"WebP\", \"OpenExr\", \"YCbCr\", \"sRGB\", \"TensorFlow\", \"TrueType\", \"iOS\", \"macOS\", \"FreeBSD\", \"NetBSD\", \"OpenBSD\", \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\", \"MinGW\", \"CamelCase\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "doc_nested_refdefs",
    "rule_name": "doc_nested_refdefs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if a link reference definition appears at the start of a\nlist item or quote.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably intended as an intra-doc link. If it is really\nsupposed to be a reference definition, it can be written outside\nof the list item or quote.</p>\n<h3>Example</h3>\n<pre><code>//! - [link]: description\n</code></pre>\n<p>Use instead:</p>\n<pre><code>//! - [link][]: description (for intra-doc link)\n//!\n//! [link]: destination (for link reference definition)\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "double_comparisons",
    "rule_name": "double_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for double comparisons that could be simplified to a single expression.</p>\n<h3>Why is this bad?</h3>\n<p>Readability.</p>\n<h3>Example</h3>\n<pre><code>if x == y || x < y {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x <= y {}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "double_must_use",
    "rule_name": "double_must_use",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a <code>#[must_use]</code> attribute without\nfurther information on functions and methods that return a type already\nmarked as <code>#[must_use]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The attribute isn\u2019t needed. Not using the result\nwill already be reported. Alternatively, one can add some text to the\nattribute to improve the lint message.</p>\n<h3>Examples</h3>\n<pre><code>#[must_use]\nfn double_must_use() -> Result<(), ()> {\n    unimplemented!();\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "double_neg",
    "rule_name": "double_neg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects expressions of the form <code>--x</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It can mislead C/C++ programmers to think <code>x</code> was\ndecremented.</p>\n<h3>Example</h3>\n<pre><code>let mut x = 3;\n--x;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "double_parens",
    "rule_name": "double_parens",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary double parentheses.</p>\n<h3>Why is this bad?</h3>\n<p>This makes code harder to read and might indicate a\nmistake.</p>\n<h3>Example</h3>\n<pre><code>fn simple_double_parens() -> i32 {\n    ((0))\n}\n\nfoo((0));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn simple_no_parens() -> i32 {\n    0\n}\n\nfoo(0);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "drain_collect",
    "rule_name": "drain_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>.drain()</code> that clear the collection, immediately followed by a call to <code>.collect()</code>.</p>\n<blockquote>\n<p>\u201cCollection\u201d in this context refers to any type with a <code>drain</code> method:\n<code>Vec</code>, <code>VecDeque</code>, <code>BinaryHeap</code>, <code>HashSet</code>,<code>HashMap</code>, <code>String</code></p>\n</blockquote>\n<h3>Why is this bad?</h3>\n<p>Using <code>mem::take</code> is faster as it avoids the allocation.\nWhen using <code>mem::take</code>, the old collection is replaced with an empty one and ownership of\nthe old collection is returned.</p>\n<h3>Known issues</h3>\n<p><code>mem::take(&mut vec)</code> is almost equivalent to <code>vec.drain(..).collect()</code>, except that\nit also moves the <strong>capacity</strong>. The user might have explicitly written it this way\nto keep the capacity on the original <code>Vec</code>.</p>\n<h3>Example</h3>\n<pre><code>fn remove_all(v: &mut Vec<i32>) -> Vec<i32> {\n    v.drain(..).collect()\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::mem;\nfn remove_all(v: &mut Vec<i32>) -> Vec<i32> {\n    mem::take(v)\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "drop_non_drop",
    "rule_name": "drop_non_drop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>std::mem::drop</code> with a value that does not implement <code>Drop</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Calling <code>std::mem::drop</code> is no different than dropping such a type. A different value may\nhave been intended.</p>\n<h3>Example</h3>\n<pre><code>struct Foo;\nlet x = Foo;\nstd::mem::drop(x);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "duplicate_mod",
    "rule_name": "duplicate_mod",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for files that are included as modules multiple times.</p>\n<h3>Why is this bad?</h3>\n<p>Loading a file as a module more than once causes it to be compiled\nmultiple times, taking longer and putting duplicate content into the\nmodule tree.</p>\n<h3>Example</h3>\n<pre><code>// lib.rs\nmod a;\nmod b;\n</code></pre>\n<pre><code>// a.rs\n#[path = \"./b.rs\"]\nmod b;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// lib.rs\nmod a;\nmod b;\n</code></pre>\n<pre><code>// a.rs\nuse crate::b;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "duplicate_underscore_argument",
    "rule_name": "duplicate_underscore_argument",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for function arguments having the similar names\ndiffering by an underscore.</p>\n<h3>Why is this bad?</h3>\n<p>It affects code readability.</p>\n<h3>Example</h3>\n<pre><code>fn foo(a: i32, _a: i32) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn bar(a: i32, _b: i32) {}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "duplicated_attributes",
    "rule_name": "duplicated_attributes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for attributes that appear two or more times.</p>\n<h3>Why is this bad?</h3>\n<p>Repeating an attribute on the same item (or globally on the same crate)\nis unnecessary and doesn\u2019t have an effect.</p>\n<h3>Example</h3>\n<pre><code>#[allow(dead_code)]\n#[allow(dead_code)]\nfn foo() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[allow(dead_code)]\nfn foo() {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "duration_subsec",
    "rule_name": "duration_subsec",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calculation of subsecond microseconds or milliseconds\nfrom other <code>Duration</code> methods.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more concise to call <code>Duration::subsec_micros()</code> or\n<code>Duration::subsec_millis()</code> than to calculate them.</p>\n<h3>Example</h3>\n<pre><code>let micros = duration.subsec_nanos() / 1_000;\nlet millis = duration.subsec_nanos() / 1_000_000;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let micros = duration.subsec_micros();\nlet millis = duration.subsec_millis();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "eager_transmute",
    "rule_name": "eager_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for integer validity checks, followed by a transmute that is (incorrectly) evaluated\neagerly (e.g. using <code>bool::then_some</code>).</p>\n<h3>Why is this bad?</h3>\n<p>Eager evaluation means that the <code>transmute</code> call is executed regardless of whether the condition is true or false.\nThis can introduce unsoundness and other subtle bugs.</p>\n<h3>Example</h3>\n<p>Consider the following function which is meant to convert an unsigned integer to its enum equivalent via transmute.</p>\n<pre><code>#[repr(u8)]\nenum Opcode {\n    Add = 0,\n    Sub = 1,\n    Mul = 2,\n    Div = 3\n}\n\nfn int_to_opcode(op: u8) -> Option<Opcode> {\n    (op < 4).then_some(unsafe { std::mem::transmute(op) })\n}\n</code></pre>\n<p>This may appear fine at first given that it checks that the <code>u8</code> is within the validity range of the enum,\n<em>however</em> the transmute is evaluated eagerly, meaning that it executes even if <code>op >= 4</code>!</p>\n<p>This makes the function unsound, because it is possible for the caller to cause undefined behavior\n(creating an enum with an invalid bitpattern) entirely in safe code only by passing an incorrect value,\nwhich is normally only a bug that is possible in unsafe code.</p>\n<p>One possible way in which this can go wrong practically is that the compiler sees it as:</p>\n<pre><code>let temp: Foo = unsafe { std::mem::transmute(op) };\n(0 < 4).then_some(temp)\n</code></pre>\n<p>and optimizes away the <code>(0 < 4)</code> check based on the assumption that since a <code>Foo</code> was created from <code>op</code> with the validity range <code>0..3</code>,\nit is <strong>impossible</strong> for this condition to be false.</p>\n<p>In short, it is possible for this function to be optimized in a way that makes it <a>never return <code>None</code></a>,\neven if passed the value <code>4</code>.</p>\n<p>This can be avoided by instead using lazy evaluation. For the example above, this should be written:</p>\n<pre><code>fn int_to_opcode(op: u8) -> Option<Opcode> {\n    (op < 4).then(|| unsafe { std::mem::transmute(op) })\n             ^^^^ ^^ `bool::then` only executes the closure if the condition is true!\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "else_if_without_else",
    "rule_name": "else_if_without_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of if expressions with an <code>else if</code> branch,\nbut without a final <code>else</code> branch.</p>\n<h3>Why restrict this?</h3>\n<p>Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).</p>\n<h3>Example</h3>\n<pre><code>if x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n} else {\n    // We don't care about zero.\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "empty_docs",
    "rule_name": "empty_docs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects documentation that is empty.</p>\n<h3>Why is this bad?</h3>\n<p>Empty docs clutter code without adding value, reducing readability and maintainability.</p>\n<h3>Example</h3>\n<pre><code>///\nfn returns_true() -> bool {\n    true\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn returns_true() -> bool {\n    true\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "empty_drop",
    "rule_name": "empty_drop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty <code>Drop</code> implementations.</p>\n<h3>Why restrict this?</h3>\n<p>Empty <code>Drop</code> implementations have no effect when dropping an instance of the type. They are\nmost likely useless. However, an empty <code>Drop</code> implementation prevents a type from being\ndestructured, which might be the intention behind adding the implementation as a marker.</p>\n<h3>Example</h3>\n<pre><code>struct S;\n\nimpl Drop for S {\n    fn drop(&mut self) {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct S;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "empty_enum",
    "rule_name": "empty_enum",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>enum</code>s with no variants, which therefore are uninhabited types\n(cannot be instantiated).</p>\n<p>As of this writing, the <code>never_type</code> is still a nightly-only experimental API.\nTherefore, this lint is only triggered if <code>#![feature(never_type)]</code> is enabled.</p>\n<h3>Why is this bad?</h3>\n<ul>\n<li>\n<p>If you only want a type which can\u2019t be instantiated, you should use <a><code>!</code></a>\n(the primitive type \u201cnever\u201d), because <a><code>!</code></a> has more extensive compiler support\n(type inference, etc.) and implementations of common traits.</p>\n</li>\n<li>\n<p>If you need to introduce a distinct type, consider using a <a>newtype</a> <code>struct</code>\ncontaining <a><code>!</code></a> instead (<code>struct MyType(pub !)</code>), because it is more idiomatic\nto use a <code>struct</code> rather than an <code>enum</code> when an <code>enum</code> is unnecessary.</p>\n<p>If you do this, note that the <a>visibility</a> of the <a><code>!</code></a> field determines whether\nthe uninhabitedness is visible in documentation, and whether it can be pattern\nmatched to mark code unreachable. If the field is not visible, then the struct\nacts like any other struct with private fields.</p>\n</li>\n<li>\n<p>If the enum has no variants only because all variants happen to be\n<a>disabled by conditional compilation</a>, then it would be appropriate\nto allow the lint, with <code>#[allow(empty_enum)]</code>.</p>\n</li>\n</ul>\n<p>For further information, visit\n<a>the never type\u2019s documentation</a>.</p>\n<h3>Example</h3>\n<pre><code>enum CannotExist {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![feature(never_type)]\n\n/// Use the `!` type directly...\ntype CannotExist = !;\n\n/// ...or define a newtype which is distinct.\nstruct CannotExist2(pub !);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "empty_enum_variants_with_brackets",
    "rule_name": "empty_enum_variants_with_brackets",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds enum variants without fields that are declared with empty brackets.</p>\n<h3>Why restrict this?</h3>\n<p>Empty brackets after a enum variant declaration are redundant and can be omitted,\nand it may be desirable to do so consistently for style.</p>\n<p>However, removing the brackets also introduces a public constant named after the variant,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a <em>breaking</em> API change.</p>\n<h3>Example</h3>\n<pre><code>enum MyEnum {\n    HasData(u8),\n    HasNoData(),       // redundant parentheses\n    NoneHereEither {}, // redundant braces\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>enum MyEnum {\n    HasData(u8),\n    HasNoData,\n    NoneHereEither,\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "empty_line_after_doc_comments",
    "rule_name": "empty_line_after_doc_comments",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty lines after doc comments.</p>\n<h3>Why is this bad?</h3>\n<p>The doc comment may have meant to be an inner doc comment, regular\ncomment or applied to some old code that is now commented out. If it was\nintended to be a doc comment, then the empty line should be removed.</p>\n<h3>Example</h3>\n<pre><code>/// Some doc comment with a blank line after it.\n\nfn f() {}\n\n/// Docs for `old_code`\n// fn old_code() {}\n\nfn new_code() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>//! Convert it to an inner doc comment\n\n// Or a regular comment\n\n/// Or remove the empty line\nfn f() {}\n\n// /// Docs for `old_code`\n// fn old_code() {}\n\nfn new_code() {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "empty_line_after_outer_attr",
    "rule_name": "empty_line_after_outer_attr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty lines after outer attributes</p>\n<h3>Why is this bad?</h3>\n<p>The attribute may have meant to be an inner attribute (<code>#![attr]</code>). If\nit was meant to be an outer attribute (<code>#[attr]</code>) then the empty line\nshould be removed</p>\n<h3>Example</h3>\n<pre><code>#[allow(dead_code)]\n\nfn not_quite_good_code() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Good (as inner attribute)\n#![allow(dead_code)]\n\nfn this_is_fine() {}\n\n// or\n\n// Good (as outer attribute)\n#[allow(dead_code)]\nfn this_is_fine_too() {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "empty_loop",
    "rule_name": "empty_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty <code>loop</code> expressions.</p>\n<h3>Why is this bad?</h3>\n<p>These busy loops burn CPU cycles without doing\nanything. It is <em>almost always</em> a better idea to <code>panic!</code> than to have\na busy loop.</p>\n<p>If panicking isn\u2019t possible, think of the environment and either:</p>\n<ul>\n<li>block on something</li>\n<li>sleep the thread for some microseconds</li>\n<li>yield or pause the thread</li>\n</ul>\n<p>For <code>std</code> targets, this can be done with\n<a><code>std::thread::sleep</code></a>\nor <a><code>std::thread::yield_now</code></a>.</p>\n<p>For <code>no_std</code> targets, doing this is more complicated, especially because\n<code>#[panic_handler]</code>s can\u2019t panic. To stop/pause the thread, you will\nprobably need to invoke some target-specific intrinsic. Examples include:</p>\n<ul>\n<li><a><code>x86_64::instructions::hlt</code></a></li>\n<li><a><code>cortex_m::asm::wfi</code></a></li>\n</ul>\n<h3>Example</h3>\n<pre><code>loop {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "empty_structs_with_brackets",
    "rule_name": "empty_structs_with_brackets",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds structs without fields (a so-called \u201cempty struct\u201d) that are declared with brackets.</p>\n<h3>Why restrict this?</h3>\n<p>Empty brackets after a struct declaration can be omitted,\nand it may be desirable to do so consistently for style.</p>\n<p>However, removing the brackets also introduces a public constant named after the struct,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a <em>breaking</em> API change.</p>\n<h3>Example</h3>\n<pre><code>struct Cookie {}\nstruct Biscuit();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Cookie;\nstruct Biscuit;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "enum_clike_unportable_variant",
    "rule_name": "enum_clike_unportable_variant",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for C-like enumerations that are\n<code>repr(isize/usize)</code> and have values that don\u2019t fit into an <code>i32</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This will truncate the variant value on 32 bit\narchitectures, but works fine on 64 bit.</p>\n<h3>Example</h3>\n<pre><code>#[repr(usize)]\nenum NonPortable {\n    X = 0x1_0000_0000,\n    Y = 0,\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "enum_glob_use",
    "rule_name": "enum_glob_use",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>use Enum::*</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is usually better style to use the prefixed name of\nan enumeration variant, rather than importing variants.</p>\n<h3>Known problems</h3>\n<p>Old-style enumerations that prefix the variants are\nstill around.</p>\n<h3>Example</h3>\n<pre><code>use std::cmp::Ordering::*;\n\nfoo(Less);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::cmp::Ordering;\n\nfoo(Ordering::Less)\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "enum_variant_names",
    "rule_name": "enum_variant_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects enumeration variants that are prefixed or suffixed\nby the same characters.</p>\n<h3>Why is this bad?</h3>\n<p>Enumeration variant names should specify their variant,\nnot repeat the enumeration name.</p>\n<h3>Limitations</h3>\n<p>Characters with no casing will be considered when comparing prefixes/suffixes\nThis applies to numbers and non-ascii characters without casing\ne.g. <code>Foo1</code> and <code>Foo2</code> is considered to have different prefixes\n(the prefixes are <code>Foo1</code> and <code>Foo2</code> respectively), as also <code>Bar\u8783</code>, <code>Bar\u87f9</code></p>\n<h3>Example</h3>\n<pre><code>enum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n    BattenbergCake,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>enum Cake {\n    BlackForest,\n    Hummingbird,\n    Battenberg,\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>enum-variant-name-threshold</code>:  The minimum number of enum variants for the lints about variant names to trigger</p>\n<p>(default: <code>3</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "eq_op",
    "rule_name": "eq_op",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for equal operands to comparison, logical and\nbitwise, difference and division binary operators (<code>==</code>, <code>></code>, etc., <code>&&</code>,\n<code>||</code>, <code>&</code>, <code>|</code>, <code>^</code>, <code>-</code> and <code>/</code>).</p>\n<h3>Why is this bad?</h3>\n<p>This is usually just a typo or a copy and paste error.</p>\n<h3>Known problems</h3>\n<p>False negatives: We had some false positives regarding\ncalls (notably <a>racer</a> had one instance\nof <code>x.pop() && x.pop()</code>), so we removed matching any function or method\ncalls. We may introduce a list of known pure functions in the future.</p>\n<h3>Example</h3>\n<pre><code>if x + 1 == x + 1 {}\n\n// or\n\nassert_eq!(a, a);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "equatable_if_let",
    "rule_name": "equatable_if_let",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for pattern matchings that can be expressed using equality.</p>\n<h3>Why is this bad?</h3>\n<ul>\n<li>It reads better and has less cognitive load because equality won\u2019t cause binding.</li>\n<li>It is a <a>Yoda condition</a>. Yoda conditions are widely\ncriticized for increasing the cognitive load of reading the code.</li>\n<li>Equality is a simple bool expression and can be merged with <code>&&</code> and <code>||</code> and\nreuse if blocks</li>\n</ul>\n<h3>Example</h3>\n<pre><code>if let Some(2) = x {\n    do_thing();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x == Some(2) {\n    do_thing();\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "erasing_op",
    "rule_name": "erasing_op",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for erasing operations, e.g., <code>x * 0</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The whole expression can be replaced by zero.\nThis is most likely not the intended outcome and should probably be\ncorrected</p>\n<h3>Example</h3>\n<pre><code>let x = 1;\n0 / x;\n0 * x;\nx & 0;\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "err_expect",
    "rule_name": "err_expect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.err().expect()</code> calls on the <code>Result</code> type.</p>\n<h3>Why is this bad?</h3>\n<p><code>.expect_err()</code> can be called directly to avoid the extra type conversion from <code>err()</code>.</p>\n<h3>Example</h3>\n<pre><code>let x: Result<u32, &str> = Ok(10);\nx.err().expect(\"Testing err().expect()\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Result<u32, &str> = Ok(10);\nx.expect_err(\"Testing expect_err\");\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "error_impl_error",
    "rule_name": "error_impl_error",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for types named <code>Error</code> that implement <code>Error</code>.</p>\n<h3>Why restrict this?</h3>\n<p>It can become confusing when a codebase has 20 types all named <code>Error</code>, requiring either\naliasing them in the <code>use</code> statement or qualifying them like <code>my_module::Error</code>. This\nhinders comprehension, as it requires you to memorize every variation of importing <code>Error</code>\nused across a codebase.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Debug)]\npub enum Error { ... }\n\nimpl std::fmt::Display for Error { ... }\n\nimpl std::error::Error for Error { ... }\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "excessive_nesting",
    "rule_name": "excessive_nesting",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for blocks which are nested beyond a certain threshold.</p>\n<p>Note: Even though this lint is warn-by-default, it will only trigger if a maximum nesting level is defined in the clippy.toml file.</p>\n<h3>Why is this bad?</h3>\n<p>It can severely hinder readability.</p>\n<h3>Example</h3>\n<p>An example clippy.toml configuration:</p>\n<pre><code>excessive-nesting-threshold = 3\n</code></pre>\n<pre><code>// lib.rs\npub mod a {\n    pub struct X;\n    impl X {\n        pub fn run(&self) {\n            if true {\n                // etc...\n            }\n        }\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// a.rs\nfn private_run(x: &X) {\n    if true {\n        // etc...\n    }\n}\n\npub struct X;\nimpl X {\n    pub fn run(&self) {\n        private_run(self);\n    }\n}\n</code></pre>\n<pre><code>// lib.rs\npub mod a;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>excessive-nesting-threshold</code>:  The maximum amount of nesting a block can reside in</p>\n<p>(default: <code>0</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "excessive_precision",
    "rule_name": "excessive_precision",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for float literals with a precision greater\nthan that supported by the underlying type.</p>\n<h3>Why is this bad?</h3>\n<p>Rust will truncate the literal silently.</p>\n<h3>Example</h3>\n<pre><code>let v: f32 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let v: f64 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789_9\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "exhaustive_enums",
    "rule_name": "exhaustive_enums",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns on any exported <code>enum</code>s that are not tagged <code>#[non_exhaustive]</code></p>\n<h3>Why restrict this?</h3>\n<p>Making an <code>enum</code> exhaustive is a stability commitment: adding a variant is a breaking change.\nA project may wish to ensure that there are no exhaustive enums or that every exhaustive\n<code>enum</code> is explicitly <code>#[allow]</code>ed.</p>\n<h3>Example</h3>\n<pre><code>enum Foo {\n    Bar,\n    Baz\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[non_exhaustive]\nenum Foo {\n    Bar,\n    Baz\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "exhaustive_structs",
    "rule_name": "exhaustive_structs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns on any exported <code>struct</code>s that are not tagged <code>#[non_exhaustive]</code></p>\n<h3>Why restrict this?</h3>\n<p>Making a <code>struct</code> exhaustive is a stability commitment: adding a field is a breaking change.\nA project may wish to ensure that there are no exhaustive structs or that every exhaustive\n<code>struct</code> is explicitly <code>#[allow]</code>ed.</p>\n<h3>Example</h3>\n<pre><code>struct Foo {\n    bar: u8,\n    baz: String,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[non_exhaustive]\nstruct Foo {\n    bar: u8,\n    baz: String,\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "exit",
    "rule_name": "exit",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects calls to the <code>exit()</code> function which terminates the program.</p>\n<h3>Why restrict this?</h3>\n<p><code>exit()</code> immediately terminates the program with no information other than an exit code.\nThis provides no means to troubleshoot a problem, and may be an unexpected side effect.</p>\n<p>Codebases may use this lint to require that all exits are performed either by panicking\n(which produces a message, a code location, and optionally a backtrace)\nor by returning from <code>main()</code> (which is a single place to look).</p>\n<h3>Example</h3>\n<pre><code>std::process::exit(0)\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// To provide a stacktrace and additional information\npanic!(\"message\");\n\n// or a main method with a return\nfn main() -> Result<(), i32> {\n    Ok(())\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "expect_fun_call",
    "rule_name": "expect_fun_call",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>.expect(&format!(...))</code>, <code>.expect(foo(..))</code>,\netc., and suggests to use <code>unwrap_or_else</code> instead</p>\n<h3>Why is this bad?</h3>\n<p>The function will always be called.</p>\n<h3>Known problems</h3>\n<p>If the function has side-effects, not calling it will\nchange the semantics of the program, but you shouldn\u2019t rely on that anyway.</p>\n<h3>Example</h3>\n<pre><code>foo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n\n// or\n\nfoo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>foo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "expect_used",
    "rule_name": "expect_used",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.expect()</code> or <code>.expect_err()</code> calls on <code>Result</code>s and <code>.expect()</code> call on <code>Option</code>s.</p>\n<h3>Why restrict this?</h3>\n<p>Usually it is better to handle the <code>None</code> or <code>Err</code> case.\nStill, for a lot of quick-and-dirty code, <code>expect</code> is a good choice, which is why\nthis lint is <code>Allow</code> by default.</p>\n<p><code>result.expect()</code> will let the thread panic on <code>Err</code>\nvalues. Normally, you want to implement more sophisticated error handling,\nand propagate errors upwards with <code>?</code> operator.</p>\n<h3>Examples</h3>\n<pre><code>option.expect(\"one\");\nresult.expect(\"one\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>option?;\n\n// or\n\nresult?;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>option_expect_used</li>\n<li>result_expect_used</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-expect-in-tests</code>:  Whether <code>expect</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "expl_impl_clone_on_copy",
    "rule_name": "expl_impl_clone_on_copy",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for explicit <code>Clone</code> implementations for <code>Copy</code>\ntypes.</p>\n<h3>Why is this bad?</h3>\n<p>To avoid surprising behavior, these traits should\nagree and the behavior of <code>Copy</code> cannot be overridden. In almost all\nsituations a <code>Copy</code> type should have a <code>Clone</code> implementation that does\nnothing more than copy the object, which is what <code>#[derive(Copy, Clone)]</code>\ngets you.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Copy)]\nstruct Foo;\n\nimpl Clone for Foo {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "explicit_auto_deref",
    "rule_name": "explicit_auto_deref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for dereferencing expressions which would be covered by auto-deref.</p>\n<h3>Why is this bad?</h3>\n<p>This unnecessarily complicates the code.</p>\n<h3>Example</h3>\n<pre><code>let x = String::new();\nlet y: &str = &*x;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = String::new();\nlet y: &str = &x;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "explicit_counter_loop",
    "rule_name": "explicit_counter_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks <code>for</code> loops over slices with an explicit counter\nand suggests the use of <code>.enumerate()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>.enumerate()</code> makes the intent more clear,\ndeclutters the code and may be faster in some instances.</p>\n<h3>Example</h3>\n<pre><code>let mut i = 0;\nfor item in &v {\n    bar(i, *item);\n    i += 1;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for (i, item) in v.iter().enumerate() { bar(i, *item); }\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "explicit_deref_methods",
    "rule_name": "explicit_deref_methods",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for explicit <code>deref()</code> or <code>deref_mut()</code> method calls.</p>\n<h3>Why is this bad?</h3>\n<p>Dereferencing by <code>&*x</code> or <code>&mut *x</code> is clearer and more concise,\nwhen not part of a method chain.</p>\n<h3>Example</h3>\n<pre><code>use std::ops::Deref;\nlet a: &mut String = &mut String::from(\"foo\");\nlet b: &str = a.deref();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a: &mut String = &mut String::from(\"foo\");\nlet b = &*a;\n</code></pre>\n<p>This lint excludes all of:</p>\n<pre><code>let _ = d.unwrap().deref();\nlet _ = Foo::deref(&foo);\nlet _ = <Foo as Deref>::deref(&foo);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "explicit_into_iter_loop",
    "rule_name": "explicit_into_iter_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for loops on <code>y.into_iter()</code> where <code>y</code> will do, and\nsuggests the latter.</p>\n<h3>Why is this bad?</h3>\n<p>Readability.</p>\n<h3>Example</h3>\n<pre><code>// with `y` a `Vec` or slice:\nfor x in y.into_iter() {\n    // ..\n}\n</code></pre>\n<p>can be rewritten to</p>\n<pre><code>for x in y {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "explicit_iter_loop",
    "rule_name": "explicit_iter_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for loops on <code>x.iter()</code> where <code>&x</code> will do, and\nsuggests the latter.</p>\n<h3>Why is this bad?</h3>\n<p>Readability.</p>\n<h3>Known problems</h3>\n<p>False negatives. We currently only warn on some known\ntypes.</p>\n<h3>Example</h3>\n<pre><code>// with `y` a `Vec` or slice:\nfor x in y.iter() {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for x in &y {\n    // ..\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li><code>enforce-iter-loop-reborrow</code>:  Whether to recommend using implicit into iter for reborrowed values.</li>\n</ul>\n<h4>Example</h4>\n<pre><code>let mut vec = vec![1, 2, 3];\nlet rmvec = &mut vec;\nfor _ in rmvec.iter() {}\nfor _ in rmvec.iter_mut() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut vec = vec![1, 2, 3];\nlet rmvec = &mut vec;\nfor _ in &*rmvec {}\nfor _ in &mut *rmvec {}\n</code></pre>\n<p>(default: <code>false</code>)</p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "explicit_write",
    "rule_name": "explicit_write",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>write!()</code> / <code>writeln()!</code> which can be\nreplaced with <code>(e)print!()</code> / <code>(e)println!()</code></p>\n<h3>Why is this bad?</h3>\n<p>Using <code>(e)println!</code> is clearer and more concise</p>\n<h3>Example</h3>\n<pre><code>writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\nwriteln!(&mut std::io::stdout(), \"foo: {:?}\", bar).unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>eprintln!(\"foo: {:?}\", bar);\nprintln!(\"foo: {:?}\", bar);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "extend_from_slice",
    "rule_name": "extend_from_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>Vec::extend_from_slice</code> is no longer faster than <code>Vec::extend</code> due to specialization.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "extend_with_drain",
    "rule_name": "extend_with_drain",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for occurrences where one vector gets extended instead of append</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>append</code> instead of <code>extend</code> is more concise and faster</p>\n<h3>Example</h3>\n<pre><code>let mut a = vec![1, 2, 3];\nlet mut b = vec![4, 5, 6];\n\na.extend(b.drain(..));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut a = vec![1, 2, 3];\nlet mut b = vec![4, 5, 6];\n\na.append(&mut b);\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "extra_unused_lifetimes",
    "rule_name": "extra_unused_lifetimes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for lifetimes in generics that are never used\nanywhere else.</p>\n<h3>Why is this bad?</h3>\n<p>The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.</p>\n<h3>Example</h3>\n<pre><code>// unnecessary lifetimes\nfn unused_lifetime<'a>(x: u8) {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn no_lifetime(x: u8) {\n    // ...\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "extra_unused_type_parameters",
    "rule_name": "extra_unused_type_parameters",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for type parameters in generics that are never used anywhere else.</p>\n<h3>Why is this bad?</h3>\n<p>Functions cannot infer the value of unused type parameters; therefore, calling them\nrequires using a turbofish, which serves no purpose but to satisfy the compiler.</p>\n<h3>Example</h3>\n<pre><code>fn unused_ty<T>(x: u8) {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn no_unused_ty(x: u8) {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "fallible_impl_from",
    "rule_name": "fallible_impl_from",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for impls of <code>From<..></code> that contain <code>panic!()</code> or <code>unwrap()</code></p>\n<h3>Why is this bad?</h3>\n<p><code>TryFrom</code> should be used if there\u2019s a possibility of failure.</p>\n<h3>Example</h3>\n<pre><code>struct Foo(i32);\n\nimpl From<String> for Foo {\n    fn from(s: String) -> Self {\n        Foo(s.parse().unwrap())\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Foo(i32);\n\nimpl TryFrom<String> for Foo {\n    type Error = ();\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        if let Ok(parsed) = s.parse() {\n            Ok(Foo(parsed))\n        } else {\n            Err(())\n        }\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "field_reassign_with_default",
    "rule_name": "field_reassign_with_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for immediate reassignment of fields initialized\nwith Default::default().</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more idiomatic to use the <a>functional update syntax</a>.</p>\n<h3>Known problems</h3>\n<p>Assignments to patterns that are of tuple type are not linted.</p>\n<h3>Example</h3>\n<pre><code>let mut a: A = Default::default();\na.i = 42;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = A {\n    i: 42,\n    .. Default::default()\n};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "field_scoped_visibility_modifiers",
    "rule_name": "field_scoped_visibility_modifiers",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of scoped visibility modifiers, like <code>pub(crate)</code>, on fields. These\nmake a field visible within a scope between public and private.</p>\n<h3>Why restrict this?</h3>\n<p>Scoped visibility modifiers cause a field to be accessible within some scope between\npublic and private, potentially within an entire crate. This allows for fields to be\nnon-private while upholding internal invariants, but can be a code smell. Scoped visibility\nrequires checking a greater area, potentially an entire crate, to verify that an invariant\nis upheld, and global analysis requires a lot of effort.</p>\n<h3>Example</h3>\n<pre><code>pub mod public_module {\n    struct MyStruct {\n        pub(crate) first_field: bool,\n        pub(super) second_field: bool\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub mod public_module {\n    struct MyStruct {\n        first_field: bool,\n        second_field: bool\n    }\n    impl MyStruct {\n        pub(crate) fn get_first_field(&self) -> bool {\n            self.first_field\n        }\n        pub(super) fn get_second_field(&self) -> bool {\n            self.second_field\n        }\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "filetype_is_file",
    "rule_name": "filetype_is_file",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>FileType::is_file()</code>.</p>\n<h3>Why restrict this?</h3>\n<p>When people testing a file type with <code>FileType::is_file</code>\nthey are testing whether a path is something they can get bytes from. But\n<code>is_file</code> doesn\u2019t cover special file types in unix-like systems, and doesn\u2019t cover\nsymlink in windows. Using <code>!FileType::is_dir()</code> is a better way to that intention.</p>\n<h3>Example</h3>\n<pre><code>let metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif filetype.is_file() {\n    // read file\n}\n</code></pre>\n<p>should be written as:</p>\n<pre><code>let metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif !filetype.is_dir() {\n    // read file\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "filter_map_bool_then",
    "rule_name": "filter_map_bool_then",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>bool::then</code> in <code>Iterator::filter_map</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This can be written with <code>filter</code> then <code>map</code> instead, which would reduce nesting and\nseparates the filtering from the transformation phase. This comes with no cost to\nperformance and is just cleaner.</p>\n<h3>Limitations</h3>\n<p>Does not lint <code>bool::then_some</code>, as it eagerly evaluates its arguments rather than lazily.\nThis can create differing behavior, so better safe than sorry.</p>\n<h3>Example</h3>\n<pre><code>_ = v.into_iter().filter_map(|i| (i % 2 == 0).then(|| really_expensive_fn(i)));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>_ = v.into_iter().filter(|i| i % 2 == 0).map(|i| really_expensive_fn(i));\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "filter_map_identity",
    "rule_name": "filter_map_identity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>filter_map(|x| x)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely by using <code>flatten</code>.</p>\n<h3>Example</h3>\n<pre><code>iter.filter_map(|x| x);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>iter.flatten();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "filter_map_next",
    "rule_name": "filter_map_next",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.filter_map(_).next()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.find_map(_)</code>.</p>\n<h3>Example</h3>\n<pre><code> (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n</code></pre>\n<p>Can be written as</p>\n<pre><code> (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "filter_next",
    "rule_name": "filter_next",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.filter(_).next()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.find(_)</code>.</p>\n<h3>Example</h3>\n<pre><code>vec.iter().filter(|x| **x == 0).next();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.iter().find(|x| **x == 0);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "flat_map_identity",
    "rule_name": "flat_map_identity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>flat_map(|x| x)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely by using <code>flatten</code>.</p>\n<h3>Example</h3>\n<pre><code>iter.flat_map(|x| x);\n</code></pre>\n<p>Can be written as</p>\n<pre><code>iter.flatten();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "flat_map_option",
    "rule_name": "flat_map_option",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Iterator::flat_map()</code> where <code>filter_map()</code> could be\nused instead.</p>\n<h3>Why is this bad?</h3>\n<p><code>filter_map()</code> is known to always produce 0 or 1 output items per input item,\nrather than however many the inner iterator type produces.\nTherefore, it maintains the upper bound in <code>Iterator::size_hint()</code>,\nand communicates to the reader that the input items are not being expanded into\nmultiple output items without their having to notice that the mapping function\nreturns an <code>Option</code>.</p>\n<h3>Example</h3>\n<pre><code>let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "float_arithmetic",
    "rule_name": "float_arithmetic",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for float arithmetic.</p>\n<h3>Why restrict this?</h3>\n<p>For some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers.</p>\n<h3>Example</h3>\n<pre><code>a + 1.0;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "float_cmp",
    "rule_name": "float_cmp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for (in-)equality comparisons on floating-point\nvalues (apart from zero), except in functions called <code>*eq*</code> (which probably\nimplement equality for a type involving floats).</p>\n<h3>Why is this bad?</h3>\n<p>Floating point calculations are usually imprecise, so asking if two values are <em>exactly</em>\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values.</p>\n<h3>Example</h3>\n<pre><code>let a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nlet y = 1000.3; // Expected value.\n\n// Actual value: 1000.3000000000001\nprintln!(\"{x}\");\n\nlet are_equal = x == y;\nprintln!(\"{are_equal}\"); // false\n</code></pre>\n<p>The correct way to compare floating point numbers is to define an allowed error margin. This\nmay be challenging if there is no \u201cnatural\u201d error margin to permit. Broadly speaking, there\nare two cases:</p>\n<ol>\n<li>If your values are in a known range and you can define a threshold for \u201cclose enough to\nbe equal\u201d, it may be appropriate to define an absolute error margin. For example, if your\ndata is \u201clength of vehicle in centimeters\u201d, you may consider 0.1 cm to be \u201cclose enough\u201d.</li>\n<li>If your code is more general and you do not know the range of values, you should use a\nrelative error margin, accepting e.g. 0.1% of error regardless of specific values.</li>\n</ol>\n<p>For the scenario where you can define a meaningful absolute error margin, consider using:</p>\n<pre><code>let a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nlet y = 1000.3; // Expected value.\n\nconst ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;\nlet within_tolerance = (x - y).abs() < ALLOWED_ERROR_VEHICLE_LENGTH_CM;\nprintln!(\"{within_tolerance}\"); // true\n</code></pre>\n<p>NB! Do not use <code>f64::EPSILON</code> - while the error margin is often called \u201cepsilon\u201d, this is\na different use of the term that is not suitable for floating point equality comparison.\nIndeed, for the example above using <code>f64::EPSILON</code> as the allowed error would return <code>false</code>.</p>\n<p>For the scenario where no meaningful absolute error can be defined, refer to\n<a>the floating point guide</a>\nfor a reference implementation of relative error based comparison of floating point values.\n<code>MIN_NORMAL</code> in the reference implementation is equivalent to <code>MIN_POSITIVE</code> in Rust.</p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "float_cmp_const",
    "rule_name": "float_cmp_const",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for (in-)equality comparisons on constant floating-point\nvalues (apart from zero), except in functions called <code>*eq*</code> (which probably\nimplement equality for a type involving floats).</p>\n<h3>Why restrict this?</h3>\n<p>Floating point calculations are usually imprecise, so asking if two values are <em>exactly</em>\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values.</p>\n<h3>Example</h3>\n<pre><code>let a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nconst Y: f64 = 1000.3; // Expected value.\n\n// Actual value: 1000.3000000000001\nprintln!(\"{x}\");\n\nlet are_equal = x == Y;\nprintln!(\"{are_equal}\"); // false\n</code></pre>\n<p>The correct way to compare floating point numbers is to define an allowed error margin. This\nmay be challenging if there is no \u201cnatural\u201d error margin to permit. Broadly speaking, there\nare two cases:</p>\n<ol>\n<li>If your values are in a known range and you can define a threshold for \u201cclose enough to\nbe equal\u201d, it may be appropriate to define an absolute error margin. For example, if your\ndata is \u201clength of vehicle in centimeters\u201d, you may consider 0.1 cm to be \u201cclose enough\u201d.</li>\n<li>If your code is more general and you do not know the range of values, you should use a\nrelative error margin, accepting e.g. 0.1% of error regardless of specific values.</li>\n</ol>\n<p>For the scenario where you can define a meaningful absolute error margin, consider using:</p>\n<pre><code>let a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nconst Y: f64 = 1000.3; // Expected value.\n\nconst ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;\nlet within_tolerance = (x - Y).abs() < ALLOWED_ERROR_VEHICLE_LENGTH_CM;\nprintln!(\"{within_tolerance}\"); // true\n</code></pre>\n<p>NB! Do not use <code>f64::EPSILON</code> - while the error margin is often called \u201cepsilon\u201d, this is\na different use of the term that is not suitable for floating point equality comparison.\nIndeed, for the example above using <code>f64::EPSILON</code> as the allowed error would return <code>false</code>.</p>\n<p>For the scenario where no meaningful absolute error can be defined, refer to\n<a>the floating point guide</a>\nfor a reference implementation of relative error based comparison of floating point values.\n<code>MIN_NORMAL</code> in the reference implementation is equivalent to <code>MIN_POSITIVE</code> in Rust.</p>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "float_equality_without_abs",
    "rule_name": "float_equality_without_abs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for statements of the form <code>(a - b) < f32::EPSILON</code> or\n<code>(a - b) < f64::EPSILON</code>. Notes the missing <code>.abs()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The code without <code>.abs()</code> is more likely to have a bug.</p>\n<h3>Known problems</h3>\n<p>If the user can ensure that b is larger than a, the <code>.abs()</code> is\ntechnically unnecessary. However, it will make the code more robust and doesn\u2019t have any\nlarge performance implications. If the abs call was deliberately left out for performance\nreasons, it is probably better to state this explicitly in the code, which then can be done\nwith an allow.</p>\n<h3>Example</h3>\n<pre><code>pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n    (a - b) < f32::EPSILON\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n    (a - b).abs() < f32::EPSILON\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "fn_params_excessive_bools",
    "rule_name": "fn_params_excessive_bools",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for excessive use of\nbools in function definitions.</p>\n<h3>Why is this bad?</h3>\n<p>Calls to such functions\nare confusing and error prone, because it\u2019s\nhard to remember argument order and you have\nno type system support to back you up. Using\ntwo-variant enums instead of bools often makes\nAPI easier to use.</p>\n<h3>Example</h3>\n<pre><code>fn f(is_round: bool, is_hot: bool) { ... }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>enum Shape {\n    Round,\n    Spiky,\n}\n\nenum Temperature {\n    Hot,\n    IceCold,\n}\n\nfn f(shape: Shape, temperature: Temperature) { ... }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>max-fn-params-bools</code>:  The maximum number of bool parameters a function can have</p>\n<p>(default: <code>3</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "fn_to_numeric_cast",
    "rule_name": "fn_to_numeric_cast",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts of function pointers to something other than <code>usize</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Casting a function pointer to anything other than <code>usize</code>/<code>isize</code> is\nnot portable across architectures. If the target type is too small the\naddress would be truncated, and target types larger than <code>usize</code> are\nunnecessary.</p>\n<p>Casting to <code>isize</code> also doesn\u2019t make sense, since addresses are never\nsigned.</p>\n<h3>Example</h3>\n<pre><code>fn fun() -> i32 { 1 }\nlet _ = fun as i64;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = fun as usize;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "fn_to_numeric_cast_any",
    "rule_name": "fn_to_numeric_cast_any",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts of a function pointer to any integer type.</p>\n<h3>Why restrict this?</h3>\n<p>Casting a function pointer to an integer can have surprising results and can occur\naccidentally if parentheses are omitted from a function call. If you aren\u2019t doing anything\nlow-level with function pointers then you can opt out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code.</p>\n<h3>Example</h3>\n<pre><code>// fn1 is cast as `usize`\nfn fn1() -> u16 {\n    1\n};\nlet _ = fn1 as usize;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// maybe you intended to call the function?\nfn fn2() -> u16 {\n    1\n};\nlet _ = fn2() as usize;\n\n// or\n\n// maybe you intended to cast it to a function type?\nfn fn3() -> u16 {\n    1\n}\nlet _ = fn3 as fn() -> u16;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "fn_to_numeric_cast_with_truncation",
    "rule_name": "fn_to_numeric_cast_with_truncation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts of a function pointer to a numeric type not wide enough to\nstore an address.</p>\n<h3>Why is this bad?</h3>\n<p>Such a cast discards some bits of the function\u2019s address. If this is intended, it would be more\nclearly expressed by casting to <code>usize</code> first, then casting the <code>usize</code> to the intended type (with\na comment) to perform the truncation.</p>\n<h3>Example</h3>\n<pre><code>fn fn1() -> i16 {\n    1\n};\nlet _ = fn1 as i32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Cast to usize first, then comment with the reason for the truncation\nfn fn1() -> i16 {\n    1\n};\nlet fn_ptr = fn1 as usize;\nlet fn_ptr_truncated = fn_ptr as i32;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "for_kv_map",
    "rule_name": "for_kv_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iterating a map (<code>HashMap</code> or <code>BTreeMap</code>) and\nignoring either the keys or values.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. There are <code>keys</code> and <code>values</code> methods that\ncan be used to express that don\u2019t need the values or keys.</p>\n<h3>Example</h3>\n<pre><code>for (k, _) in &map {\n    ..\n}\n</code></pre>\n<p>could be replaced by</p>\n<pre><code>for k in map.keys() {\n    ..\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "forget_non_drop",
    "rule_name": "forget_non_drop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>std::mem::forget</code> with a value that does not implement <code>Drop</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Calling <code>std::mem::forget</code> is no different than dropping such a type. A different value may\nhave been intended.</p>\n<h3>Example</h3>\n<pre><code>struct Foo;\nlet x = Foo;\nstd::mem::forget(x);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "format_collect",
    "rule_name": "format_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.map(|_| format!(..)).collect::<String>()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This allocates a new string for every element in the iterator.\nThis can be done more efficiently by creating the <code>String</code> once and appending to it in <code>Iterator::fold</code>,\nusing either the <code>write!</code> macro which supports exactly the same syntax as the <code>format!</code> macro,\nor concatenating with <code>+</code> in case the iterator yields <code>&str</code>/<code>String</code>.</p>\n<p>Note also that <code>write!</code>-ing into a <code>String</code> can never fail, despite the return type of <code>write!</code> being <code>std::fmt::Result</code>,\nso it can be safely ignored or unwrapped.</p>\n<h3>Example</h3>\n<pre><code>fn hex_encode(bytes: &[u8]) -> String {\n    bytes.iter().map(|b| format!(\"{b:02X}\")).collect()\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt::Write;\nfn hex_encode(bytes: &[u8]) -> String {\n    bytes.iter().fold(String::new(), |mut output, b| {\n        let _ = write!(output, \"{b:02X}\");\n        output\n    })\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "format_in_format_args",
    "rule_name": "format_in_format_args",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects <code>format!</code> within the arguments of another macro that does\nformatting such as <code>format!</code> itself, <code>write!</code> or <code>println!</code>. Suggests\ninlining the <code>format!</code> call.</p>\n<h3>Why is this bad?</h3>\n<p>The recommended code is both shorter and avoids a temporary allocation.</p>\n<h3>Example</h3>\n<pre><code>println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!(\"error: something failed at {}\", Location::caller());\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "format_push_string",
    "rule_name": "format_push_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects cases where the result of a <code>format!</code> call is\nappended to an existing <code>String</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Introduces an extra, avoidable heap allocation.</p>\n<h3>Known problems</h3>\n<p><code>format!</code> returns a <code>String</code> but <code>write!</code> returns a <code>Result</code>.\nThus you are forced to ignore the <code>Err</code> variant to achieve the same API.</p>\n<p>While using <code>write!</code> in the suggested way should never fail, this isn\u2019t necessarily clear to the programmer.</p>\n<h3>Example</h3>\n<pre><code>let mut s = String::new();\ns += &format!(\"0x{:X}\", 1024);\ns.push_str(&format!(\"0x{:X}\", 1024));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt::Write as _; // import without risk of name clashing\n\nlet mut s = String::new();\nlet _ = write!(s, \"0x{:X}\", 1024);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "four_forward_slashes",
    "rule_name": "four_forward_slashes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for outer doc comments written with 4 forward slashes (<code>////</code>).</p>\n<h3>Why is this bad?</h3>\n<p>This is (probably) a typo, and results in it not being a doc comment; just a regular\ncomment.</p>\n<h3>Example</h3>\n<pre><code>//// My amazing data structure\npub struct Foo {\n    // ...\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>/// My amazing data structure\npub struct Foo {\n    // ...\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "from_iter_instead_of_collect",
    "rule_name": "from_iter_instead_of_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>from_iter()</code> function calls on types that implement the <code>FromIterator</code>\ntrait.</p>\n<h3>Why is this bad?</h3>\n<p>If it\u2019s needed to create a collection from the contents of an iterator, the <code>Iterator::collect(_)</code>\nmethod is preferred. However, when it\u2019s needed to specify the container type,\n<code>Vec::from_iter(_)</code> can be more readable than using a turbofish (e.g. <code>_.collect::<Vec<_>>()</code>). See\n<a>FromIterator documentation</a></p>\n<h3>Example</h3>\n<pre><code>let five_fives = std::iter::repeat(5).take(5);\n\nlet v = Vec::from_iter(five_fives);\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let five_fives = std::iter::repeat(5).take(5);\n\nlet v: Vec<i32> = five_fives.collect();\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n</code></pre>\n<p>but prefer to use</p>\n<pre><code>let numbers: Vec<i32> = FromIterator::from_iter(1..=5);\n</code></pre>\n<p>instead of</p>\n<pre><code>let numbers = (1..=5).collect::<Vec<_>>();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "from_over_into",
    "rule_name": "from_over_into",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Searches for implementations of the <code>Into<..></code> trait and suggests to implement <code>From<..></code> instead.</p>\n<h3>Why is this bad?</h3>\n<p>According the std docs implementing <code>From<..></code> is preferred since it gives you <code>Into<..></code> for free where the reverse isn\u2019t true.</p>\n<h3>Example</h3>\n<pre><code>struct StringWrapper(String);\n\nimpl Into<StringWrapper> for String {\n    fn into(self) -> StringWrapper {\n        StringWrapper(self)\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct StringWrapper(String);\n\nimpl From<String> for StringWrapper {\n    fn from(s: String) -> StringWrapper {\n        StringWrapper(s)\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "from_raw_with_void_ptr",
    "rule_name": "from_raw_with_void_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if we\u2019re passing a <code>c_void</code> raw pointer to <code>{Box,Rc,Arc,Weak}::from_raw(_)</code></p>\n<h3>Why is this bad?</h3>\n<p>When dealing with <code>c_void</code> raw pointers in FFI, it is easy to run into the pitfall of calling <code>from_raw</code> with the <code>c_void</code> pointer.\nThe type signature of <code>Box::from_raw</code> is <code>fn from_raw(raw: *mut T) -> Box<T></code>, so if you pass a <code>*mut c_void</code> you will get a <code>Box<c_void></code> (and similarly for <code>Rc</code>, <code>Arc</code> and <code>Weak</code>).\nFor this to be safe, <code>c_void</code> would need to have the same memory layout as the original type, which is often not the case.</p>\n<h3>Example</h3>\n<pre><code>let ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;\nlet _ = unsafe { Box::from_raw(ptr) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = unsafe { Box::from_raw(ptr as *mut usize) };\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "from_str_radix_10",
    "rule_name": "from_str_radix_10",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for function invocations of the form <code>primitive::from_str_radix(s, 10)</code></p>\n<h3>Why is this bad?</h3>\n<p>This specific common use case can be rewritten as <code>s.parse::<primitive>()</code>\n(and in most cases, the turbofish can be removed), which reduces code length\nand complexity.</p>\n<h3>Known problems</h3>\n<p>This lint may suggest using <code>(&<expression>).parse()</code> instead of <code><expression>.parse()</code>\ndirectly in some cases, which is correct but adds unnecessary complexity to the code.</p>\n<h3>Example</h3>\n<pre><code>let input: &str = get_input();\nlet num = u16::from_str_radix(input, 10)?;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let input: &str = get_input();\nlet num: u16 = input.parse()?;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "future_not_send",
    "rule_name": "future_not_send",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint requires Future implementations returned from\nfunctions and methods to implement the <code>Send</code> marker trait,\nignoring type parameters.</p>\n<p>If a function is generic and its Future conditionally implements <code>Send</code>\nbased on a generic parameter then it is considered <code>Send</code> and no warning is emitted.</p>\n<p>This can be used by library authors (public and internal) to ensure\ntheir functions are compatible with both multi-threaded runtimes that require <code>Send</code> futures,\nas well as single-threaded runtimes where callers may choose <code>!Send</code> types\nfor generic parameters.</p>\n<h3>Why is this bad?</h3>\n<p>A Future implementation captures some state that it\nneeds to eventually produce its final value. When targeting a multithreaded\nexecutor (which is the norm on non-embedded devices) this means that this\nstate may need to be transported to other threads, in other words the\nwhole Future needs to implement the <code>Send</code> marker trait. If it does not,\nthen the resulting Future cannot be submitted to a thread pool in the\nend user\u2019s code.</p>\n<p>Especially for generic functions it can be confusing to leave the\ndiscovery of this problem to the end user: the reported error location\nwill be far from its cause and can in many cases not even be fixed without\nmodifying the library where the offending Future implementation is\nproduced.</p>\n<h3>Example</h3>\n<pre><code>async fn not_send(bytes: std::rc::Rc<[u8]>) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "get_first",
    "rule_name": "get_first",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>x.get(0)</code> instead of\n<code>x.first()</code> or <code>x.front()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>x.first()</code> for <code>Vec</code>s and slices or <code>x.front()</code>\nfor <code>VecDeque</code>s is easier to read and has the same result.</p>\n<h3>Example</h3>\n<pre><code>let x = vec![2, 3, 5];\nlet first_element = x.get(0);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = vec![2, 3, 5];\nlet first_element = x.first();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "get_last_with_len",
    "rule_name": "get_last_with_len",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>x.get(x.len() - 1)</code> instead of\n<code>x.last()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>x.last()</code> is easier to read and has the same\nresult.</p>\n<p>Note that using <code>x[x.len() - 1]</code> is semantically different from\n<code>x.last()</code>.  Indexing into the array will panic on out-of-bounds\naccesses, while <code>x.get()</code> and <code>x.last()</code> will return <code>None</code>.</p>\n<p>There is another lint (get_unwrap) that covers the case of using\n<code>x.get(index).unwrap()</code> instead of <code>x[index]</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = vec![2, 3, 5];\nlet last_element = x.get(x.len() - 1);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = vec![2, 3, 5];\nlet last_element = x.last();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "get_unwrap",
    "rule_name": "get_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.get().unwrap()</code> (or\n<code>.get_mut().unwrap</code>) on a standard library type which implements <code>Index</code></p>\n<h3>Why restrict this?</h3>\n<p>Using the Index trait (<code>[]</code>) is more clear and more\nconcise.</p>\n<h3>Known problems</h3>\n<p>Not a replacement for error handling: Using either\n<code>.unwrap()</code> or the Index trait (<code>[]</code>) carries the risk of causing a <code>panic</code>\nif the value being accessed is <code>None</code>. If the use of <code>.get().unwrap()</code> is a\ntemporary placeholder for dealing with the <code>Option</code> type, then this does\nnot mitigate the need for error handling. If there is a chance that <code>.get()</code>\nwill be <code>None</code> in your program, then it is advisable that the <code>None</code> case\nis handled in a future refactor instead of using <code>.unwrap()</code> or the Index\ntrait.</p>\n<h3>Example</h3>\n<pre><code>let mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec.get(3).unwrap();\n*some_vec.get_mut(0).unwrap() = 1;\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec[3];\nsome_vec[0] = 1;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "host_endian_bytes",
    "rule_name": "host_endian_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of the <code>to_ne_bytes</code> method and/or the function <code>from_ne_bytes</code>.</p>\n<h3>Why restrict this?</h3>\n<p>To ensure use of explicitly chosen endianness rather than the target\u2019s endianness,\nsuch as when implementing network protocols or file formats rather than FFI.</p>\n<h3>Example</h3>\n<pre><code>let _x = 2i32.to_ne_bytes();\nlet _y = 2i64.to_ne_bytes();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "identity_op",
    "rule_name": "identity_op",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for identity operations, e.g., <code>x + 0</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This code can be removed without changing the\nmeaning. So it just obscures what\u2019s going on. Delete it mercilessly.</p>\n<h3>Example</h3>\n<pre><code>x / 1 + 0 * 1 - 0 | 0;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "if_let_mutex",
    "rule_name": "if_let_mutex",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Mutex::lock</code> calls in <code>if let</code> expression\nwith lock calls in any of the else blocks.</p>\n<h3>Disabled starting in Edition 2024</h3>\n<p>This lint is effectively disabled starting in\nEdition 2024 as <code>if let ... else</code> scoping was reworked\nsuch that this is no longer an issue. See\n<a>Proposal: stabilize if_let_rescope for Edition 2024</a></p>\n<h3>Why is this bad?</h3>\n<p>The Mutex lock remains held for the whole\n<code>if let ... else</code> block and deadlocks.</p>\n<h3>Example</h3>\n<pre><code>if let Ok(thing) = mutex.lock() {\n    do_thing();\n} else {\n    mutex.lock();\n}\n</code></pre>\n<p>Should be written</p>\n<pre><code>let locked = mutex.lock();\nif let Ok(thing) = locked {\n    do_thing(thing);\n} else {\n    use_locked(locked);\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "if_not_else",
    "rule_name": "if_not_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>!</code> or <code>!=</code> in an if condition with an\nelse branch.</p>\n<h3>Why is this bad?</h3>\n<p>Negations reduce the readability of statements.</p>\n<h3>Example</h3>\n<pre><code>if !v.is_empty() {\n    a()\n} else {\n    b()\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>if v.is_empty() {\n    b()\n} else {\n    a()\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "if_same_then_else",
    "rule_name": "if_same_then_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>if/else</code> with the same body as the <em>then</em> part\nand the <em>else</em> part.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a copy & paste error.</p>\n<h3>Example</h3>\n<pre><code>let foo = if \u2026 {\n    42\n} else {\n    42\n};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "if_then_some_else_none",
    "rule_name": "if_then_some_else_none",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for if-else that could be written using either <code>bool::then</code> or <code>bool::then_some</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Looks a little redundant. Using <code>bool::then</code> is more concise and incurs no loss of clarity.\nFor simple calculations and known values, use <code>bool::then_some</code>, which is eagerly evaluated\nin comparison to <code>bool::then</code>.</p>\n<h3>Example</h3>\n<pre><code>let a = if v.is_empty() {\n    println!(\"true!\");\n    Some(42)\n} else {\n    None\n};\n</code></pre>\n<p>Could be written:</p>\n<pre><code>let a = v.is_empty().then(|| {\n    println!(\"true!\");\n    42\n});\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "ifs_same_cond",
    "rule_name": "ifs_same_cond",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for consecutive <code>if</code>s with the same condition.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a copy & paste error.</p>\n<h3>Example</h3>\n<pre><code>if a == b {\n    \u2026\n} else if a == b {\n    \u2026\n}\n</code></pre>\n<p>Note that this lint ignores all conditions with a function call as it could\nhave side effects:</p>\n<pre><code>if foo() {\n    \u2026\n} else if foo() { // not linted\n    \u2026\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>\n<p>(default: <code>[\"bytes::Bytes\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "ignored_unit_patterns",
    "rule_name": "ignored_unit_patterns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_</code> in patterns of type <code>()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Matching with <code>()</code> explicitly instead of <code>_</code> outlines\nthe fact that the pattern contains no data. Also it\nwould detect a type change that <code>_</code> would ignore.</p>\n<h3>Example</h3>\n<pre><code>match std::fs::create_dir(\"tmp-work-dir\") {\n   Ok(_) => println!(\"Working directory created\"),\n   Err(s) => eprintln!(\"Could not create directory: {s}\"),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match std::fs::create_dir(\"tmp-work-dir\") {\n   Ok(()) => println!(\"Working directory created\"),\n   Err(s) => eprintln!(\"Could not create directory: {s}\"),\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "impl_hash_borrow_with_str_and_bytes",
    "rule_name": "impl_hash_borrow_with_str_and_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint is concerned with the semantics of <code>Borrow</code> and <code>Hash</code> for a\ntype that implements all three of <code>Hash</code>, <code>Borrow<str></code> and <code>Borrow<[u8]></code>\nas it is impossible to satisfy the semantics of Borrow and <code>Hash</code> for\nboth <code>Borrow<str></code> and <code>Borrow<[u8]></code>.</p>\n<h3>Why is this bad?</h3>\n<p>When providing implementations for <code>Borrow<T></code>, one should consider whether the different\nimplementations should act as facets or representations of the underlying type. Generic code\ntypically uses <code>Borrow<T></code> when it relies on the identical behavior of these additional trait\nimplementations. These traits will likely appear as additional trait bounds.</p>\n<p>In particular <code>Eq</code>, <code>Ord</code> and <code>Hash</code> must be equivalent for borrowed and owned values:\n<code>x.borrow() == y.borrow()</code> should give the same result as <code>x == y</code>.\nIt follows then that the following equivalence must hold:\n<code>hash(x) == hash((x as Borrow<[u8]>).borrow()) == hash((x as Borrow<str>).borrow())</code></p>\n<p>Unfortunately it doesn\u2019t hold as <code>hash(\"abc\") != hash(\"abc\".as_bytes())</code>.\nThis happens because the <code>Hash</code> impl for str passes an additional <code>0xFF</code> byte to\nthe hasher to avoid collisions. For example, given the tuples <code>(\"a\", \"bc\")</code>, and <code>(\"ab\", \"c\")</code>,\nthe two tuples would have the same hash value if the <code>0xFF</code> byte was not added.</p>\n<h3>Example</h3>\n<pre><code>use std::borrow::Borrow;\nuse std::hash::{Hash, Hasher};\n\nstruct ExampleType {\n    data: String\n}\n\nimpl Hash for ExampleType {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.data.hash(state);\n    }\n}\n\nimpl Borrow<str> for ExampleType {\n    fn borrow(&self) -> &str {\n        &self.data\n    }\n}\n\nimpl Borrow<[u8]> for ExampleType {\n    fn borrow(&self) -> &[u8] {\n        self.data.as_bytes()\n    }\n}\n</code></pre>\n<p>As a consequence, hashing a <code>&ExampleType</code> and hashing the result of the two\nborrows will result in different values.</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "impl_trait_in_params",
    "rule_name": "impl_trait_in_params",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints when <code>impl Trait</code> is being used in a function\u2019s parameters.</p>\n<h3>Why restrict this?</h3>\n<p>Turbofish syntax (<code>::<></code>) cannot be used to specify the type of an <code>impl Trait</code> parameter,\nmaking <code>impl Trait</code> less powerful. Readability may also be a factor.</p>\n<h3>Example</h3>\n<pre><code>trait MyTrait {}\nfn foo(a: impl MyTrait) {\n\t// [...]\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>trait MyTrait {}\nfn foo<T: MyTrait>(a: T) {\n\t// [...]\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "implicit_clone",
    "rule_name": "implicit_clone",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of <code>_.to_owned()</code>, <code>vec.to_vec()</code>, or similar when calling <code>_.clone()</code> would be clearer.</p>\n<h3>Why is this bad?</h3>\n<p>These methods do the same thing as <code>_.clone()</code> but may be confusing as\nto why we are calling <code>to_vec</code> on something that is already a <code>Vec</code> or calling <code>to_owned</code> on something that is already owned.</p>\n<h3>Example</h3>\n<pre><code>let a = vec![1, 2, 3];\nlet b = a.to_vec();\nlet c = a.to_owned();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = vec![1, 2, 3];\nlet b = a.clone();\nlet c = a.clone();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "implicit_hasher",
    "rule_name": "implicit_hasher",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for public <code>impl</code> or <code>fn</code> missing generalization\nover different hashers and implicitly defaulting to the default hashing\nalgorithm (<code>SipHash</code>).</p>\n<h3>Why is this bad?</h3>\n<p><code>HashMap</code> or <code>HashSet</code> with custom hashers cannot be\nused with them.</p>\n<h3>Known problems</h3>\n<p>Suggestions for replacing constructors can contain\nfalse-positives. Also applying suggestions can require modification of other\npieces of code, possibly including external crates.</p>\n<h3>Example</h3>\n<pre><code>impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n\npub fn foo(map: &mut HashMap<i32, i32>) { }\n</code></pre>\n<p>could be rewritten as</p>\n<pre><code>impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n\npub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "implicit_return",
    "rule_name": "implicit_return",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for missing return statements at the end of a block.</p>\n<h3>Why restrict this?</h3>\n<p>Omitting the return keyword whenever possible is idiomatic Rust code, but:</p>\n<ul>\n<li>Programmers coming from other languages might prefer the expressiveness of <code>return</code>.</li>\n<li>It\u2019s possible to miss the last returning statement because the only difference is a missing <code>;</code>.</li>\n<li>Especially in bigger code with multiple return paths, having a <code>return</code> keyword makes it easier to find the\ncorresponding statements.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>fn foo(x: usize) -> usize {\n    x\n}\n</code></pre>\n<p>add return</p>\n<pre><code>fn foo(x: usize) -> usize {\n    return x;\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "implicit_saturating_add",
    "rule_name": "implicit_saturating_add",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for implicit saturating addition.</p>\n<h3>Why is this bad?</h3>\n<p>The built-in function is more readable and may be faster.</p>\n<h3>Example</h3>\n<pre><code>let mut u:u32 = 7000;\n\nif u != u32::MAX {\n    u += 1;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut u:u32 = 7000;\n\nu = u.saturating_add(1);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "implicit_saturating_sub",
    "rule_name": "implicit_saturating_sub",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for implicit saturating subtraction.</p>\n<h3>Why is this bad?</h3>\n<p>Simplicity and readability. Instead we can easily use an builtin function.</p>\n<h3>Example</h3>\n<pre><code>let mut i: u32 = end - start;\n\nif i != 0 {\n    i -= 1;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut i: u32 = end - start;\n\ni = i.saturating_sub(1);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "implied_bounds_in_impls",
    "rule_name": "implied_bounds_in_impls",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for bounds in <code>impl Trait</code> in return position that are implied by other bounds.\nThis can happen when a trait is specified that another trait already has as a supertrait\n(e.g. <code>fn() -> impl Deref + DerefMut<Target = i32></code> has an unnecessary <code>Deref</code> bound,\nbecause <code>Deref</code> is a supertrait of <code>DerefMut</code>)</p>\n<h3>Why is this bad?</h3>\n<p>Specifying more bounds than necessary adds needless complexity for the reader.</p>\n<h3>Limitations</h3>\n<p>This lint does not check for implied bounds transitively. Meaning that\nit doesn\u2019t check for implied bounds from supertraits of supertraits\n(e.g. <code>trait A {} trait B: A {} trait C: B {}</code>, then having an <code>fn() -> impl A + C</code>)</p>\n<h3>Example</h3>\n<pre><code>fn f() -> impl Deref<Target = i32> + DerefMut<Target = i32> {\n//             ^^^^^^^^^^^^^^^^^^^ unnecessary bound, already implied by the `DerefMut` trait bound\n    Box::new(123)\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn f() -> impl DerefMut<Target = i32> {\n    Box::new(123)\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "impossible_comparisons",
    "rule_name": "impossible_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for double comparisons that can never succeed</p>\n<h3>Why is this bad?</h3>\n<p>The whole expression can be replaced by <code>false</code>,\nwhich is probably not the programmer\u2019s intention</p>\n<h3>Example</h3>\n<pre><code>if status_code <= 400 && status_code > 500 {}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "imprecise_flops",
    "rule_name": "imprecise_flops",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for floating-point expressions that\ncan be expressed using built-in methods to improve accuracy\nat the cost of performance.</p>\n<h3>Why is this bad?</h3>\n<p>Negatively impacts accuracy.</p>\n<h3>Example</h3>\n<pre><code>let a = 3f32;\nlet _ = a.powf(1.0 / 3.0);\nlet _ = (1.0 + a).ln();\nlet _ = a.exp() - 1.0;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = 3f32;\nlet _ = a.cbrt();\nlet _ = a.ln_1p();\nlet _ = a.exp_m1();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "incompatible_msrv",
    "rule_name": "incompatible_msrv",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks that no function newer than the defined MSRV (minimum\nsupported rust version) is used in the crate.</p>\n<h3>Why is this bad?</h3>\n<p>It would prevent the crate to be actually used with the specified MSRV.</p>\n<h3>Example</h3>\n<pre><code>// MSRV of 1.3.0\nuse std::thread::sleep;\nuse std::time::Duration;\n\n// Sleep was defined in `1.4.0`.\nsleep(Duration::new(1, 0));\n</code></pre>\n<p>To fix this problem, either increase your MSRV or use another item\navailable in your current MSRV.</p>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "inconsistent_digit_grouping",
    "rule_name": "inconsistent_digit_grouping",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if an integral or floating-point constant is\ngrouped inconsistently with underscores.</p>\n<h3>Why is this bad?</h3>\n<p>Readers may incorrectly interpret inconsistently\ngrouped digits.</p>\n<h3>Example</h3>\n<pre><code>618_64_9189_73_511\n</code></pre>\n<p>Use instead:</p>\n<pre><code>61_864_918_973_511\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "inconsistent_struct_constructor",
    "rule_name": "inconsistent_struct_constructor",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for struct constructors where all fields are shorthand and\nthe order of the field init shorthand in the constructor is inconsistent\nwith the order in the struct definition.</p>\n<h3>Why is this bad?</h3>\n<p>Since the order of fields in a constructor doesn\u2019t affect the\nresulted instance as the below example indicates,</p>\n<pre><code>#[derive(Debug, PartialEq, Eq)]\nstruct Foo {\n    x: i32,\n    y: i32,\n}\nlet x = 1;\nlet y = 2;\n\n// This assertion never fails:\nassert_eq!(Foo { x, y }, Foo { y, x });\n</code></pre>\n<p>inconsistent order can be confusing and decreases readability and consistency.</p>\n<h3>Example</h3>\n<pre><code>struct Foo {\n    x: i32,\n    y: i32,\n}\nlet x = 1;\nlet y = 2;\n\nFoo { y, x };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>Foo { x, y };\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "index_refutable_slice",
    "rule_name": "index_refutable_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>The lint checks for slice bindings in patterns that are only used to\naccess individual slice values.</p>\n<h3>Why is this bad?</h3>\n<p>Accessing slice values using indices can lead to panics. Using refutable\npatterns can avoid these. Binding to individual values also improves the\nreadability as they can be named.</p>\n<h3>Limitations</h3>\n<p>This lint currently only checks for immutable access inside <code>if let</code>\npatterns.</p>\n<h3>Example</h3>\n<pre><code>let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n\nif let Some(slice) = slice {\n    println!(\"{}\", slice[0]);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n\nif let Some(&[first, ..]) = slice {\n    println!(\"{}\", first);\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>max-suggested-slice-pattern-length</code>:  When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\nthe slice pattern that is suggested. If more elements are necessary, the lint is suppressed.\nFor example, <code>[_, _, _, e, ..]</code> is a slice pattern with 4 elements.</p>\n<p>(default: <code>3</code>)</p>\n</li>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "indexing_slicing",
    "rule_name": "indexing_slicing",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of indexing or slicing that may panic at runtime.</p>\n<p>This lint does not report on indexing or slicing operations\nthat always panic, clippy\u2019s <code>out_of_bound_indexing</code> already\nhandles those cases.</p>\n<h3>Why restrict this?</h3>\n<p>To avoid implicit panics from indexing and slicing.</p>\n<p>There are \u201cchecked\u201d alternatives which do not panic, and can be used with <code>unwrap()</code> to make\nan explicit panic when it is desired.</p>\n<h3>Limitations</h3>\n<p>This lint does not check for the usage of indexing or slicing on strings. These are covered\nby the more specific <code>string_slice</code> lint.</p>\n<h3>Example</h3>\n<pre><code>// Vector\nlet x = vec![0, 1, 2, 3];\n\nx[2];\nx[100];\n&x[2..100];\n\n// Array\nlet y = [0, 1, 2, 3];\n\nlet i = 10; // Could be a runtime value\nlet j = 20;\n&y[i..j];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>x.get(2);\nx.get(100);\nx.get(2..100);\n\nlet i = 10;\nlet j = 20;\ny.get(i..j);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-indexing-slicing-in-tests</code>:  Whether <code>indexing_slicing</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n<li>\n<p><code>suppress-restriction-lint-in-const</code>:  Whether to suppress a restriction lint in constant code. In same\ncases the restructured operation might not be unavoidable, as the\nsuggested counterparts are unavailable in constant code. This\nconfiguration will cause restriction lints to trigger even\nif no suggestion can be made.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "ineffective_bit_mask",
    "rule_name": "ineffective_bit_mask",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bit masks in comparisons which can be removed\nwithout changing the outcome. The basic structure can be seen in the\nfollowing table:</p>\n<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>equals</th></tr></thead><tbody>\n<tr><td><code>></code> / <code><=</code></td><td><code>|</code> / <code>^</code></td><td><code>x | 2 > 3</code></td><td><code>x > 3</code></td></tr>\n<tr><td><code><</code> / <code>>=</code></td><td><code>|</code> / <code>^</code></td><td><code>x ^ 1 < 4</code></td><td><code>x < 4</code></td></tr>\n</tbody></table>\n<h3>Why is this bad?</h3>\n<p>Not equally evil as <a><code>bad_bit_mask</code></a>,\nbut still a bit misleading, because the bit mask is ineffective.</p>\n<h3>Known problems</h3>\n<p>False negatives: This lint will only match instances\nwhere we have figured out the math (which is for a power-of-two compared\nvalue). This means things like <code>x | 1 >= 7</code> (which would be better written\nas <code>x >= 6</code>) will not be reported (but bit masks like this are fairly\nuncommon).</p>\n<h3>Example</h3>\n<pre><code>if (x | 1 > 3) {  }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if (x >= 2) {  }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "ineffective_open_options",
    "rule_name": "ineffective_open_options",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if both <code>.write(true)</code> and <code>.append(true)</code> methods are called\non a same <code>OpenOptions</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.append(true)</code> already enables <code>write(true)</code>, making this one\nsuperfluous.</p>\n<h3>Example</h3>\n<pre><code>let _ = OpenOptions::new()\n           .write(true)\n           .append(true)\n           .create(true)\n           .open(\"file.json\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = OpenOptions::new()\n           .append(true)\n           .create(true)\n           .open(\"file.json\");\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "inefficient_to_string",
    "rule_name": "inefficient_to_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.to_string()</code> on an <code>&&T</code> where\n<code>T</code> implements <code>ToString</code> directly (like <code>&&str</code> or <code>&&String</code>).</p>\n<h3>Why is this bad?</h3>\n<p>This bypasses the specialized implementation of\n<code>ToString</code> and instead goes through the more expensive string formatting\nfacilities.</p>\n<h3>Example</h3>\n<pre><code>// Generic implementation for `T: Display` is used (slow)\n[\"foo\", \"bar\"].iter().map(|s| s.to_string());\n\n// OK, the specialized impl is used\n[\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "infallible_destructuring_match",
    "rule_name": "infallible_destructuring_match",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for matches being used to destructure a single-variant enum\nor tuple struct where a <code>let</code> will suffice.</p>\n<h3>Why is this bad?</h3>\n<p>Just readability \u2013 <code>let</code> doesn\u2019t nest, whereas a <code>match</code> does.</p>\n<h3>Example</h3>\n<pre><code>enum Wrapper {\n    Data(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\n\nlet data = match wrapper {\n    Wrapper::Data(i) => i,\n};\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>enum Wrapper {\n    Data(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\nlet Wrapper::Data(data) = wrapper;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "infinite_iter",
    "rule_name": "infinite_iter",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iteration that is guaranteed to be infinite.</p>\n<h3>Why is this bad?</h3>\n<p>While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.</p>\n<h3>Example</h3>\n<pre><code>use std::iter;\n\niter::repeat(1_u8).collect::<Vec<_>>();\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "infinite_loop",
    "rule_name": "infinite_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for infinite loops in a function where the return type is not <code>!</code>\nand lint accordingly.</p>\n<h3>Why restrict this?</h3>\n<p>Making the return type <code>!</code> serves as documentation that the function does not return.\nIf the function is not intended to loop infinitely, then this lint may detect a bug.</p>\n<h3>Example</h3>\n<pre><code>fn run_forever() {\n    loop {\n        // do something\n    }\n}\n</code></pre>\n<p>If infinite loops are as intended:</p>\n<pre><code>fn run_forever() -> ! {\n    loop {\n        // do something\n    }\n}\n</code></pre>\n<p>Otherwise add a <code>break</code> or <code>return</code> condition:</p>\n<pre><code>fn run_forever() {\n    loop {\n        // do something\n        if condition {\n            break;\n        }\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "inherent_to_string",
    "rule_name": "inherent_to_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the definition of inherent methods with a signature of <code>to_string(&self) -> String</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This method is also implicitly defined if a type implements the <code>Display</code> trait. As the functionality of <code>Display</code> is much more versatile, it should be preferred.</p>\n<h3>Example</h3>\n<pre><code>pub struct A;\n\nimpl A {\n    pub fn to_string(&self) -> String {\n        \"I am A\".to_string()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A\")\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "inherent_to_string_shadow_display",
    "rule_name": "inherent_to_string_shadow_display",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the definition of inherent methods with a signature of <code>to_string(&self) -> String</code> and if the type implementing this method also implements the <code>Display</code> trait.</p>\n<h3>Why is this bad?</h3>\n<p>This method is also implicitly defined if a type implements the <code>Display</code> trait. The less versatile inherent method will then shadow the implementation introduced by <code>Display</code>.</p>\n<h3>Example</h3>\n<pre><code>use std::fmt;\n\npub struct A;\n\nimpl A {\n    pub fn to_string(&self) -> String {\n        \"I am A\".to_string()\n    }\n}\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A, too\")\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A\")\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "init_numbered_fields",
    "rule_name": "init_numbered_fields",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for tuple structs initialized with field syntax.\nIt will however not lint if a base initializer is present.\nThe lint will also ignore code in macros.</p>\n<h3>Why is this bad?</h3>\n<p>This may be confusing to the uninitiated and adds no\nbenefit as opposed to tuple initializers</p>\n<h3>Example</h3>\n<pre><code>struct TupleStruct(u8, u16);\n\nlet _ = TupleStruct {\n    0: 1,\n    1: 23,\n};\n\n// should be written as\nlet base = TupleStruct(1, 23);\n\n// This is OK however\nlet _ = TupleStruct { 0: 42, ..base };\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "inline_always",
    "rule_name": "inline_always",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items annotated with <code>#[inline(always)]</code>,\nunless the annotated function is empty or simply panics.</p>\n<h3>Why is this bad?</h3>\n<p>While there are valid uses of this annotation (and once\nyou know when to use it, by all means <code>allow</code> this lint), it\u2019s a common\nnewbie-mistake to pepper one\u2019s code with it.</p>\n<p>As a rule of thumb, before slapping <code>#[inline(always)]</code> on a function,\nmeasure if that additional function call really affects your runtime profile\nsufficiently to make up for the increase in compile time.</p>\n<h3>Known problems</h3>\n<p>False positives, big time. This lint is meant to be\ndeactivated by everyone doing serious performance work. This means having\ndone the measurement.</p>\n<h3>Example</h3>\n<pre><code>#[inline(always)]\nfn not_quite_hot_code(..) { ... }\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "inline_asm_x86_att_syntax",
    "rule_name": "inline_asm_x86_att_syntax",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of AT&T x86 assembly syntax.</p>\n<h3>Why restrict this?</h3>\n<p>To enforce consistent use of Intel x86 assembly syntax.</p>\n<h3>Example</h3>\n<pre><code>asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "inline_asm_x86_intel_syntax",
    "rule_name": "inline_asm_x86_intel_syntax",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of Intel x86 assembly syntax.</p>\n<h3>Why restrict this?</h3>\n<p>To enforce consistent use of AT&T x86 assembly syntax.</p>\n<h3>Example</h3>\n<pre><code>asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "inline_fn_without_body",
    "rule_name": "inline_fn_without_body",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[inline]</code> on trait methods without bodies</p>\n<h3>Why is this bad?</h3>\n<p>Only implementations of trait methods may be inlined.\nThe inline attribute is ignored for trait methods without bodies.</p>\n<h3>Example</h3>\n<pre><code>trait Animal {\n    #[inline]\n    fn name(&self) -> &'static str;\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "inspect_for_each",
    "rule_name": "inspect_for_each",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>inspect().for_each()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is the same as performing the computation\ninside <code>inspect</code> at the beginning of the closure in <code>for_each</code>.</p>\n<h3>Example</h3>\n<pre><code>[1,2,3,4,5].iter()\n.inspect(|&x| println!(\"inspect the number: {}\", x))\n.for_each(|&x| {\n    assert!(x >= 0);\n});\n</code></pre>\n<p>Can be written as</p>\n<pre><code>[1,2,3,4,5].iter()\n.for_each(|&x| {\n    println!(\"inspect the number: {}\", x);\n    assert!(x >= 0);\n});\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "int_plus_one",
    "rule_name": "int_plus_one",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>x >= y + 1</code> or <code>x - 1 >= y</code> (and <code><=</code>) in a block</p>\n<h3>Why is this bad?</h3>\n<p>Readability \u2013 better to use <code>> y</code> instead of <code>>= y + 1</code>.</p>\n<h3>Example</h3>\n<pre><code>if x >= y + 1 {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x > y {}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "integer_division",
    "rule_name": "integer_division",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for division of integers</p>\n<h3>Why restrict this?</h3>\n<p>When outside of some very specific algorithms,\ninteger division is very often a mistake because it discards the\nremainder.</p>\n<h3>Example</h3>\n<pre><code>let x = 3 / 2;\nprintln!(\"{}\", x);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = 3f32 / 2f32;\nprintln!(\"{}\", x);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "integer_division_remainder_used",
    "rule_name": "integer_division_remainder_used",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of division (<code>/</code>) and remainder (<code>%</code>) operations\nwhen performed on any integer types using the default <code>Div</code> and <code>Rem</code> trait implementations.</p>\n<h3>Why restrict this?</h3>\n<p>In cryptographic contexts, division can result in timing sidechannel vulnerabilities,\nand needs to be replaced with constant-time code instead (e.g. Barrett reduction).</p>\n<h3>Example</h3>\n<pre><code>let my_div = 10 / 2;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let my_div = 10 >> 1;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "into_iter_on_ref",
    "rule_name": "into_iter_on_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>into_iter</code> calls on references which should be replaced by <code>iter</code>\nor <code>iter_mut</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. Calling <code>into_iter</code> on a reference will not move out its\ncontent into the resulting iterator, which is confusing. It is better just call <code>iter</code> or\n<code>iter_mut</code> directly.</p>\n<h3>Example</h3>\n<pre><code>(&vec).into_iter();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>(&vec).iter();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "into_iter_without_iter",
    "rule_name": "into_iter_without_iter",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This is the opposite of the <code>iter_without_into_iter</code> lint.\nIt looks for <code>IntoIterator for (&|&mut) Type</code> implementations without an inherent <code>iter</code> or <code>iter_mut</code> method\non the type or on any of the types in its <code>Deref</code> chain.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s not bad, but having them is idiomatic and allows the type to be used in iterator chains\nby just calling <code>.iter()</code>, instead of the more awkward <code><&Type>::into_iter</code> or <code>(&val).into_iter()</code> syntax\nin case of ambiguity with another <code>IntoIterator</code> impl.</p>\n<h3>Limitations</h3>\n<p>This lint focuses on providing an idiomatic API. Therefore, it will only\nlint on types which are accessible outside of the crate. For internal types,\nthese methods can be added on demand if they are actually needed. Otherwise,\nit would trigger the <a><code>dead_code</code></a> lint for the unused method.</p>\n<h3>Example</h3>\n<pre><code>struct MySlice<'a>(&'a [u8]);\nimpl<'a> IntoIterator for &MySlice<'a> {\n    type Item = &'a u8;\n    type IntoIter = std::slice::Iter<'a, u8>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.iter()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\n    pub fn iter(&self) -> std::slice::Iter<'a, u8> {\n        self.into_iter()\n    }\n}\nimpl<'a> IntoIterator for &MySlice<'a> {\n    type Item = &'a u8;\n    type IntoIter = std::slice::Iter<'a, u8>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.iter()\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "invalid_null_ptr_usage",
    "rule_name": "invalid_null_ptr_usage",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for invalid usages of <code>ptr::null</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This causes undefined behavior.</p>\n<h3>Example</h3>\n<pre><code>// Undefined behavior\nunsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "invalid_regex",
    "rule_name": "invalid_regex",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks <a>regex</a> creation\n(with <code>Regex::new</code>, <code>RegexBuilder::new</code>, or <code>RegexSet::new</code>) for correct\nregex syntax.</p>\n<h3>Why is this bad?</h3>\n<p>This will lead to a runtime panic.</p>\n<h3>Example</h3>\n<pre><code>Regex::new(\"(\")\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "invalid_upcast_comparisons",
    "rule_name": "invalid_upcast_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for comparisons where the relation is always either\ntrue or false, but where one side has been upcast so that the comparison is\nnecessary. Only integer types are checked.</p>\n<h3>Why is this bad?</h3>\n<p>An expression like <code>let x : u8 = ...; (x as u32) > 300</code>\nwill mistakenly imply that it is possible for <code>x</code> to be outside the range of\n<code>u8</code>.</p>\n<h3>Known problems</h3>\n<p>https://github.com/rust-lang/rust-clippy/issues/886</p>\n<h3>Example</h3>\n<pre><code>let x: u8 = 1;\n(x as u32) > 300;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "inverted_saturating_sub",
    "rule_name": "inverted_saturating_sub",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for comparisons between integers, followed by subtracting the greater value from the\nlower one.</p>\n<h3>Why is this bad?</h3>\n<p>This could result in an underflow and is most likely not what the user wants. If this was\nintended to be a saturated subtraction, consider using the <code>saturating_sub</code> method directly.</p>\n<h3>Example</h3>\n<pre><code>let a = 12u32;\nlet b = 13u32;\n\nlet result = if a > b { b - a } else { 0 };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = 12u32;\nlet b = 13u32;\n\nlet result = a.saturating_sub(b);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "invisible_characters",
    "rule_name": "invisible_characters",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for invisible Unicode characters in the code.</p>\n<h3>Why is this bad?</h3>\n<p>Having an invisible character in the code makes for all\nsorts of April fools, but otherwise is very much frowned upon.</p>\n<h3>Example</h3>\n<p>You don\u2019t see it, but there may be a zero-width space or soft hyphen\nsome\u00adwhere in this text.</p>\n<h3>Past names</h3>\n<ul>\n<li>zero_width_space</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "is_digit_ascii_radix",
    "rule_name": "is_digit_ascii_radix",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds usages of <a><code>char::is_digit</code></a> that\ncan be replaced with <a><code>is_ascii_digit</code></a> or\n<a><code>is_ascii_hexdigit</code></a>.</p>\n<h3>Why is this bad?</h3>\n<p><code>is_digit(..)</code> is slower and requires specifying the radix.</p>\n<h3>Example</h3>\n<pre><code>let c: char = '6';\nc.is_digit(10);\nc.is_digit(16);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let c: char = '6';\nc.is_ascii_digit();\nc.is_ascii_hexdigit();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "items_after_statements",
    "rule_name": "items_after_statements",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items declared after some statement in a block.</p>\n<h3>Why is this bad?</h3>\n<p>Items live for the entire scope they are declared\nin. But statements are processed in order. This might cause confusion as\nit\u2019s hard to figure out which item is meant in a statement.</p>\n<h3>Example</h3>\n<pre><code>fn foo() {\n    println!(\"cake\");\n}\n\nfn main() {\n    foo(); // prints \"foo\"\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo() {\n    println!(\"cake\");\n}\n\nfn main() {\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n    foo(); // prints \"foo\"\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "items_after_test_module",
    "rule_name": "items_after_test_module",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Triggers if an item is declared after the testing module marked with <code>#[cfg(test)]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Having items declared after the testing module is confusing and may lead to bad test coverage.</p>\n<h3>Example</h3>\n<pre><code>#[cfg(test)]\nmod tests {\n    // [...]\n}\n\nfn my_function() {\n    // [...]\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn my_function() {\n    // [...]\n}\n\n#[cfg(test)]\nmod tests {\n    // [...]\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_cloned_collect",
    "rule_name": "iter_cloned_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>.cloned().collect()</code> on slice to\ncreate a <code>Vec</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.to_vec()</code> is clearer</p>\n<h3>Example</h3>\n<pre><code>let s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s[..].iter().cloned().collect();\n</code></pre>\n<p>The better use would be:</p>\n<pre><code>let s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s.to_vec();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_count",
    "rule_name": "iter_count",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>.iter().count()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.len()</code> is more efficient and more\nreadable.</p>\n<h3>Example</h3>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\n\nsome_vec.iter().count();\n&some_vec[..].iter().count();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\n\nsome_vec.len();\n&some_vec[..].len();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_filter_is_ok",
    "rule_name": "iter_filter_is_ok",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.filter(Result::is_ok)</code> that may be replaced with a <code>.flatten()</code> call.\nThis lint will require additional changes to the follow-up calls as it affects the type.</p>\n<h3>Why is this bad?</h3>\n<p>This pattern is often followed by manual unwrapping of <code>Result</code>. The simplification\nresults in more readable and succinct code without the need for manual unwrapping.</p>\n<h3>Example</h3>\n<pre><code>vec![Ok::<i32, String>(1)].into_iter().filter(Result::is_ok);\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![Ok::<i32, String>(1)].into_iter().flatten();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_filter_is_some",
    "rule_name": "iter_filter_is_some",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.filter(Option::is_some)</code> that may be replaced with a <code>.flatten()</code> call.\nThis lint will require additional changes to the follow-up calls as it affects the type.</p>\n<h3>Why is this bad?</h3>\n<p>This pattern is often followed by manual unwrapping of the <code>Option</code>. The simplification\nresults in more readable and succinct code without the need for manual unwrapping.</p>\n<h3>Example</h3>\n<pre><code>vec![Some(1)].into_iter().filter(Option::is_some);\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![Some(1)].into_iter().flatten();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_kv_map",
    "rule_name": "iter_kv_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iterating a map (<code>HashMap</code> or <code>BTreeMap</code>) and\nignoring either the keys or values.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. There are <code>keys</code> and <code>values</code> methods that\ncan be used to express that we only need the keys or the values.</p>\n<h3>Example</h3>\n<pre><code>let map: HashMap<u32, u32> = HashMap::new();\nlet values = map.iter().map(|(_, value)| value).collect::<Vec<_>>();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let map: HashMap<u32, u32> = HashMap::new();\nlet values = map.values().collect::<Vec<_>>();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_next_loop",
    "rule_name": "iter_next_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for loops on <code>x.next()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>next()</code> returns either <code>Some(value)</code> if there was a\nvalue, or <code>None</code> otherwise. The insidious thing is that <code>Option<_></code>\nimplements <code>IntoIterator</code>, so that possibly one value will be iterated,\nleading to some hard to find bugs. No one will want to write such code\n<a>except to win an Underhanded Rust\nContest</a>.</p>\n<h3>Example</h3>\n<pre><code>for x in y.next() {\n    ..\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "iter_next_slice",
    "rule_name": "iter_next_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>iter().next()</code> on a Slice or an Array</p>\n<h3>Why is this bad?</h3>\n<p>These can be shortened into <code>.get()</code></p>\n<h3>Example</h3>\n<pre><code>a[2..].iter().next();\nb.iter().next();\n</code></pre>\n<p>should be written as:</p>\n<pre><code>a.get(2);\nb.get(0);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_not_returning_iterator",
    "rule_name": "iter_not_returning_iterator",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects methods named <code>iter</code> or <code>iter_mut</code> that do not have a return type that implements <code>Iterator</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Methods named <code>iter</code> or <code>iter_mut</code> conventionally return an <code>Iterator</code>.</p>\n<h3>Example</h3>\n<pre><code>// `String` does not implement `Iterator`\nstruct Data {}\nimpl Data {\n    fn iter(&self) -> String {\n        todo!()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::str::Chars;\nstruct Data {}\nimpl Data {\n   fn iter(&self) -> Chars<'static> {\n       todo!()\n   }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_nth",
    "rule_name": "iter_nth",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.iter().nth()</code>/<code>.iter_mut().nth()</code> on standard library types that have\nequivalent <code>.get()</code>/<code>.get_mut()</code> methods.</p>\n<h3>Why is this bad?</h3>\n<p><code>.get()</code> and <code>.get_mut()</code> are equivalent but more concise.</p>\n<h3>Example</h3>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.get(3);\nlet bad_slice = &some_vec[..].get(3);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_nth_zero",
    "rule_name": "iter_nth_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>iter.nth(0)</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>iter.next()</code> is equivalent to\n<code>iter.nth(0)</code>, as they both consume the next element,\nbut is more readable.</p>\n<h3>Example</h3>\n<pre><code>let x = s.iter().nth(0);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = s.iter().next();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_on_empty_collections",
    "rule_name": "iter_on_empty_collections",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>iter</code>, <code>iter_mut</code> or <code>into_iter</code> on empty collections</p>\n<h3>Why is this bad?</h3>\n<p>It is simpler to use the empty function from the standard library:</p>\n<h3>Example</h3>\n<pre><code>use std::{slice, option};\nlet a: slice::Iter<i32> = [].iter();\nlet f: option::IntoIter<i32> = None.into_iter();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::iter;\nlet a: iter::Empty<i32> = iter::empty();\nlet b: iter::Empty<i32> = iter::empty();\n</code></pre>\n<h3>Known problems</h3>\n<p>The type of the resulting iterator might become incompatible with its usage</p>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_on_single_items",
    "rule_name": "iter_on_single_items",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>iter</code>, <code>iter_mut</code> or <code>into_iter</code> on collections containing a single item</p>\n<h3>Why is this bad?</h3>\n<p>It is simpler to use the once function from the standard library:</p>\n<h3>Example</h3>\n<pre><code>let a = [123].iter();\nlet b = Some(123).into_iter();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::iter;\nlet a = iter::once(&123);\nlet b = iter::once(123);\n</code></pre>\n<h3>Known problems</h3>\n<p>The type of the resulting iterator might become incompatible with its usage</p>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_out_of_bounds",
    "rule_name": "iter_out_of_bounds",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for iterator combinator calls such as <code>.take(x)</code> or <code>.skip(x)</code>\nwhere <code>x</code> is greater than the amount of items that an iterator will produce.</p>\n<h3>Why is this bad?</h3>\n<p>Taking or skipping more items than there are in an iterator either creates an iterator\nwith all items from the original iterator or an iterator with no items at all.\nThis is most likely not what the user intended to do.</p>\n<h3>Example</h3>\n<pre><code>for _ in [1, 2, 3].iter().take(4) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for _ in [1, 2, 3].iter() {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_over_hash_type",
    "rule_name": "iter_over_hash_type",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This is a restriction lint which prevents the use of hash types (i.e., <code>HashSet</code> and <code>HashMap</code>) in for loops.</p>\n<h3>Why restrict this?</h3>\n<p>Because hash types are unordered, when iterated through such as in a <code>for</code> loop, the values are returned in\nan undefined order. As a result, on redundant systems this may cause inconsistencies and anomalies.\nIn addition, the unknown order of the elements may reduce readability or introduce other undesired\nside effects.</p>\n<h3>Example</h3>\n<pre><code>    let my_map = std::collections::HashMap::<i32, String>::new();\n    for (key, value) in my_map { /* ... */ }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>    let my_map = std::collections::HashMap::<i32, String>::new();\n    let mut keys = my_map.keys().clone().collect::<Vec<_>>();\n    keys.sort();\n    for key in keys {\n        let value = &my_map[key];\n    }\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_overeager_cloned",
    "rule_name": "iter_overeager_cloned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.cloned().<func>()</code> where call to <code>.cloned()</code> can be postponed.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s often inefficient to clone all elements of an iterator, when eventually, only some\nof them will be consumed.</p>\n<h3>Known Problems</h3>\n<p>This <code>lint</code> removes the side of effect of cloning items in the iterator.\nA code that relies on that side-effect could fail.</p>\n<h3>Examples</h3>\n<pre><code>vec.iter().cloned().take(10);\nvec.iter().cloned().last();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.iter().take(10).cloned();\nvec.iter().last().cloned();\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_skip_next",
    "rule_name": "iter_skip_next",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.skip(x).next()</code> on iterators.</p>\n<h3>Why is this bad?</h3>\n<p><code>.nth(x)</code> is cleaner</p>\n<h3>Example</h3>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().skip(3).next();\nlet bad_slice = &some_vec[..].iter().skip(3).next();\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "iter_skip_zero",
    "rule_name": "iter_skip_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.skip(0)</code> on iterators.</p>\n<h3>Why is this bad?</h3>\n<p>This was likely intended to be <code>.skip(1)</code> to skip the first element, as <code>.skip(0)</code> does\nnothing. If not, the call should be removed.</p>\n<h3>Example</h3>\n<pre><code>let v = vec![1, 2, 3];\nlet x = v.iter().skip(0).collect::<Vec<_>>();\nlet y = v.iter().collect::<Vec<_>>();\nassert_eq!(x, y);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "iter_with_drain",
    "rule_name": "iter_with_drain",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.drain(..)</code> on <code>Vec</code> and <code>VecDeque</code> for iteration.</p>\n<h3>Why is this bad?</h3>\n<p><code>.into_iter()</code> is simpler with better performance.</p>\n<h3>Example</h3>\n<pre><code>let mut foo = vec![0, 1, 2, 3];\nlet bar: HashSet<usize> = foo.drain(..).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let foo = vec![0, 1, 2, 3];\nlet bar: HashSet<usize> = foo.into_iter().collect();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "iter_without_into_iter",
    "rule_name": "iter_without_into_iter",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for <code>iter</code> and <code>iter_mut</code> methods without an associated <code>IntoIterator for (&|&mut) Type</code> implementation.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s not bad, but having them is idiomatic and allows the type to be used in for loops directly\n(<code>for val in &iter {}</code>), without having to first call <code>iter()</code> or <code>iter_mut()</code>.</p>\n<h3>Limitations</h3>\n<p>This lint focuses on providing an idiomatic API. Therefore, it will only\nlint on types which are accessible outside of the crate. For internal types,\nthe <code>IntoIterator</code> trait can be implemented on demand if it is actually needed.</p>\n<h3>Example</h3>\n<pre><code>struct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\n    pub fn iter(&self) -> std::slice::Iter<'a, u8> {\n        self.0.iter()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\n    pub fn iter(&self) -> std::slice::Iter<'a, u8> {\n        self.0.iter()\n    }\n}\nimpl<'a> IntoIterator for &MySlice<'a> {\n    type Item = &'a u8;\n    type IntoIter = std::slice::Iter<'a, u8>;\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "iterator_step_by_zero",
    "rule_name": "iterator_step_by_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calling <code>.step_by(0)</code> on iterators which panics.</p>\n<h3>Why is this bad?</h3>\n<p>This very much looks like an oversight. Use <code>panic!()</code> instead if you\nactually intend to panic.</p>\n<h3>Example</h3>\n<pre><code>for x in (0..100).step_by(0) {\n    //..\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "join_absolute_paths",
    "rule_name": "join_absolute_paths",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>Path::join</code> that start with a path separator (<code>\\\\</code> or <code>/</code>).</p>\n<h3>Why is this bad?</h3>\n<p>If the argument to <code>Path::join</code> starts with a separator, it will overwrite\nthe original path. If this is intentional, prefer using <code>Path::new</code> instead.</p>\n<p>Note the behavior is platform dependent. A leading <code>\\\\</code> will be accepted\non unix systems as part of the file name</p>\n<p>See <a><code>Path::join</code></a></p>\n<h3>Example</h3>\n<pre><code>let path = Path::new(\"/bin\");\nlet joined_path = path.join(\"/sh\");\nassert_eq!(joined_path, PathBuf::from(\"/sh\"));\n</code></pre>\n<p>Use instead;</p>\n<pre><code>let path = Path::new(\"/bin\");\n\n// If this was unintentional, remove the leading separator\nlet joined_path = path.join(\"sh\");\nassert_eq!(joined_path, PathBuf::from(\"/bin/sh\"));\n\n// If this was intentional, create a new path instead\nlet new = Path::new(\"/sh\");\nassert_eq!(new, PathBuf::from(\"/sh\"));\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "just_underscores_and_digits",
    "rule_name": "just_underscores_and_digits",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if you have variables whose name consists of just\nunderscores and digits.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s hard to memorize what a variable means without a\ndescriptive name.</p>\n<h3>Example</h3>\n<pre><code>let _1 = 1;\nlet ___1 = 1;\nlet __1___2 = 11;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "large_const_arrays",
    "rule_name": "large_const_arrays",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for large <code>const</code> arrays that should\nbe defined as <code>static</code> instead.</p>\n<h3>Why is this bad?</h3>\n<p>Performance: const variables are inlined upon use.\nStatic items result in only one instance and has a fixed location in memory.</p>\n<h3>Example</h3>\n<pre><code>pub const a = [0u32; 1_000_000];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub static a = [0u32; 1_000_000];\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>array-size-threshold</code>:  The maximum allowed size for arrays on the stack</p>\n<p>(default: <code>16384</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "large_digit_groups",
    "rule_name": "large_digit_groups",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if the digits of an integral or floating-point\nconstant are grouped into groups that\nare too large.</p>\n<h3>Why is this bad?</h3>\n<p>Negatively impacts readability.</p>\n<h3>Example</h3>\n<pre><code>let x: u64 = 6186491_8973511;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "large_enum_variant",
    "rule_name": "large_enum_variant",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for large size differences between variants on\n<code>enum</code>s.</p>\n<h3>Why is this bad?</h3>\n<p>Enum size is bounded by the largest variant. Having one\nlarge variant can penalize the memory layout of that enum.</p>\n<h3>Known problems</h3>\n<p>This lint obviously cannot take the distribution of\nvariants in your running program into account. It is possible that the\nsmaller variants make up less than 1% of all instances, in which case\nthe overhead is negligible and the boxing is counter-productive. Always\nmeasure the change this lint suggests.</p>\n<p>For types that implement <code>Copy</code>, the suggestion to <code>Box</code> a variant\u2019s\ndata would require removing the trait impl. The types can of course\nstill be <code>Clone</code>, but that is worse ergonomically. Depending on the\nuse case it may be possible to store the large data in an auxiliary\nstructure (e.g. Arena or ECS).</p>\n<p>The lint will ignore the impact of generic types to the type layout by\nassuming every type parameter is zero-sized. Depending on your use case,\nthis may lead to a false positive.</p>\n<h3>Example</h3>\n<pre><code>enum Test {\n    A(i32),\n    B([i32; 8000]),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Possibly better\nenum Test2 {\n    A(i32),\n    B(Box<[i32; 8000]>),\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>enum-variant-size-threshold</code>:  The maximum size of an enum\u2019s variant to avoid box suggestion</p>\n<p>(default: <code>200</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "large_futures",
    "rule_name": "large_futures",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It checks for the size of a <code>Future</code> created by <code>async fn</code> or <code>async {}</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Due to the current <a>unideal implementation</a> of <code>Coroutine</code>,\nlarge size of a <code>Future</code> may cause stack overflows.</p>\n<h3>Example</h3>\n<pre><code>async fn large_future(_x: [u8; 16 * 1024]) {}\n\npub async fn trigger() {\n    large_future([0u8; 16 * 1024]).await;\n}\n</code></pre>\n<p><code>Box::pin</code> the big future instead.</p>\n<pre><code>async fn large_future(_x: [u8; 16 * 1024]) {}\n\npub async fn trigger() {\n    Box::pin(large_future([0u8; 16 * 1024])).await;\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>future-size-threshold</code>:  The maximum byte size a <code>Future</code> can have, before it triggers the <code>clippy::large_futures</code> lint</p>\n<p>(default: <code>16384</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "large_include_file",
    "rule_name": "large_include_file",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the inclusion of large files via <code>include_bytes!()</code>\nor <code>include_str!()</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Including large files can undesirably increase the size of the binary produced by the compiler.\nThis lint may be used to catch mistakes where an unexpectedly large file is included, or\ntemporarily to obtain a list of all large files.</p>\n<h3>Example</h3>\n<pre><code>let included_str = include_str!(\"very_large_file.txt\");\nlet included_bytes = include_bytes!(\"very_large_file.txt\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fs;\n\n// You can load the file at runtime\nlet string = fs::read_to_string(\"very_large_file.txt\")?;\nlet bytes = fs::read(\"very_large_file.txt\")?;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>max-include-file-size</code>:  The maximum size of a file included via <code>include_bytes!()</code> or <code>include_str!()</code>, in bytes</p>\n<p>(default: <code>1000000</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "large_stack_arrays",
    "rule_name": "large_stack_arrays",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for local arrays that may be too large.</p>\n<h3>Why is this bad?</h3>\n<p>Large local arrays may cause stack overflow.</p>\n<h3>Example</h3>\n<pre><code>let a = [0u32; 1_000_000];\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>array-size-threshold</code>:  The maximum allowed size for arrays on the stack</p>\n<p>(default: <code>16384</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "large_stack_frames",
    "rule_name": "large_stack_frames",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions that use a lot of stack space.</p>\n<p>This often happens when constructing a large type, such as an array with a lot of elements,\nor constructing <em>many</em> smaller-but-still-large structs, or copying around a lot of large types.</p>\n<p>This lint is a more general version of <a><code>large_stack_arrays</code></a>\nthat is intended to look at functions as a whole instead of only individual array expressions inside of a function.</p>\n<h3>Why is this bad?</h3>\n<p>The stack region of memory is very limited in size (usually <em>much</em> smaller than the heap) and attempting to\nuse too much will result in a stack overflow and crash the program.\nTo avoid this, you should consider allocating large types on the heap instead (e.g. by boxing them).</p>\n<p>Keep in mind that the code path to construction of large types does not even need to be reachable;\nit purely needs to <em>exist</em> inside of the function to contribute to the stack size.\nFor example, this causes a stack overflow even though the branch is unreachable:</p>\n<pre><code>fn main() {\n    if false {\n        let x = [0u8; 10000000]; // 10 MB stack array\n        black_box(&x);\n    }\n}\n</code></pre>\n<h3>Known issues</h3>\n<p>False positives. The stack size that clippy sees is an estimated value and can be vastly different\nfrom the actual stack usage after optimizations passes have run (especially true in release mode).\nModern compilers are very smart and are able to optimize away a lot of unnecessary stack allocations.\nIn debug mode however, it is usually more accurate.</p>\n<p>This lint works by summing up the size of all variables that the user typed, variables that were\nimplicitly introduced by the compiler for temporaries, function arguments and the return value,\nand comparing them against a (configurable, but high-by-default).</p>\n<h3>Example</h3>\n<p>This function creates four 500 KB arrays on the stack. Quite big but just small enough to not trigger <code>large_stack_arrays</code>.\nHowever, looking at the function as a whole, it\u2019s clear that this uses a lot of stack space.</p>\n<pre><code>struct QuiteLargeType([u8; 500_000]);\nfn foo() {\n    // ... some function that uses a lot of stack space ...\n    let _x1 = QuiteLargeType([0; 500_000]);\n    let _x2 = QuiteLargeType([0; 500_000]);\n    let _x3 = QuiteLargeType([0; 500_000]);\n    let _x4 = QuiteLargeType([0; 500_000]);\n}\n</code></pre>\n<p>Instead of doing this, allocate the arrays on the heap.\nThis currently requires going through a <code>Vec</code> first and then converting it to a <code>Box</code>:</p>\n<pre><code>struct NotSoLargeType(Box<[u8]>);\n\nfn foo() {\n    let _x1 = NotSoLargeType(vec![0; 500_000].into_boxed_slice());\n//                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  Now heap allocated.\n//                                                                The size of `NotSoLargeType` is 16 bytes.\n//  ...\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>stack-size-threshold</code>:  The maximum allowed stack size for functions in bytes</p>\n<p>(default: <code>512000</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "large_types_passed_by_value",
    "rule_name": "large_types_passed_by_value",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions taking arguments by value, where\nthe argument type is <code>Copy</code> and large enough to be worth considering\npassing by reference. Does not trigger if the function is being exported,\nbecause that might induce API breakage, if the parameter is declared as mutable,\nor if the argument is a <code>self</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Arguments passed by value might result in an unnecessary\nshallow copy, taking up more space in the stack and requiring a call to\n<code>memcpy</code>, which can be expensive.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Clone, Copy)]\nstruct TooLarge([u8; 2048]);\n\nfn foo(v: TooLarge) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(v: &TooLarge) {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>pass-by-value-size-limit</code>:  The minimum size (in bytes) to consider a type for passing by reference instead of by value.</p>\n<p>(default: <code>256</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "legacy_numeric_constants",
    "rule_name": "legacy_numeric_constants",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code><integer>::max_value()</code>, <code>std::<integer>::MAX</code>,\n<code>std::<float>::EPSILON</code>, etc.</p>\n<h3>Why is this bad?</h3>\n<p>All of these have been superseded by the associated constants on their respective types,\nsuch as <code>i128::MAX</code>. These legacy items may be deprecated in a future version of rust.</p>\n<h3>Example</h3>\n<pre><code>let eps = std::f32::EPSILON;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let eps = f32::EPSILON;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "len_without_is_empty",
    "rule_name": "len_without_is_empty",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items that implement <code>.len()</code> but not\n<code>.is_empty()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is good custom to have both methods, because for\nsome data structures, asking about the length will be a costly operation,\nwhereas <code>.is_empty()</code> can usually answer in constant time. Also it used to\nlead to false positives on the <a><code>len_zero</code></a> lint \u2013 currently that\nlint will ignore such entities.</p>\n<h3>Example</h3>\n<pre><code>impl X {\n    pub fn len(&self) -> usize {\n        ..\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "len_zero",
    "rule_name": "len_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for getting the length of something via <code>.len()</code>\njust to compare to zero, and suggests using <code>.is_empty()</code> where applicable.</p>\n<h3>Why is this bad?</h3>\n<p>Some structures can answer <code>.is_empty()</code> much faster\nthan calculating their length. So it is good to get into the habit of using\n<code>.is_empty()</code>, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.</p>\n<h3>Example</h3>\n<pre><code>if x.len() == 0 {\n    ..\n}\nif y.len() != 0 {\n    ..\n}\n</code></pre>\n<p>instead use</p>\n<pre><code>if x.is_empty() {\n    ..\n}\nif !y.is_empty() {\n    ..\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "let_and_return",
    "rule_name": "let_and_return",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>let</code>-bindings, which are subsequently\nreturned.</p>\n<h3>Why is this bad?</h3>\n<p>It is just extraneous code. Remove it to make your code\nmore rusty.</p>\n<h3>Known problems</h3>\n<p>In the case of some temporaries, e.g. locks, eliding the variable binding could lead\nto deadlocks. See <a>this issue</a>.\nThis could become relevant if the code is later changed to use the code that would have been\nbound without first assigning it to a let-binding.</p>\n<h3>Example</h3>\n<pre><code>fn foo() -> String {\n    let x = String::new();\n    x\n}\n</code></pre>\n<p>instead, use</p>\n<pre><code>fn foo() -> String {\n    String::new()\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "let_underscore_future",
    "rule_name": "let_underscore_future",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>let _ = <expr></code> where the resulting type of expr implements <code>Future</code></p>\n<h3>Why is this bad?</h3>\n<p>Futures must be polled for work to be done. The original intention was most likely to await the future\nand ignore the resulting value.</p>\n<h3>Example</h3>\n<pre><code>async fn foo() -> Result<(), ()> {\n    Ok(())\n}\nlet _ = foo();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn foo() -> Result<(), ()> {\n    Ok(())\n}\nlet _ = foo().await;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "let_underscore_lock",
    "rule_name": "let_underscore_lock",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>let _ = sync_lock</code>. This supports <code>mutex</code> and <code>rwlock</code> in\n<code>parking_lot</code>. For <code>std</code> locks see the <code>rustc</code> lint\n<a><code>let_underscore_lock</code></a></p>\n<h3>Why is this bad?</h3>\n<p>This statement immediately drops the lock instead of\nextending its lifetime to the end of the scope, which is often not intended.\nTo extend lock lifetime to the end of the scope, use an underscore-prefixed\nname instead (i.e. _lock). If you want to explicitly drop the lock,\n<code>std::mem::drop</code> conveys your intention better and is less error-prone.</p>\n<h3>Example</h3>\n<pre><code>let _ = mutex.lock();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _lock = mutex.lock();\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "let_underscore_must_use",
    "rule_name": "let_underscore_must_use",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>let _ = <expr></code> where expr is <code>#[must_use]</code></p>\n<h3>Why restrict this?</h3>\n<p>To ensure that all <code>#[must_use]</code> types are used rather than ignored.</p>\n<h3>Example</h3>\n<pre><code>fn f() -> Result<u32, u32> {\n    Ok(0)\n}\n\nlet _ = f();\n// is_ok() is marked #[must_use]\nlet _ = f().is_ok();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "let_underscore_untyped",
    "rule_name": "let_underscore_untyped",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>let _ = <expr></code> without a type annotation, and suggests to either provide one,\nor remove the <code>let</code> keyword altogether.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>let _ = <expr></code> expression ignores the value of <code><expr></code>, but will continue to do so even\nif the type were to change, thus potentially introducing subtle bugs. By supplying a type\nannotation, one will be forced to re-visit the decision to ignore the value in such cases.</p>\n<h3>Known problems</h3>\n<p>The <code>_ = <expr></code> is not properly supported by some tools (e.g. IntelliJ) and may seem odd\nto many developers. This lint also partially overlaps with the other <code>let_underscore_*</code>\nlints.</p>\n<h3>Example</h3>\n<pre><code>fn foo() -> Result<u32, ()> {\n    Ok(123)\n}\nlet _ = foo();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo() -> Result<u32, ()> {\n    Ok(123)\n}\n// Either provide a type annotation:\nlet _: Result<u32, ()> = foo();\n// \u2026or drop the let keyword:\n_ = foo();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "let_unit_value",
    "rule_name": "let_unit_value",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for binding a unit value.</p>\n<h3>Why is this bad?</h3>\n<p>A unit value cannot usefully be used anywhere. So\nbinding one is kind of pointless.</p>\n<h3>Example</h3>\n<pre><code>let x = {\n    1;\n};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "let_with_type_underscore",
    "rule_name": "let_with_type_underscore",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects when a variable is declared with an explicit type of <code>_</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It adds noise, <code>: _</code> provides zero clarity or utility.</p>\n<h3>Example</h3>\n<pre><code>let my_number: _ = 1;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let my_number = 1;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "lines_filter_map_ok",
    "rule_name": "lines_filter_map_ok",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>lines.filter_map(Result::ok)</code> or <code>lines.flat_map(Result::ok)</code>\nwhen <code>lines</code> has type <code>std::io::Lines</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>Lines</code> instances might produce a never-ending stream of <code>Err</code>, in which case\n<code>filter_map(Result::ok)</code> will enter an infinite loop while waiting for an\n<code>Ok</code> variant. Calling <code>next()</code> once is sufficient to enter the infinite loop,\neven in the absence of explicit loops in the user code.</p>\n<p>This situation can arise when working with user-provided paths. On some platforms,\n<code>std::fs::File::open(path)</code> might return <code>Ok(fs)</code> even when <code>path</code> is a directory,\nbut any later attempt to read from <code>fs</code> will return an error.</p>\n<h3>Known problems</h3>\n<p>This lint suggests replacing <code>filter_map()</code> or <code>flat_map()</code> applied to a <code>Lines</code>\ninstance in all cases. There are two cases where the suggestion might not be\nappropriate or necessary:</p>\n<ul>\n<li>If the <code>Lines</code> instance can never produce any error, or if an error is produced\nonly once just before terminating the iterator, using <code>map_while()</code> is not\nnecessary but will not do any harm.</li>\n<li>If the <code>Lines</code> instance can produce intermittent errors then recover and produce\nsuccessful results, using <code>map_while()</code> would stop at the first error.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let mut lines = BufReader::new(File::open(\"some-path\")?).lines().filter_map(Result::ok);\n// If \"some-path\" points to a directory, the next statement never terminates:\nlet first_line: Option<String> = lines.next();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut lines = BufReader::new(File::open(\"some-path\")?).lines().map_while(Result::ok);\nlet first_line: Option<String> = lines.next();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "linkedlist",
    "rule_name": "linkedlist",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of any <code>LinkedList</code>, suggesting to use a\n<code>Vec</code> or a <code>VecDeque</code> (formerly called <code>RingBuf</code>).</p>\n<h3>Why is this bad?</h3>\n<p>Gankra says:</p>\n<blockquote>\n<p>The TL;DR of <code>LinkedList</code> is that it\u2019s built on a massive amount of\npointers and indirection.\nIt wastes memory, it has terrible cache locality, and is all-around slow.\n<code>RingBuf</code>, while\n\u201conly\u201d amortized for push/pop, should be faster in the general case for\nalmost every possible\nworkload, and isn\u2019t even amortized at all if you can predict the capacity\nyou need.</p>\n<p><code>LinkedList</code>s are only really good if you\u2019re doing a lot of merging or\nsplitting of lists.\nThis is because they can just mangle some pointers instead of actually\ncopying the data. Even\nif you\u2019re doing a lot of insertion in the middle of the list, <code>RingBuf</code>\ncan still be better\nbecause of how expensive it is to seek to the middle of a <code>LinkedList</code>.</p>\n</blockquote>\n<h3>Known problems</h3>\n<p>False positives \u2013 the instances where using a\n<code>LinkedList</code> makes sense are few and far between, but they can still happen.</p>\n<h3>Example</h3>\n<pre><code>let x: LinkedList<usize> = LinkedList::new();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "lint_groups_priority",
    "rule_name": "lint_groups_priority",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for lint groups with the same priority as lints in the <code>Cargo.toml</code>\n<a><code>[lints]</code> table</a>.</p>\n<p>This lint will be removed once <a>cargo#12918</a>\nis resolved.</p>\n<h3>Why is this bad?</h3>\n<p>The order of lints in the <code>[lints]</code> is ignored, to have a lint override a group the\n<code>priority</code> field needs to be used, otherwise the sort order is undefined.</p>\n<h3>Known problems</h3>\n<p>Does not check lints inherited using <code>lints.workspace = true</code></p>\n<h3>Example</h3>\n<pre><code>[lints.clippy]\npedantic = \"warn\"\nsimilar_names = \"allow\"\n</code></pre>\n<p>Use instead:</p>\n<pre><code>[lints.clippy]\npedantic = { level = \"warn\", priority = -1 }\nsimilar_names = \"allow\"\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "literal_string_with_formatting_args",
    "rule_name": "literal_string_with_formatting_args",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if string literals have formatting arguments outside of macros\nusing them (like <code>format!</code>).</p>\n<h3>Why is this bad?</h3>\n<p>It will likely not generate the expected content.</p>\n<h3>Example</h3>\n<pre><code>let x: Option<usize> = None;\nlet y = \"hello\";\nx.expect(\"{y:?}\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Option<usize> = None;\nlet y = \"hello\";\nx.expect(&format!(\"{y:?}\"));\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "little_endian_bytes",
    "rule_name": "little_endian_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of the <code>to_le_bytes</code> method and/or the function <code>from_le_bytes</code>.</p>\n<h3>Why restrict this?</h3>\n<p>To ensure use of big-endian or the target\u2019s endianness rather than little-endian.</p>\n<h3>Example</h3>\n<pre><code>let _x = 2i32.to_le_bytes();\nlet _y = 2i64.to_le_bytes();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "lossy_float_literal",
    "rule_name": "lossy_float_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for whole number float literals that\ncannot be represented as the underlying type without loss.</p>\n<h3>Why restrict this?</h3>\n<p>If the value was intended to be exact, it will not be.\nThis may be especially surprising when the lost precision is to the left of the decimal point.</p>\n<h3>Example</h3>\n<pre><code>let _: f32 = 16_777_217.0; // 16_777_216.0\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _: f32 = 16_777_216.0;\nlet _: f64 = 16_777_217.0;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "macro_metavars_in_unsafe",
    "rule_name": "macro_metavars_in_unsafe",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for macros that expand metavariables in an unsafe block.</p>\n<h3>Why is this bad?</h3>\n<p>This hides an unsafe block and allows the user of the macro to write unsafe code without an explicit\nunsafe block at callsite, making it possible to perform unsafe operations in seemingly safe code.</p>\n<p>The macro should be restructured so that these metavariables are referenced outside of unsafe blocks\nand that the usual unsafety checks apply to the macro argument.</p>\n<p>This is usually done by binding it to a variable outside of the unsafe block\nand then using that variable inside of the block as shown in the example, or by referencing it a second time\nin a safe context, e.g. <code>if false { $expr }</code>.</p>\n<h3>Known limitations</h3>\n<p>Due to how macros are represented in the compiler at the time Clippy runs its lints,\nit\u2019s not possible to look for metavariables in macro definitions directly.</p>\n<p>Instead, this lint looks at expansions of macros.\nThis leads to false negatives for macros that are never actually invoked.</p>\n<p>By default, this lint is rather conservative and will only emit warnings on publicly-exported\nmacros from the same crate, because oftentimes private internal macros are one-off macros where\nthis lint would just be noise (e.g. macros that generate <code>impl</code> blocks).\nThe default behavior should help with preventing a high number of such false positives,\nhowever it can be configured to also emit warnings in private macros if desired.</p>\n<h3>Example</h3>\n<pre><code>/// Gets the first element of a slice\nmacro_rules! first {\n    ($slice:expr) => {\n        unsafe {\n            let slice = $slice; // \u26a0\ufe0f expansion inside of `unsafe {}`\n\n            assert!(!slice.is_empty());\n            // SAFETY: slice is checked to have at least one element\n            slice.first().unwrap_unchecked()\n        }\n    }\n}\n\nassert_eq!(*first!(&[1i32]), 1);\n\n// This will compile as a consequence (note the lack of `unsafe {}`)\nassert_eq!(*first!(std::hint::unreachable_unchecked() as &[i32]), 1);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>macro_rules! first {\n    ($slice:expr) => {{\n        let slice = $slice; // \u2705 outside of `unsafe {}`\n        unsafe {\n            assert!(!slice.is_empty());\n            // SAFETY: slice is checked to have at least one element\n            slice.first().unwrap_unchecked()\n        }\n    }}\n}\n\nassert_eq!(*first!(&[1]), 1);\n\n// This won't compile:\nassert_eq!(*first!(std::hint::unreachable_unchecked() as &[i32]), 1);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>warn-unsafe-macro-metavars-in-private-macros</code>:  Whether to also emit warnings for unsafe blocks with metavariable expansions in <strong>private</strong> macros.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "macro_use_imports",
    "rule_name": "macro_use_imports",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[macro_use] use...</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Since the Rust 2018 edition you can import\nmacro\u2019s directly, this is considered idiomatic.</p>\n<h3>Example</h3>\n<pre><code>#[macro_use]\nuse some_macro;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "main_recursion",
    "rule_name": "main_recursion",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for recursion using the entrypoint.</p>\n<h3>Why is this bad?</h3>\n<p>Apart from special setups (which we could detect following attributes like #![no_std]),\nrecursing into main() seems like an unintuitive anti-pattern we should be able to detect.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    main();\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_assert",
    "rule_name": "manual_assert",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects <code>if</code>-then-<code>panic!</code> that can be replaced with <code>assert!</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>assert!</code> is simpler than <code>if</code>-then-<code>panic!</code>.</p>\n<h3>Example</h3>\n<pre><code>let sad_people: Vec<&str> = vec![];\nif !sad_people.is_empty() {\n    panic!(\"there are sad people: {:?}\", sad_people);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let sad_people: Vec<&str> = vec![];\nassert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_async_fn",
    "rule_name": "manual_async_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It checks for manual implementations of <code>async</code> functions.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more idiomatic to use the dedicated syntax.</p>\n<h3>Example</h3>\n<pre><code>use std::future::Future;\n\nfn foo() -> impl Future<Output = i32> { async { 42 } }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>async fn foo() -> i32 { 42 }\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_bits",
    "rule_name": "manual_bits",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>std::mem::size_of::<T>() * 8</code> when\n<code>T::BITS</code> is available.</p>\n<h3>Why is this bad?</h3>\n<p>Can be written as the shorter <code>T::BITS</code>.</p>\n<h3>Example</h3>\n<pre><code>std::mem::size_of::<usize>() * 8;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>usize::BITS as usize;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_c_str_literals",
    "rule_name": "manual_c_str_literals",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the manual creation of C strings (a string with a <code>NUL</code> byte at the end), either\nthrough one of the <code>CStr</code> constructor functions, or more plainly by calling <code>.as_ptr()</code>\non a (byte) string literal with a hardcoded <code>\\0</code> byte at the end.</p>\n<h3>Why is this bad?</h3>\n<p>This can be written more concisely using <code>c\"str\"</code> literals and is also less error-prone,\nbecause the compiler checks for interior <code>NUL</code> bytes and the terminating <code>NUL</code> byte is inserted automatically.</p>\n<h3>Example</h3>\n<pre><code>fn needs_cstr(_: &CStr) {}\n\nneeds_cstr(CStr::from_bytes_with_nul(b\"Hello\\0\").unwrap());\nunsafe { libc::puts(\"World\\0\".as_ptr().cast()) }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn needs_cstr(_: &CStr) {}\n\nneeds_cstr(c\"Hello\");\nunsafe { libc::puts(c\"World\".as_ptr()) }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_clamp",
    "rule_name": "manual_clamp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Identifies good opportunities for a clamp function from std or core, and suggests using it.</p>\n<h3>Why is this bad?</h3>\n<p>clamp is much shorter, easier to read, and doesn\u2019t use any control flow.</p>\n<h3>Limitations</h3>\n<p>This lint will only trigger if max and min are known at compile time, and max is\ngreater than min.</p>\n<h3>Known issue(s)</h3>\n<p>If the clamped variable is NaN this suggestion will cause the code to propagate NaN\nrather than returning either <code>max</code> or <code>min</code>.</p>\n<p><code>clamp</code> functions will panic if <code>max < min</code>, <code>max.is_nan()</code>, or <code>min.is_nan()</code>.\nSome may consider panicking in these situations to be desirable, but it also may\nintroduce panicking where there wasn\u2019t any before.</p>\n<p>See also <a>the discussion in the\nPR</a>.</p>\n<h3>Examples</h3>\n<pre><code>if input > max {\n    max\n} else if input < min {\n    min\n} else {\n    input\n}\n</code></pre>\n<pre><code>input.max(min).min(max)\n</code></pre>\n<pre><code>match input {\n    x if x > max => max,\n    x if x < min => min,\n    x => x,\n}\n</code></pre>\n<pre><code>let mut x = input;\nif x < min { x = min; }\nif x > max { x = max; }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>input.clamp(min, max)\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_div_ceil",
    "rule_name": "manual_div_ceil",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for an expression like <code>(x + (y - 1)) / y</code> which is a common manual reimplementation\nof <code>x.div_ceil(y)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s simpler, clearer and more readable.</p>\n<h3>Example</h3>\n<pre><code>let x: i32 = 7;\nlet y: i32 = 4;\nlet div = (x + (y - 1)) / y;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![feature(int_roundings)]\nlet x: i32 = 7;\nlet y: i32 = 4;\nlet div = x.div_ceil(y);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_filter",
    "rule_name": "manual_filter",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>match</code> which could be implemented using <code>filter</code></p>\n<h3>Why is this bad?</h3>\n<p>Using the <code>filter</code> method is clearer and more concise.</p>\n<h3>Example</h3>\n<pre><code>match Some(0) {\n    Some(x) => if x % 2 == 0 {\n                    Some(x)\n               } else {\n                    None\n                },\n    None => None,\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>Some(0).filter(|&x| x % 2 == 0);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_filter_map",
    "rule_name": "manual_filter_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.filter(_).map(_)</code> that can be written more simply\nas <code>filter_map(_)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code in the <code>filter</code> and <code>map</code> operations is poor style and\nless performant.</p>\n<h3>Example</h3>\n<pre><code>(0_i32..10)\n    .filter(|n| n.checked_add(1).is_some())\n    .map(|n| n.checked_add(1).unwrap());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>(0_i32..10).filter_map(|n| n.checked_add(1));\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>filter_map</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_find",
    "rule_name": "manual_find",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual implementations of Iterator::find</p>\n<h3>Why is this bad?</h3>\n<p>It doesn\u2019t affect performance, but using <code>find</code> is shorter and easier to read.</p>\n<h3>Example</h3>\n<pre><code>fn example(arr: Vec<i32>) -> Option<i32> {\n    for el in arr {\n        if el == 1 {\n            return Some(el);\n        }\n    }\n    None\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn example(arr: Vec<i32>) -> Option<i32> {\n    arr.into_iter().find(|&el| el == 1)\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_find_map",
    "rule_name": "manual_find_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.find(_).map(_)</code> that can be written more simply\nas <code>find_map(_)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code in the <code>find</code> and <code>map</code> operations is poor style and\nless performant.</p>\n<h3>Example</h3>\n<pre><code>(0_i32..10)\n    .find(|n| n.checked_add(1).is_some())\n    .map(|n| n.checked_add(1).unwrap());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>(0_i32..10).find_map(|n| n.checked_add(1));\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>find_map</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_flatten",
    "rule_name": "manual_flatten",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary <code>if let</code> usage in a for loop\nwhere only the <code>Some</code> or <code>Ok</code> variant of the iterator element is used.</p>\n<h3>Why is this bad?</h3>\n<p>It is verbose and can be simplified\nby first calling the <code>flatten</code> method on the <code>Iterator</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = vec![Some(1), Some(2), Some(3)];\nfor n in x {\n    if let Some(n) = n {\n        println!(\"{}\", n);\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = vec![Some(1), Some(2), Some(3)];\nfor n in x.into_iter().flatten() {\n    println!(\"{}\", n);\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_hash_one",
    "rule_name": "manual_hash_one",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for cases where <a><code>BuildHasher::hash_one</code></a> can be used.</p>\n<h3>Why is this bad?</h3>\n<p>It is more concise to use the <code>hash_one</code> method.</p>\n<h3>Example</h3>\n<pre><code>use std::hash::{BuildHasher, Hash, Hasher};\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet value = vec![1, 2, 3];\n\nlet mut hasher = s.build_hasher();\nvalue.hash(&mut hasher);\nlet hash = hasher.finish();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::hash::BuildHasher;\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet value = vec![1, 2, 3];\n\nlet hash = s.hash_one(&value);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_ignore_case_cmp",
    "rule_name": "manual_ignore_case_cmp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual case-insensitive ASCII comparison.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>eq_ignore_ascii_case</code> method is faster because it does not allocate\nmemory for the new strings, and it is more readable.</p>\n<h3>Example</h3>\n<pre><code>fn compare(a: &str, b: &str) -> bool {\n    a.to_ascii_lowercase() == b.to_ascii_lowercase() || a.to_ascii_lowercase() == \"abc\"\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn compare(a: &str, b: &str) -> bool {\n   a.eq_ignore_ascii_case(b) || a.eq_ignore_ascii_case(\"abc\")\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_inspect",
    "rule_name": "manual_inspect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for uses of <code>map</code> which return the original item.</p>\n<h3>Why is this bad?</h3>\n<p><code>inspect</code> is both clearer in intent and shorter.</p>\n<h3>Example</h3>\n<pre><code>let x = Some(0).map(|x| { println!(\"{x}\"); x });\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = Some(0).inspect(|x| println!(\"{x}\"));\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_instant_elapsed",
    "rule_name": "manual_instant_elapsed",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints subtraction between <code>Instant::now()</code> and another <code>Instant</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is easy to accidentally write <code>prev_instant - Instant::now()</code>, which will always be 0ns\nas <code>Instant</code> subtraction saturates.</p>\n<p><code>prev_instant.elapsed()</code> also more clearly signals intention.</p>\n<h3>Example</h3>\n<pre><code>use std::time::Instant;\nlet prev_instant = Instant::now();\nlet duration = Instant::now() - prev_instant;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::time::Instant;\nlet prev_instant = Instant::now();\nlet duration = prev_instant.elapsed();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_is_ascii_check",
    "rule_name": "manual_is_ascii_check",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests to use dedicated built-in methods,\n<code>is_ascii_(lowercase|uppercase|digit|hexdigit)</code> for checking on corresponding\nascii range</p>\n<h3>Why is this bad?</h3>\n<p>Using the built-in functions is more readable and makes it\nclear that it\u2019s not a specific subset of characters, but all\nASCII (lowercase|uppercase|digit|hexdigit) characters.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    assert!(matches!('x', 'a'..='z'));\n    assert!(matches!(b'X', b'A'..=b'Z'));\n    assert!(matches!('2', '0'..='9'));\n    assert!(matches!('x', 'A'..='Z' | 'a'..='z'));\n    assert!(matches!('C', '0'..='9' | 'a'..='f' | 'A'..='F'));\n\n    ('0'..='9').contains(&'0');\n    ('a'..='z').contains(&'a');\n    ('A'..='Z').contains(&'A');\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    assert!('x'.is_ascii_lowercase());\n    assert!(b'X'.is_ascii_uppercase());\n    assert!('2'.is_ascii_digit());\n    assert!('x'.is_ascii_alphabetic());\n    assert!('C'.is_ascii_hexdigit());\n\n    '0'.is_ascii_digit();\n    'a'.is_ascii_lowercase();\n    'A'.is_ascii_uppercase();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_is_finite",
    "rule_name": "manual_is_finite",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual <code>is_finite</code> reimplementations\n(i.e., <code>x != <float>::INFINITY && x != <float>::NEG_INFINITY</code>).</p>\n<h3>Why is this bad?</h3>\n<p>The method <code>is_finite</code> is shorter and more readable.</p>\n<h3>Example</h3>\n<pre><code>if x != f32::INFINITY && x != f32::NEG_INFINITY {}\nif x.abs() < f32::INFINITY {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x.is_finite() {}\nif x.is_finite() {}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_is_infinite",
    "rule_name": "manual_is_infinite",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual <code>is_infinite</code> reimplementations\n(i.e., <code>x == <float>::INFINITY || x == <float>::NEG_INFINITY</code>).</p>\n<h3>Why is this bad?</h3>\n<p>The method <code>is_infinite</code> is shorter and more readable.</p>\n<h3>Example</h3>\n<pre><code>if x == f32::INFINITY || x == f32::NEG_INFINITY {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x.is_infinite() {}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_is_power_of_two",
    "rule_name": "manual_is_power_of_two",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions like <code>x.count_ones() == 1</code> or <code>x & (x - 1) == 0</code>, with x and unsigned integer, which may be manual\nreimplementations of <code>x.is_power_of_two()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Manual reimplementations of <code>is_power_of_two</code> increase code complexity for little benefit.</p>\n<h3>Example</h3>\n<pre><code>let a: u32 = 4;\nlet result = a.count_ones() == 1;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a: u32 = 4;\nlet result = a.is_power_of_two();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_is_variant_and",
    "rule_name": "manual_is_variant_and",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>option.map(f).unwrap_or_default()</code> and <code>result.map(f).unwrap_or_default()</code> where f is a function or closure that returns the <code>bool</code> type.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. These can be written more concisely as <code>option.is_some_and(f)</code> and <code>result.is_ok_and(f)</code>.</p>\n<h3>Example</h3>\n<pre><code>option.map(|a| a > 10).unwrap_or_default();\nresult.map(|a| a > 10).unwrap_or_default();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>option.is_some_and(|a| a > 10);\nresult.is_ok_and(|a| a > 10);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_let_else",
    "rule_name": "manual_let_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warn of cases where <code>let...else</code> could be used</p>\n<h3>Why is this bad?</h3>\n<p><code>let...else</code> provides a standard construct for this pattern\nthat people can easily recognize. It\u2019s also more compact.</p>\n<h3>Example</h3>\n<pre><code>let v = if let Some(v) = w { v } else { return };\n</code></pre>\n<p>Could be written:</p>\n<pre><code>let Some(v) = w else { return };\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>matches-for-let-else</code>:  Whether the matches should be considered by the lint, and whether there should\nbe filtering for common types.</p>\n<p>(default: <code>\"WellKnownTypes\"</code>)</p>\n</li>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_main_separator_str",
    "rule_name": "manual_main_separator_str",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for references on <code>std::path::MAIN_SEPARATOR.to_string()</code> used\nto build a <code>&str</code>.</p>\n<h3>Why is this bad?</h3>\n<p>There exists a <code>std::path::MAIN_SEPARATOR_STR</code> which does not require\nan extra memory allocation.</p>\n<h3>Example</h3>\n<pre><code>let s: &str = &std::path::MAIN_SEPARATOR.to_string();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s: &str = std::path::MAIN_SEPARATOR_STR;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_map",
    "rule_name": "manual_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>match</code> which could be implemented using <code>map</code></p>\n<h3>Why is this bad?</h3>\n<p>Using the <code>map</code> method is clearer and more concise.</p>\n<h3>Example</h3>\n<pre><code>match Some(0) {\n    Some(x) => Some(x + 1),\n    None => None,\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>Some(0).map(|x| x + 1);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_memcpy",
    "rule_name": "manual_memcpy",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for for-loops that manually copy items between\nslices that could be optimized by having a memcpy.</p>\n<h3>Why is this bad?</h3>\n<p>It is not as fast as a memcpy.</p>\n<h3>Example</h3>\n<pre><code>for i in 0..src.len() {\n    dst[i + 64] = src[i];\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>dst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_next_back",
    "rule_name": "manual_next_back",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.rev().next()</code> on a <code>DoubleEndedIterator</code></p>\n<h3>Why is this bad?</h3>\n<p><code>.next_back()</code> is cleaner.</p>\n<h3>Example</h3>\n<pre><code>foo.iter().rev().next();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>foo.iter().next_back();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_non_exhaustive",
    "rule_name": "manual_non_exhaustive",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual implementations of the non-exhaustive pattern.</p>\n<h3>Why is this bad?</h3>\n<p>Using the #[non_exhaustive] attribute expresses better the intent\nand allows possible optimizations when applied to enums.</p>\n<h3>Example</h3>\n<pre><code>struct S {\n    pub a: i32,\n    pub b: i32,\n    _c: (),\n}\n\nenum E {\n    A,\n    B,\n    #[doc(hidden)]\n    _C,\n}\n\nstruct T(pub i32, pub i32, ());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[non_exhaustive]\nstruct S {\n    pub a: i32,\n    pub b: i32,\n}\n\n#[non_exhaustive]\nenum E {\n    A,\n    B,\n}\n\n#[non_exhaustive]\nstruct T(pub i32, pub i32);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_ok_or",
    "rule_name": "manual_ok_or",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds patterns that reimplement <code>Option::ok_or</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Concise code helps focusing on behavior instead of boilerplate.</p>\n<h3>Examples</h3>\n<pre><code>let foo: Option<i32> = None;\nfoo.map_or(Err(\"error\"), |v| Ok(v));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let foo: Option<i32> = None;\nfoo.ok_or(\"error\");\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_pattern_char_comparison",
    "rule_name": "manual_pattern_char_comparison",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual <code>char</code> comparison in string patterns</p>\n<h3>Why is this bad?</h3>\n<p>This can be written more concisely using a <code>char</code> or an array of <code>char</code>.\nThis is more readable and more optimized when comparing to only one <code>char</code>.</p>\n<h3>Example</h3>\n<pre><code>\"Hello World!\".trim_end_matches(|c| c == '.' || c == ',' || c == '!' || c == '?');\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\"Hello World!\".trim_end_matches(['.', ',', '!', '?']);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_range_contains",
    "rule_name": "manual_range_contains",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions like <code>x >= 3 && x < 8</code> that could\nbe more readably expressed as <code>(3..8).contains(x)</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>contains</code> expresses the intent better and has less\nfailure modes (such as fencepost errors or using <code>||</code> instead of <code>&&</code>).</p>\n<h3>Example</h3>\n<pre><code>// given\nlet x = 6;\n\nassert!(x >= 3 && x < 8);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>assert!((3..8).contains(&x));\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_range_patterns",
    "rule_name": "manual_range_patterns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for combined OR patterns that are all contained in a specific range,\ne.g. <code>6 | 4 | 5 | 9 | 7 | 8</code> can be rewritten as <code>4..=9</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using an explicit range is more concise and easier to read.</p>\n<h3>Known issues</h3>\n<p>This lint intentionally does not handle numbers greater than <code>i128::MAX</code> for <code>u128</code> literals\nin order to support negative numbers.</p>\n<h3>Example</h3>\n<pre><code>let x = 6;\nlet foo = matches!(x, 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = 6;\nlet foo = matches!(x, 1..=10);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_rem_euclid",
    "rule_name": "manual_rem_euclid",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for an expression like <code>((x % 4) + 4) % 4</code> which is a common manual reimplementation\nof <code>x.rem_euclid(4)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s simpler and more readable.</p>\n<h3>Example</h3>\n<pre><code>let x: i32 = 24;\nlet rem = ((x % 4) + 4) % 4;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: i32 = 24;\nlet rem = x.rem_euclid(4);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_retain",
    "rule_name": "manual_retain",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for code to be replaced by <code>.retain()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.retain()</code> is simpler and avoids needless allocation.</p>\n<h3>Example</h3>\n<pre><code>let mut vec = vec![0, 1, 2];\nvec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\nvec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut vec = vec![0, 1, 2];\nvec.retain(|x| x % 2 == 0);\nvec.retain(|x| x % 2 == 0);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_rotate",
    "rule_name": "manual_rotate",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It detects manual bit rotations that could be rewritten using standard\nfunctions <code>rotate_left</code> or <code>rotate_right</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Calling the function better conveys the intent.</p>\n<h3>Known issues</h3>\n<p>Currently, the lint only catches shifts by constant amount.</p>\n<h3>Example</h3>\n<pre><code>let x = 12345678_u32;\nlet _ = (x >> 8) | (x << 24);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = 12345678_u32;\nlet _ = x.rotate_right(8);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_saturating_arithmetic",
    "rule_name": "manual_saturating_arithmetic",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.checked_add/sub(x).unwrap_or(MAX/MIN)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>These can be written simply with <code>saturating_add/sub</code> methods.</p>\n<h3>Example</h3>\n<pre><code>let add = x.checked_add(y).unwrap_or(u32::MAX);\nlet sub = x.checked_sub(y).unwrap_or(u32::MIN);\n</code></pre>\n<p>can be written using dedicated methods for saturating addition/subtraction as:</p>\n<pre><code>let add = x.saturating_add(y);\nlet sub = x.saturating_sub(y);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_slice_size_calculation",
    "rule_name": "manual_slice_size_calculation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>When <code>a</code> is <code>&[T]</code>, detect <code>a.len() * size_of::<T>()</code> and suggest <code>size_of_val(a)</code>\ninstead.</p>\n<h3>Why is this better?</h3>\n<ul>\n<li>Shorter to write</li>\n<li>Removes the need for the human and the compiler to worry about overflow in the\nmultiplication</li>\n<li>Potentially faster at runtime as rust emits special no-wrapping flags when it\ncalculates the byte length</li>\n<li>Less turbofishing</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let newlen = data.len() * std::mem::size_of::<i32>();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let newlen = std::mem::size_of_val(data);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_split_once",
    "rule_name": "manual_split_once",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>str::splitn(2, _)</code></p>\n<h3>Why is this bad?</h3>\n<p><code>split_once</code> is both clearer in intent and slightly more efficient.</p>\n<h3>Example</h3>\n<pre><code>let s = \"key=value=add\";\nlet (key, value) = s.splitn(2, '=').next_tuple()?;\nlet value = s.splitn(2, '=').nth(1)?;\n\nlet mut parts = s.splitn(2, '=');\nlet key = parts.next()?;\nlet value = parts.next()?;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s = \"key=value=add\";\nlet (key, value) = s.split_once('=')?;\nlet value = s.split_once('=')?.1;\n\nlet (key, value) = s.split_once('=')?;\n</code></pre>\n<h3>Limitations</h3>\n<p>The multiple statement variant currently only detects <code>iter.next()?</code>/<code>iter.next().unwrap()</code>\nin two separate <code>let</code> statements that immediately follow the <code>splitn()</code></p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_str_repeat",
    "rule_name": "manual_str_repeat",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual implementations of <code>str::repeat</code></p>\n<h3>Why is this bad?</h3>\n<p>These are both harder to read, as well as less performant.</p>\n<h3>Example</h3>\n<pre><code>let x: String = std::iter::repeat('x').take(10).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: String = \"x\".repeat(10);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_string_new",
    "rule_name": "manual_string_new",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>\"\"</code> to create a <code>String</code>, such as <code>\"\".to_string()</code>, <code>\"\".to_owned()</code>,\n<code>String::from(\"\")</code> and others.</p>\n<h3>Why is this bad?</h3>\n<p>Different ways of creating an empty string makes your code less standardized, which can\nbe confusing.</p>\n<h3>Example</h3>\n<pre><code>let a = \"\".to_string();\nlet b: String = \"\".into();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = String::new();\nlet b = String::new();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "manual_strip",
    "rule_name": "manual_strip",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests using <code>strip_{prefix,suffix}</code> over <code>str::{starts,ends}_with</code> and slicing using\nthe pattern\u2019s length.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>str:strip_{prefix,suffix}</code> is safer and may have better performance as there is no\nslicing which may panic and the compiler does not need to insert this panic code. It is\nalso sometimes more readable as it removes the need for duplicating or storing the pattern\nused by <code>str::{starts,ends}_with</code> and in the slicing.</p>\n<h3>Example</h3>\n<pre><code>let s = \"hello, world!\";\nif s.starts_with(\"hello, \") {\n    assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s = \"hello, world!\";\nif let Some(end) = s.strip_prefix(\"hello, \") {\n    assert_eq!(end.to_uppercase(), \"WORLD!\");\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_swap",
    "rule_name": "manual_swap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual swapping.</p>\n<p>Note that the lint will not be emitted in const blocks, as the suggestion would not be applicable.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>std::mem::swap</code> function exposes the intent better\nwithout deinitializing or copying either variable.</p>\n<h3>Example</h3>\n<pre><code>let mut a = 42;\nlet mut b = 1337;\n\nlet t = b;\nb = a;\na = t;\n</code></pre>\n<p>Use std::mem::swap():</p>\n<pre><code>let mut a = 1;\nlet mut b = 2;\nstd::mem::swap(&mut a, &mut b);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_try_fold",
    "rule_name": "manual_try_fold",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Iterator::fold</code> with a type that implements <code>Try</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The code should use <code>try_fold</code> instead, which short-circuits on failure, thus opening the\ndoor for additional optimizations not possible with <code>fold</code> as rustc can guarantee the\nfunction is never called on <code>None</code>, <code>Err</code>, etc., alleviating otherwise necessary checks. It\u2019s\nalso slightly more idiomatic.</p>\n<h3>Known issues</h3>\n<p>This lint doesn\u2019t take into account whether a function does something on the failure case,\ni.e., whether short-circuiting will affect behavior. Refactoring to <code>try_fold</code> is not\ndesirable in those cases.</p>\n<h3>Example</h3>\n<pre><code>vec![1, 2, 3].iter().fold(Some(0i32), |sum, i| sum?.checked_add(*i));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![1, 2, 3].iter().try_fold(0i32, |sum, i| sum.checked_add(*i));\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_unwrap_or",
    "rule_name": "manual_unwrap_or",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds patterns that reimplement <code>Option::unwrap_or</code> or <code>Result::unwrap_or</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Concise code helps focusing on behavior instead of boilerplate.</p>\n<h3>Example</h3>\n<pre><code>let foo: Option<i32> = None;\nmatch foo {\n    Some(v) => v,\n    None => 1,\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let foo: Option<i32> = None;\nfoo.unwrap_or(1);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_unwrap_or_default",
    "rule_name": "manual_unwrap_or_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if a <code>match</code> or <code>if let</code> expression can be simplified using\n<code>.unwrap_or_default()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It can be done in one call with <code>.unwrap_or_default()</code>.</p>\n<h3>Example</h3>\n<pre><code>let x: Option<String> = Some(String::new());\nlet y: String = match x {\n    Some(v) => v,\n    None => String::new(),\n};\n\nlet x: Option<Vec<String>> = Some(Vec::new());\nlet y: Vec<String> = if let Some(v) = x {\n    v\n} else {\n    Vec::new()\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Option<String> = Some(String::new());\nlet y: String = x.unwrap_or_default();\n\nlet x: Option<Vec<String>> = Some(Vec::new());\nlet y: Vec<String> = x.unwrap_or_default();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "manual_while_let_some",
    "rule_name": "manual_while_let_some",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for loops that check for emptiness of a <code>Vec</code> in the condition and pop an element\nin the body as a separate operation.</p>\n<h3>Why is this bad?</h3>\n<p>Such loops can be written in a more idiomatic way by using a while-let loop and directly\npattern matching on the return value of <code>Vec::pop()</code>.</p>\n<h3>Example</h3>\n<pre><code>let mut numbers = vec![1, 2, 3, 4, 5];\nwhile !numbers.is_empty() {\n    let number = numbers.pop().unwrap();\n    // use `number`\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut numbers = vec![1, 2, 3, 4, 5];\nwhile let Some(number) = numbers.pop() {\n    // use `number`\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "many_single_char_names",
    "rule_name": "many_single_char_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for too many variables whose name consists of a\nsingle character.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s hard to memorize what a variable means without a\ndescriptive name.</p>\n<h3>Example</h3>\n<pre><code>let (a, b, c, d, e, f, g) = (...);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>single-char-binding-names-threshold</code>:  The maximum number of single char bindings a scope may have</p>\n<p>(default: <code>4</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "map_all_any_identity",
    "rule_name": "map_all_any_identity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.map(\u2026)</code>, followed by <code>.all(identity)</code> or <code>.any(identity)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>.all(\u2026)</code> or <code>.any(\u2026)</code> methods can be called directly in place of <code>.map(\u2026)</code>.</p>\n<h3>Example</h3>\n<pre><code>let e1 = v.iter().map(|s| s.is_empty()).all(|a| a);\nlet e2 = v.iter().map(|s| s.is_empty()).any(std::convert::identity);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let e1 = v.iter().all(|s| s.is_empty());\nlet e2 = v.iter().any(|s| s.is_empty());\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_clone",
    "rule_name": "map_clone",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>map(|x| x.clone())</code> or\ndereferencing closures for <code>Copy</code> types, on <code>Iterator</code> or <code>Option</code>,\nand suggests <code>cloned()</code> or <code>copied()</code> instead</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely</p>\n<h3>Example</h3>\n<pre><code>let x = vec![42, 43];\nlet y = x.iter();\nlet z = y.map(|i| *i);\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let x = vec![42, 43];\nlet y = x.iter();\nlet z = y.cloned();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_collect_result_unit",
    "rule_name": "map_collect_result_unit",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.map(_).collect::<Result<(), _>()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>try_for_each</code> instead is more readable and idiomatic.</p>\n<h3>Example</h3>\n<pre><code>(0..3).map(|t| Err(t)).collect::<Result<(), _>>();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>(0..3).try_for_each(|t| Err(t));\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_entry",
    "rule_name": "map_entry",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>contains_key</code> + <code>insert</code> on <code>HashMap</code>\nor <code>BTreeMap</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>entry</code> is more efficient.</p>\n<h3>Known problems</h3>\n<p>The suggestion may have type inference errors in some cases. e.g.</p>\n<pre><code>let mut map = std::collections::HashMap::new();\nlet _ = if !map.contains_key(&0) {\n    map.insert(0, 0)\n} else {\n    None\n};\n</code></pre>\n<h3>Example</h3>\n<pre><code>if !map.contains_key(&k) {\n    map.insert(k, v);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>map.entry(k).or_insert(v);\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_err_ignore",
    "rule_name": "map_err_ignore",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for instances of <code>map_err(|_| Some::Enum)</code></p>\n<h3>Why restrict this?</h3>\n<p>This <code>map_err</code> throws away the original error rather than allowing the enum to\ncontain and report the cause of the error.</p>\n<h3>Example</h3>\n<p>Before:</p>\n<pre><code>use std::fmt;\n\n#[derive(Debug)]\nenum Error {\n    Indivisible,\n    Remainder(u8),\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::Indivisible => write!(f, \"could not divide input by three\"),\n            Error::Remainder(remainder) => write!(\n                f,\n                \"input is not divisible by three, remainder = {}\",\n                remainder\n            ),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\n    input\n        .parse::<i32>()\n        .map_err(|_| Error::Indivisible)\n        .map(|v| v % 3)\n        .and_then(|remainder| {\n            if remainder == 0 {\n                Ok(())\n            } else {\n                Err(Error::Remainder(remainder as u8))\n            }\n        })\n}\n</code></pre>\n<p>After:</p>\n<pre><code>use std::{fmt, num::ParseIntError};\n\n#[derive(Debug)]\nenum Error {\n    Indivisible(ParseIntError),\n    Remainder(u8),\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n            Error::Remainder(remainder) => write!(\n                f,\n                \"input is not divisible by three, remainder = {}\",\n                remainder\n            ),\n        }\n    }\n}\n\nimpl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Error::Indivisible(source) => Some(source),\n            _ => None,\n        }\n    }\n}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\n    input\n        .parse::<i32>()\n        .map_err(Error::Indivisible)\n        .map(|v| v % 3)\n        .and_then(|remainder| {\n            if remainder == 0 {\n                Ok(())\n            } else {\n                Err(Error::Remainder(remainder as u8))\n            }\n        })\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "map_flatten",
    "rule_name": "map_flatten",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.map(_).flatten(_)</code> on <code>Iterator</code> and <code>Option</code></p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.flat_map(_)</code> for <code>Iterator</code> or <code>_.and_then(_)</code> for <code>Option</code></p>\n<h3>Example</h3>\n<pre><code>let vec = vec![vec![1]];\nlet opt = Some(5);\n\nvec.iter().map(|x| x.iter()).flatten();\nopt.map(|x| Some(x * 2)).flatten();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.iter().flat_map(|x| x.iter());\nopt.and_then(|x| Some(x * 2));\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_identity",
    "rule_name": "map_identity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for instances of <code>map(f)</code> where <code>f</code> is the identity function.</p>\n<h3>Why is this bad?</h3>\n<p>It can be written more concisely without the call to <code>map</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| 2*x).collect();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "map_unwrap_or",
    "rule_name": "map_unwrap_or",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>option.map(_).unwrap_or(_)</code> or <code>option.map(_).unwrap_or_else(_)</code> or\n<code>result.map(_).unwrap_or_else(_)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, these can be written more concisely (resp.) as\n<code>option.map_or(_, _)</code>, <code>option.map_or_else(_, _)</code> and <code>result.map_or_else(_, _)</code>.</p>\n<h3>Known problems</h3>\n<p>The order of the arguments is not in execution order</p>\n<h3>Examples</h3>\n<pre><code>option.map(|a| a + 1).unwrap_or(0);\noption.map(|a| a > 10).unwrap_or(false);\nresult.map(|a| a + 1).unwrap_or_else(some_function);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>option.map_or(0, |a| a + 1);\noption.is_some_and(|a| a > 10);\nresult.map_or_else(some_function, |a| a + 1);\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>option_map_unwrap_or</li>\n<li>option_map_unwrap_or_else</li>\n<li>result_map_unwrap_or_else</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "map_with_unused_argument_over_ranges",
    "rule_name": "map_with_unused_argument_over_ranges",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Iterator::map</code> over ranges without using the parameter which\ncould be more clearly expressed using <code>std::iter::repeat(...).take(...)</code>\nor <code>std::iter::repeat_n</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It expresses the intent more clearly to <code>take</code> the correct number of times\nfrom a generating function than to apply a closure to each number in a\nrange only to discard them.</p>\n<h3>Example</h3>\n<pre><code>let random_numbers : Vec<_> = (0..10).map(|_| { 3 + 1 }).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let f : Vec<_> = std::iter::repeat( 3 + 1 ).take(10).collect();\n</code></pre>\n<h3>Known Issues</h3>\n<p>This lint may suggest replacing a <code>Map<Range></code> with a <code>Take<RepeatWith></code>.\nThe former implements some traits that the latter does not, such as\n<code>DoubleEndedIterator</code>.</p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "match_as_ref",
    "rule_name": "match_as_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for match which is used to add a reference to an\n<code>Option</code> value.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>as_ref()</code> or <code>as_mut()</code> instead is shorter.</p>\n<h3>Example</h3>\n<pre><code>let x: Option<()> = None;\n\nlet r: Option<&()> = match x {\n    None => None,\n    Some(ref v) => Some(v),\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Option<()> = None;\n\nlet r: Option<&()> = x.as_ref();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_bool",
    "rule_name": "match_bool",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for matches where match expression is a <code>bool</code>. It\nsuggests to replace the expression with an <code>if...else</code> block.</p>\n<h3>Why is this bad?</h3>\n<p>It makes the code less readable.</p>\n<h3>Example</h3>\n<pre><code>let condition: bool = true;\nmatch condition {\n    true => foo(),\n    false => bar(),\n}\n</code></pre>\n<p>Use if/else instead:</p>\n<pre><code>let condition: bool = true;\nif condition {\n    foo();\n} else {\n    bar();\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "match_like_matches_macro",
    "rule_name": "match_like_matches_macro",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>match</code>  or <code>if let</code> expressions producing a\n<code>bool</code> that could be written using <code>matches!</code></p>\n<h3>Why is this bad?</h3>\n<p>Readability and needless complexity.</p>\n<h3>Known problems</h3>\n<p>This lint falsely triggers, if there are arms with\n<code>cfg</code> attributes that remove an arm evaluating to <code>false</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = Some(5);\n\nlet a = match x {\n    Some(0) => true,\n    _ => false,\n};\n\nlet a = if let Some(0) = x {\n    true\n} else {\n    false\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = Some(5);\nlet a = matches!(x, Some(0));\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_on_vec_items",
    "rule_name": "match_on_vec_items",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>match vec[idx]</code> or <code>match vec[n..m]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This can panic at runtime.</p>\n<h3>Example</h3>\n<pre><code>let arr = vec![0, 1, 2, 3];\nlet idx = 1;\n\nmatch arr[idx] {\n    0 => println!(\"{}\", 0),\n    1 => println!(\"{}\", 3),\n    _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let arr = vec![0, 1, 2, 3];\nlet idx = 1;\n\nmatch arr.get(idx) {\n    Some(0) => println!(\"{}\", 0),\n    Some(1) => println!(\"{}\", 3),\n    _ => {},\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "match_overlapping_arm",
    "rule_name": "match_overlapping_arm",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for overlapping match arms.</p>\n<h3>Why is this bad?</h3>\n<p>It is likely to be an error and if not, makes the code\nless obvious.</p>\n<h3>Example</h3>\n<pre><code>let x = 5;\nmatch x {\n    1..=10 => println!(\"1 ... 10\"),\n    5..=15 => println!(\"5 ... 15\"),\n    _ => (),\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_ref_pats",
    "rule_name": "match_ref_pats",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for matches where all arms match a reference,\nsuggesting to remove the reference and deref the matched expression\ninstead. It also checks for <code>if let &foo = bar</code> blocks.</p>\n<h3>Why is this bad?</h3>\n<p>It just makes the code less readable. That reference\ndestructuring adds nothing to the code.</p>\n<h3>Example</h3>\n<pre><code>match x {\n    &A(ref y) => foo(y),\n    &B => bar(),\n    _ => frob(&x),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match *x {\n    A(ref y) => foo(y),\n    B => bar(),\n    _ => frob(x),\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_result_ok",
    "rule_name": "match_result_ok",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary <code>ok()</code> in <code>while let</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Calling <code>ok()</code> in <code>while let</code> is unnecessary, instead match\non <code>Ok(pat)</code></p>\n<h3>Example</h3>\n<pre><code>while let Some(value) = iter.next().ok() {\n    vec.push(value)\n}\n\nif let Some(value) = iter.next().ok() {\n    vec.push(value)\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>while let Ok(value) = iter.next() {\n    vec.push(value)\n}\n\nif let Ok(value) = iter.next() {\n       vec.push(value)\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>if_let_some_result</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_same_arms",
    "rule_name": "match_same_arms",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>match</code> with identical arm bodies.</p>\n<p>Note: Does not lint on wildcards if the <code>non_exhaustive_omitted_patterns_lint</code> feature is\nenabled and disallowed.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a copy & paste error. If arm bodies\nare the same on purpose, you can factor them\n<a>using <code>|</code></a>.</p>\n<h3>Known problems</h3>\n<p>False positive possible with order dependent <code>match</code>\n(see issue\n<a>#860</a>).</p>\n<h3>Example</h3>\n<pre><code>match foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => bar(), // <= oops\n}\n</code></pre>\n<p>This should probably be</p>\n<pre><code>match foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => baz(), // <= fixed\n}\n</code></pre>\n<p>or if the original code was not a typo:</p>\n<pre><code>match foo {\n    Bar | Baz => bar(), // <= shows the intent better\n    Quz => quz(),\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "match_single_binding",
    "rule_name": "match_single_binding",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for useless match that binds to only one value.</p>\n<h3>Why is this bad?</h3>\n<p>Readability and needless complexity.</p>\n<h3>Known problems</h3>\n<p>Suggested replacements may be incorrect when <code>match</code>\nis actually binding temporary value, bringing a \u2018dropped while borrowed\u2019 error.</p>\n<h3>Example</h3>\n<pre><code>match (a, b) {\n    (c, d) => {\n        // useless match\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let (c, d) = (a, b);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "match_str_case_mismatch",
    "rule_name": "match_str_case_mismatch",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>match</code> expressions modifying the case of a string with non-compliant arms</p>\n<h3>Why is this bad?</h3>\n<p>The arm is unreachable, which is likely a mistake</p>\n<h3>Example</h3>\n<pre><code>match &*text.to_ascii_lowercase() {\n    \"foo\" => {},\n    \"Bar\" => {},\n    _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match &*text.to_ascii_lowercase() {\n    \"foo\" => {},\n    \"bar\" => {},\n    _ => {},\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "match_wild_err_arm",
    "rule_name": "match_wild_err_arm",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for arm which matches all errors with <code>Err(_)</code>\nand take drastic actions like <code>panic!</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is generally a bad practice, similar to\ncatching all exceptions in java with <code>catch(Exception)</code></p>\n<h3>Example</h3>\n<pre><code>let x: Result<i32, &str> = Ok(3);\nmatch x {\n    Ok(_) => println!(\"ok\"),\n    Err(_) => panic!(\"err\"),\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "match_wildcard_for_single_variants",
    "rule_name": "match_wildcard_for_single_variants",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for wildcard enum matches for a single variant.</p>\n<h3>Why is this bad?</h3>\n<p>New enum variants added by library updates can be missed.</p>\n<h3>Known problems</h3>\n<p>Suggested replacements may not use correct path to enum\nif it\u2019s not present in the current scope.</p>\n<h3>Example</h3>\n<pre><code>match x {\n    Foo::A => {},\n    Foo::B => {},\n    _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match x {\n    Foo::A => {},\n    Foo::B => {},\n    Foo::C => {},\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "maybe_infinite_iter",
    "rule_name": "maybe_infinite_iter",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iteration that may be infinite.</p>\n<h3>Why is this bad?</h3>\n<p>While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.</p>\n<h3>Known problems</h3>\n<p>The code may have a condition to stop iteration, but\nthis lint is not clever enough to analyze it.</p>\n<h3>Example</h3>\n<pre><code>let infinite_iter = 0..;\n[0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "mem_forget",
    "rule_name": "mem_forget",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>std::mem::forget(t)</code> where <code>t</code> is\n<code>Drop</code> or has a field that implements <code>Drop</code>.</p>\n<h3>Why restrict this?</h3>\n<p><code>std::mem::forget(t)</code> prevents <code>t</code> from running its destructor, possibly causing leaks.\nIt is not possible to detect all means of creating leaks, but it may be desirable to\nprohibit the simple ones.</p>\n<h3>Example</h3>\n<pre><code>mem::forget(Rc::new(55))\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "mem_replace_option_with_none",
    "rule_name": "mem_replace_option_with_none",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>mem::replace()</code> on an <code>Option</code> with\n<code>None</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>Option</code> already has the method <code>take()</code> for\ntaking its current value (Some(..) or None) and replacing it with\n<code>None</code>.</p>\n<h3>Example</h3>\n<pre><code>use std::mem;\n\nlet mut an_option = Some(0);\nlet replaced = mem::replace(&mut an_option, None);\n</code></pre>\n<p>Is better expressed with:</p>\n<pre><code>let mut an_option = Some(0);\nlet taken = an_option.take();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mem_replace_with_default",
    "rule_name": "mem_replace_with_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>std::mem::replace</code> on a value of type\n<code>T</code> with <code>T::default()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>std::mem</code> module already has the method <code>take</code> to\ntake the current value and replace it with the default value of that type.</p>\n<h3>Example</h3>\n<pre><code>let mut text = String::from(\"foo\");\nlet replaced = std::mem::replace(&mut text, String::default());\n</code></pre>\n<p>Is better expressed with:</p>\n<pre><code>let mut text = String::from(\"foo\");\nlet taken = std::mem::take(&mut text);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mem_replace_with_uninit",
    "rule_name": "mem_replace_with_uninit",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>mem::replace(&mut _, mem::uninitialized())</code>\nand <code>mem::replace(&mut _, mem::zeroed())</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This will lead to undefined behavior even if the\nvalue is overwritten later, because the uninitialized value may be\nobserved in the case of a panic.</p>\n<h3>Example</h3>\n<pre><code>use std::mem;\n\n#[allow(deprecated, invalid_value)]\nfn myfunc (v: &mut Vec<i32>) {\n    let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\n    let new_v = may_panic(taken_v); // undefined behavior on panic\n    mem::forget(mem::replace(v, new_v));\n}\n</code></pre>\n<p>The <a>take_mut</a> crate offers a sound solution,\nat the cost of either lazily creating a replacement value or aborting\non panic, to ensure that the uninitialized value cannot be observed.</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "min_ident_chars",
    "rule_name": "min_ident_chars",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for identifiers which consist of a single character (or fewer than the configured threshold).</p>\n<p>Note: This lint can be very noisy when enabled; it may be desirable to only enable it\ntemporarily.</p>\n<h3>Why restrict this?</h3>\n<p>To improve readability by requiring that every variable has a name more specific than a single letter can be.</p>\n<h3>Example</h3>\n<pre><code>for m in movies {\n    let title = m.t;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for movie in movies {\n    let title = movie.title;\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allowed-idents-below-min-chars</code>:  Allowed names below the minimum allowed characters. The value <code>\"..\"</code> can be used as part of\nthe list to indicate, that the configured values should be appended to the default\nconfiguration of Clippy. By default, any configuration will replace the default value.</p>\n<p>(default: <code>[\"i\", \"j\", \"x\", \"y\", \"z\", \"w\", \"n\"]</code>)</p>\n</li>\n<li>\n<p><code>min-ident-chars-threshold</code>:  Minimum chars an ident can have, anything below or equal to this will be linted.</p>\n<p>(default: <code>1</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "min_max",
    "rule_name": "min_max",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions where <code>std::cmp::min</code> and <code>max</code> are\nused to clamp values, but switched so that the result is constant.</p>\n<h3>Why is this bad?</h3>\n<p>This is in all probability not the intended outcome. At\nthe least it hurts readability of the code.</p>\n<h3>Example</h3>\n<pre><code>min(0, max(100, x))\n\n// or\n\nx.max(100).min(0)\n</code></pre>\n<p>It will always be equal to <code>0</code>. Probably the author meant to clamp the value\nbetween 0 and 100, but has erroneously swapped <code>min</code> and <code>max</code>.</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "misaligned_transmute",
    "rule_name": "misaligned_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p>Split into <code>clippy::cast_ptr_alignment</code> and <code>clippy::transmute_ptr_to_ptr</code>.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "mismatching_type_param_order",
    "rule_name": "mismatching_type_param_order",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for type parameters which are positioned inconsistently between\na type definition and impl block. Specifically, a parameter in an impl\nblock which has the same name as a parameter in the type def, but is in\na different place.</p>\n<h3>Why is this bad?</h3>\n<p>Type parameters are determined by their position rather than name.\nNaming type parameters inconsistently may cause you to refer to the\nwrong type parameter.</p>\n<h3>Limitations</h3>\n<p>This lint only applies to impl blocks with simple generic params, e.g.\n<code>A</code>. If there is anything more complicated, such as a tuple, it will be\nignored.</p>\n<h3>Example</h3>\n<pre><code>struct Foo<A, B> {\n    x: A,\n    y: B,\n}\n// inside the impl, B refers to Foo::A\nimpl<B, A> Foo<B, A> {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Foo<A, B> {\n    x: A,\n    y: B,\n}\nimpl<A, B> Foo<A, B> {}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "misnamed_getters",
    "rule_name": "misnamed_getters",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for getter methods that return a field that doesn\u2019t correspond\nto the name of the method, when there is a field\u2019s whose name matches that of the method.</p>\n<h3>Why is this bad?</h3>\n<p>It is most likely that such a  method is a bug caused by a typo or by copy-pasting.</p>\n<h3>Example</h3>\n<pre><code>struct A {\n    a: String,\n    b: String,\n}\n\nimpl A {\n    fn a(&self) -> &str{\n        &self.b\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct A {\n    a: String,\n    b: String,\n}\n\nimpl A {\n    fn a(&self) -> &str{\n        &self.a\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "misrefactored_assign_op",
    "rule_name": "misrefactored_assign_op",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>a op= a op b</code> or <code>a op= b op a</code> patterns.</p>\n<h3>Why is this bad?</h3>\n<p>Most likely these are bugs where one meant to write <code>a op= b</code>.</p>\n<h3>Known problems</h3>\n<p>Clippy cannot know for sure if <code>a op= a op b</code> should have\nbeen <code>a = a op a op b</code> or <code>a = a op b</code>/<code>a op= b</code>. Therefore, it suggests both.\nIf <code>a op= a op b</code> is really the correct behavior it should be\nwritten as <code>a = a op a op b</code> as it\u2019s less confusing.</p>\n<h3>Example</h3>\n<pre><code>let mut a = 5;\nlet b = 2;\n// ...\na += a + b;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "missing_assert_message",
    "rule_name": "missing_assert_message",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks assertions without a custom panic message.</p>\n<h3>Why restrict this?</h3>\n<p>Without a good custom message, it\u2019d be hard to understand what went wrong when the assertion fails.\nA good custom message should be more about why the failure of the assertion is problematic\nand not what is failed because the assertion already conveys that.</p>\n<p>Although the same reasoning applies to testing functions, this lint ignores them as they would be too noisy.\nAlso, in most cases understanding the test failure would be easier\ncompared to understanding a complex invariant distributed around the codebase.</p>\n<h3>Known problems</h3>\n<p>This lint cannot check the quality of the custom panic messages.\nHence, you can suppress this lint simply by adding placeholder messages\nlike \u201cassertion failed\u201d. However, we recommend coming up with good messages\nthat provide useful information instead of placeholder messages that\ndon\u2019t provide any extra information.</p>\n<h3>Example</h3>\n<pre><code>fn call(service: Service) {\n    assert!(service.ready);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn call(service: Service) {\n    assert!(service.ready, \"`service.poll_ready()` must be called first to ensure that service is ready to receive requests\");\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_asserts_for_indexing",
    "rule_name": "missing_asserts_for_indexing",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for repeated slice indexing without asserting beforehand that the length\nis greater than the largest index used to index into the slice.</p>\n<h3>Why restrict this?</h3>\n<p>In the general case where the compiler does not have a lot of information\nabout the length of a slice, indexing it repeatedly will generate a bounds check\nfor every single index.</p>\n<p>Asserting that the length of the slice is at least as large as the largest value\nto index beforehand gives the compiler enough information to elide the bounds checks,\neffectively reducing the number of bounds checks from however many times\nthe slice was indexed to just one (the assert).</p>\n<h3>Drawbacks</h3>\n<p>False positives. It is, in general, very difficult to predict how well\nthe optimizer will be able to elide bounds checks and it very much depends on\nthe surrounding code. For example, indexing into the slice yielded by the\n<a><code>slice::chunks_exact</code></a>\niterator will likely have all of the bounds checks elided even without an assert\nif the <code>chunk_size</code> is a constant.</p>\n<p>Asserts are not tracked across function calls. Asserting the length of a slice\nin a different function likely gives the optimizer enough information\nabout the length of a slice, but this lint will not detect that.</p>\n<h3>Example</h3>\n<pre><code>fn sum(v: &[u8]) -> u8 {\n    // 4 bounds checks\n    v[0] + v[1] + v[2] + v[3]\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn sum(v: &[u8]) -> u8 {\n    assert!(v.len() > 3);\n    // no bounds checks\n    v[0] + v[1] + v[2] + v[3]\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_const_for_fn",
    "rule_name": "missing_const_for_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests the use of <code>const</code> in functions and methods where possible.</p>\n<h3>Why is this bad?</h3>\n<p>Not having the function const prevents callers of the function from being const as well.</p>\n<h3>Known problems</h3>\n<p>Const functions are currently still being worked on, with some features only being available\non nightly. This lint does not consider all edge cases currently and the suggestions may be\nincorrect if you are using this lint on stable.</p>\n<p>Also, the lint only runs one pass over the code. Consider these two non-const functions:</p>\n<pre><code>fn a() -> i32 {\n    0\n}\nfn b() -> i32 {\n    a()\n}\n</code></pre>\n<p>When running Clippy, the lint will only suggest to make <code>a</code> const, because <code>b</code> at this time\ncan\u2019t be const as it calls a non-const function. Making <code>a</code> const and running Clippy again,\nwill suggest to make <code>b</code> const, too.</p>\n<p>If you are marking a public function with <code>const</code>, removing it again will break API compatibility.</p>\n<h3>Example</h3>\n<pre><code>fn new() -> Self {\n    Self { random_number: 42 }\n}\n</code></pre>\n<p>Could be a const fn:</p>\n<pre><code>const fn new() -> Self {\n    Self { random_number: 42 }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_const_for_thread_local",
    "rule_name": "missing_const_for_thread_local",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests to use <code>const</code> in <code>thread_local!</code> macro if possible.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>thread_local!</code> macro wraps static declarations and makes them thread-local.\nIt supports using a <code>const</code> keyword that may be used for declarations that can\nbe evaluated as a constant expression. This can enable a more efficient thread\nlocal implementation that can avoid lazy initialization. For types that do not\nneed to be dropped, this can enable an even more efficient implementation that\ndoes not need to track any additional state.</p>\n<p>https://doc.rust-lang.org/std/macro.thread_local.html</p>\n<h3>Example</h3>\n<pre><code>thread_local! {\n    static BUF: String = String::new();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>thread_local! {\n    static BUF: String = const { String::new() };\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>thread_local_initializer_can_be_made_const</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "missing_docs_in_private_items",
    "rule_name": "missing_docs_in_private_items",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if there is missing documentation for any private documentable item.</p>\n<h3>Why restrict this?</h3>\n<p>Doc is good. <em>rustc</em> has a <code>MISSING_DOCS</code>\nallowed-by-default lint for\npublic members, but has no way to enforce documentation of private items.\nThis lint fixes that.</p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>missing-docs-in-crate-items</code>:  Whether to <strong>only</strong> check for missing documentation in items visible within the current\ncrate. For example, <code>pub(crate)</code> items.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_enforced_import_renames",
    "rule_name": "missing_enforced_import_renames",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for imports that do not rename the item as specified\nin the <code>enforced-import-renames</code> config option.</p>\n<p>Note: Even though this lint is warn-by-default, it will only trigger if\nimport renames are defined in the <code>clippy.toml</code> file.</p>\n<h3>Why is this bad?</h3>\n<p>Consistency is important; if a project has defined import renames, then they should be\nfollowed. More practically, some item names are too vague outside of their defining scope,\nin which case this can enforce a more meaningful naming.</p>\n<h3>Example</h3>\n<p>An example clippy.toml configuration:</p>\n<pre><code>enforced-import-renames = [\n    { path = \"serde_json::Value\", rename = \"JsonValue\" },\n]\n</code></pre>\n<pre><code>use serde_json::Value;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use serde_json::Value as JsonValue;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>enforced-import-renames</code>:  The list of imports to always rename, a fully qualified path followed by the rename.</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "missing_errors_doc",
    "rule_name": "missing_errors_doc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks the doc comments of publicly visible functions that\nreturn a <code>Result</code> type and warns if there is no <code># Errors</code> section.</p>\n<h3>Why is this bad?</h3>\n<p>Documenting the type of errors that can be returned from a\nfunction can help callers write code to handle the errors appropriately.</p>\n<h3>Examples</h3>\n<p>Since the following function returns a <code>Result</code> it has an <code># Errors</code> section in\nits doc comment:</p>\n<pre><code>/// # Errors\n///\n/// Will return `Err` if `filename` does not exist or the user does not have\n/// permission to read it.\npub fn read(filename: String) -> io::Result<String> {\n    unimplemented!();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_fields_in_debug",
    "rule_name": "missing_fields_in_debug",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual <a><code>core::fmt::Debug</code></a> implementations that do not use all fields.</p>\n<h3>Why is this bad?</h3>\n<p>A common mistake is to forget to update manual <code>Debug</code> implementations when adding a new field\nto a struct or a new variant to an enum.</p>\n<p>At the same time, it also acts as a style lint to suggest using <a><code>core::fmt::DebugStruct::finish_non_exhaustive</code></a>\nfor the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details).</p>\n<h3>Known problems</h3>\n<p>This lint works based on the <code>DebugStruct</code> helper types provided by the <code>Formatter</code>,\nso this won\u2019t detect <code>Debug</code> impls that use the <code>write!</code> macro.\nOftentimes there is more logic to a <code>Debug</code> impl if it uses <code>write!</code> macro, so it tries\nto be on the conservative side and not lint in those cases in an attempt to prevent false positives.</p>\n<p>This lint also does not look through function calls, so calling a function does not consider fields\nused inside of that function as used by the <code>Debug</code> impl.</p>\n<p>Lastly, it also ignores tuple structs as their <code>DebugTuple</code> formatter does not have a <code>finish_non_exhaustive</code>\nmethod, as well as enums because their exhaustiveness is already checked by the compiler when matching on the enum,\nmaking it much less likely to accidentally forget to update the <code>Debug</code> impl when adding a new variant.</p>\n<h3>Example</h3>\n<pre><code>use std::fmt;\nstruct Foo {\n    data: String,\n    // implementation detail\n    hidden_data: i32\n}\nimpl fmt::Debug for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        formatter\n            .debug_struct(\"Foo\")\n            .field(\"data\", &self.data)\n            .finish()\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt;\nstruct Foo {\n    data: String,\n    // implementation detail\n    hidden_data: i32\n}\nimpl fmt::Debug for Foo {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        formatter\n            .debug_struct(\"Foo\")\n            .field(\"data\", &self.data)\n            .finish_non_exhaustive()\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_inline_in_public_items",
    "rule_name": "missing_inline_in_public_items",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It lints if an exported function, method, trait method with default impl,\nor trait method impl is not <code>#[inline]</code>.</p>\n<h3>Why restrict this?</h3>\n<p>When a function is not marked <code>#[inline]</code>, it is not\n<a>a \u201csmall\u201d candidate for automatic inlining</a>, and LTO is not in use, then it is not\npossible for the function to be inlined into the code of any crate other than the one in\nwhich it is defined.  Depending on the role of the function and the relationship of the crates,\nthis could significantly reduce performance.</p>\n<p>Certain types of crates might intend for most of the methods in their public API to be able\nto be inlined across crates even when LTO is disabled.\nThis lint allows those crates to require all exported methods to be <code>#[inline]</code> by default, and\nthen opt out for specific methods where this might not make sense.</p>\n<h3>Example</h3>\n<pre><code>pub fn foo() {} // missing #[inline]\nfn ok() {} // ok\n#[inline] pub fn bar() {} // ok\n#[inline(always)] pub fn baz() {} // ok\n\npub trait Bar {\n  fn bar(); // ok\n  fn def_bar() {} // missing #[inline]\n}\n\nstruct Baz;\nimpl Baz {\n   fn private() {} // ok\n}\n\nimpl Bar for Baz {\n  fn bar() {} // ok - Baz is not exported\n}\n\npub struct PubBaz;\nimpl PubBaz {\n   fn private() {} // ok\n   pub fn not_private() {} // missing #[inline]\n}\n\nimpl Bar for PubBaz {\n   fn bar() {} // missing #[inline]\n   fn def_bar() {} // missing #[inline]\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_panics_doc",
    "rule_name": "missing_panics_doc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks the doc comments of publicly visible functions that\nmay panic and warns if there is no <code># Panics</code> section.</p>\n<h3>Why is this bad?</h3>\n<p>Documenting the scenarios in which panicking occurs\ncan help callers who do not want to panic to avoid those situations.</p>\n<h3>Examples</h3>\n<p>Since the following function may panic it has a <code># Panics</code> section in\nits doc comment:</p>\n<pre><code>/// # Panics\n///\n/// Will panic if y is 0\npub fn divide_by(x: i32, y: i32) -> i32 {\n    if y == 0 {\n        panic!(\"Cannot divide by 0\")\n    } else {\n        x / y\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_safety_doc",
    "rule_name": "missing_safety_doc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the doc comments of publicly visible\nunsafe functions and warns if there is no <code># Safety</code> section.</p>\n<h3>Why is this bad?</h3>\n<p>Unsafe functions should document their safety\npreconditions, so that users can be sure they are using them safely.</p>\n<h3>Examples</h3>\n<pre><code>/// This function should really be documented\npub unsafe fn start_apocalypse(u: &mut Universe) {\n    unimplemented!();\n}\n</code></pre>\n<p>At least write a line about safety:</p>\n<pre><code>/// # Safety\n///\n/// This function should not be called before the horsemen are ready.\npub unsafe fn start_apocalypse(u: &mut Universe) {\n    unimplemented!();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "missing_spin_loop",
    "rule_name": "missing_spin_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty spin loops</p>\n<h3>Why is this bad?</h3>\n<p>The loop body should have something like <code>thread::park()</code> or at least\n<code>std::hint::spin_loop()</code> to avoid needlessly burning cycles and conserve\nenergy. Perhaps even better use an actual lock, if possible.</p>\n<h3>Known problems</h3>\n<p>This lint doesn\u2019t currently trigger on <code>while let</code> or\n<code>loop { match .. { .. } }</code> loops, which would be considered idiomatic in\ncombination with e.g. <code>AtomicBool::compare_exchange_weak</code>.</p>\n<h3>Example</h3>\n<pre><code>use core::sync::atomic::{AtomicBool, Ordering};\nlet b = AtomicBool::new(true);\n// give a ref to `b` to another thread,wait for it to become false\nwhile b.load(Ordering::Acquire) {};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>while b.load(Ordering::Acquire) {\n    std::hint::spin_loop()\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "missing_trait_methods",
    "rule_name": "missing_trait_methods",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if a provided method is used implicitly by a trait\nimplementation.</p>\n<h3>Why restrict this?</h3>\n<p>To ensure that a certain implementation implements every method; for example,\na wrapper type where every method should delegate to the corresponding method of\nthe inner type\u2019s implementation.</p>\n<p>This lint should typically be enabled on a specific trait <code>impl</code> item\nrather than globally.</p>\n<h3>Example</h3>\n<pre><code>trait Trait {\n    fn required();\n\n    fn provided() {}\n}\n\n#[warn(clippy::missing_trait_methods)]\nimpl Trait for Type {\n    fn required() { /* ... */ }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>trait Trait {\n    fn required();\n\n    fn provided() {}\n}\n\n#[warn(clippy::missing_trait_methods)]\nimpl Trait for Type {\n    fn required() { /* ... */ }\n\n    fn provided() { /* ... */ }\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "missing_transmute_annotations",
    "rule_name": "missing_transmute_annotations",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if transmute calls have all generics specified.</p>\n<h3>Why is this bad?</h3>\n<p>If not, one or more unexpected types could be used during <code>transmute()</code>, potentially leading\nto Undefined Behavior or other problems.</p>\n<p>This is particularly dangerous in case a seemingly innocent/unrelated change causes type\ninference to result in a different type. For example, if <code>transmute()</code> is the tail\nexpression of an <code>if</code>-branch, and the <code>else</code>-branch type changes, the compiler may silently\ninfer a different type to be returned by <code>transmute()</code>. That is because the compiler is\nfree to change the inference of a type as long as that inference is technically correct,\nregardless of the programmer\u2019s unknown expectation.</p>\n<p>Both type-parameters, the input- and the output-type, to any <code>transmute()</code> should\nbe given explicitly: Setting the input-type explicitly avoids confusion about what the\nargument\u2019s type actually is. Setting the output-type explicitly avoids type-inference\nto infer a technically correct yet unexpected type.</p>\n<h3>Example</h3>\n<pre><code>// Avoid \"naked\" calls to `transmute()`!\nlet x: i32 = std::mem::transmute([1u16, 2u16]);\n\n// `first_answers` is intended to transmute a slice of bool to a slice of u8.\n// But the programmer forgot to index the first element of the outer slice,\n// so we are actually transmuting from \"pointers to slices\" instead of\n// transmuting from \"a slice of bool\", causing a nonsensical result.\nlet the_answers: &[&[bool]] = &[&[true, false, true]];\nlet first_answers: &[u8] = std::mem::transmute(the_answers);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = std::mem::transmute::<[u16; 2], i32>([1u16, 2u16]);\n\n// The explicit type parameters on `transmute()` makes the intention clear,\n// and cause a type-error if the actual types don't match our expectation.\nlet the_answers: &[&[bool]] = &[&[true, false, true]];\nlet first_answers: &[u8] = std::mem::transmute::<&[bool], &[u8]>(the_answers[0]);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "mistyped_literal_suffixes",
    "rule_name": "mistyped_literal_suffixes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns for mistyped suffix in literals</p>\n<h3>Why is this bad?</h3>\n<p>This is most probably a typo</p>\n<h3>Known problems</h3>\n<ul>\n<li>Does not match on integers too large to fit in the corresponding unsigned type</li>\n<li>Does not match on <code>_127</code> since that is a valid grouping for decimal and octal numbers</li>\n</ul>\n<h3>Example</h3>\n<pre><code>`2_32` => `2_i32`\n`250_8 => `250_u8`\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "mixed_attributes_style",
    "rule_name": "mixed_attributes_style",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items that have the same kind of attributes with mixed styles (inner/outer).</p>\n<h3>Why is this bad?</h3>\n<p>Having both style of said attributes makes it more complicated to read code.</p>\n<h3>Known problems</h3>\n<p>This lint currently has false-negatives when mixing same attributes\nbut they have different path symbols, for example:</p>\n<pre><code>#[custom_attribute]\npub fn foo() {\n    #![my_crate::custom_attribute]\n}\n</code></pre>\n<h3>Example</h3>\n<pre><code>#[cfg(linux)]\npub fn foo() {\n    #![cfg(windows)]\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[cfg(linux)]\n#[cfg(windows)]\npub fn foo() {\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mixed_case_hex_literals",
    "rule_name": "mixed_case_hex_literals",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns on hexadecimal literals with mixed-case letter\ndigits.</p>\n<h3>Why is this bad?</h3>\n<p>It looks confusing.</p>\n<h3>Example</h3>\n<pre><code>0x1a9BAcD\n</code></pre>\n<p>Use instead:</p>\n<pre><code>0x1A9BACD\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mixed_read_write_in_expression",
    "rule_name": "mixed_read_write_in_expression",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a read and a write to the same variable where\nwhether the read occurs before or after the write depends on the evaluation\norder of sub-expressions.</p>\n<h3>Why restrict this?</h3>\n<p>While [the evaluation order of sub-expressions] is fully specified in Rust,\nit still may be confusing to read an expression where the evaluation order\naffects its behavior.</p>\n<h3>Known problems</h3>\n<p>Code which intentionally depends on the evaluation\norder, or which is correct for any evaluation order.</p>\n<h3>Example</h3>\n<pre><code>let mut x = 0;\n\nlet a = {\n    x = 1;\n    1\n} + x;\n// Unclear whether a is 1 or 2.\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let tmp = {\n    x = 1;\n    1\n};\nlet a = tmp + x;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>eval_order_dependence</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "mod_module_files",
    "rule_name": "mod_module_files",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks that module layout uses only self named module files; bans <code>mod.rs</code> files.</p>\n<h3>Why restrict this?</h3>\n<p>Having multiple module layout styles in a project can be confusing.</p>\n<h3>Example</h3>\n<pre><code>src/\n  stuff/\n    stuff_files.rs\n    mod.rs\n  lib.rs\n</code></pre>\n<p>Use instead:</p>\n<pre><code>src/\n  stuff/\n    stuff_files.rs\n  stuff.rs\n  lib.rs\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "module_inception",
    "rule_name": "module_inception",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for modules that have the same name as their\nparent module</p>\n<h3>Why is this bad?</h3>\n<p>A typical beginner mistake is to have <code>mod foo;</code> and\nagain <code>mod foo { .. }</code> in <code>foo.rs</code>.\nThe expectation is that items inside the inner <code>mod foo { .. }</code> are then\navailable\nthrough <code>foo::x</code>, but they are only available through\n<code>foo::foo::x</code>.\nIf this is done on purpose, it would be better to choose a more\nrepresentative module name.</p>\n<h3>Example</h3>\n<pre><code>// lib.rs\nmod foo;\n// foo.rs\nmod foo {\n    ...\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-private-module-inception</code>:  Whether to allow module inception if it\u2019s not public.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "module_name_repetitions",
    "rule_name": "module_name_repetitions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects public item names that are prefixed or suffixed by the\ncontaining public module\u2019s name.</p>\n<h3>Why is this bad?</h3>\n<p>It requires the user to type the module name twice in each usage,\nespecially if they choose to import the module rather than its contents.</p>\n<p>Lack of such repetition is also the style used in the Rust standard library;\ne.g. <code>io::Error</code> and <code>fmt::Error</code> rather than <code>io::IoError</code> and <code>fmt::FmtError</code>;\nand <code>array::from_ref</code> rather than <code>array::array_from_ref</code>.</p>\n<h3>Known issues</h3>\n<p>Glob re-exports are ignored; e.g. this will not warn even though it should:</p>\n<pre><code>pub mod foo {\n    mod iteration {\n        pub struct FooIter {}\n    }\n    pub use iteration::*; // creates the path `foo::FooIter`\n}\n</code></pre>\n<h3>Example</h3>\n<pre><code>mod cake {\n    struct BlackForestCake;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>mod cake {\n    struct BlackForest;\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>stutter</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li><code>allowed-prefixes</code>:  List of prefixes to allow when determining whether an item\u2019s name ends with the module\u2019s name.\nIf the rest of an item\u2019s name is an allowed prefix (e.g. item <code>ToFoo</code> or <code>to_foo</code> in module <code>foo</code>),\nthen don\u2019t emit a warning.</li>\n</ul>\n<h4>Example</h4>\n<pre><code>allowed-prefixes = [ \"to\", \"from\" ]\n</code></pre>\n<h4>Noteworthy</h4>\n<ul>\n<li>\n<p>By default, the following prefixes are allowed: <code>to</code>, <code>as</code>, <code>into</code>, <code>from</code>, <code>try_into</code> and <code>try_from</code></p>\n</li>\n<li>\n<p>PascalCase variant is included automatically for each snake_case variant (e.g. if <code>try_into</code> is included,\n<code>TryInto</code> will also be included)</p>\n</li>\n<li>\n<p>Use <code>\"..\"</code> as part of the list to indicate that the configured values should be appended to the\ndefault configuration of Clippy. By default, any configuration will replace the default value</p>\n<p>(default: <code>[\"to\", \"as\", \"into\", \"from\", \"try_into\", \"try_from\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "modulo_arithmetic",
    "rule_name": "modulo_arithmetic",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for modulo arithmetic.</p>\n<h3>Why restrict this?</h3>\n<p>The results of modulo (<code>%</code>) operation might differ\ndepending on the language, when negative numbers are involved.\nIf you interop with different languages it might be beneficial\nto double check all places that use modulo arithmetic.</p>\n<p>For example, in Rust <code>17 % -3 = 2</code>, but in Python <code>17 % -3 = -1</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = -17 % 3;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-comparison-to-zero</code>:  Don\u2019t lint when comparing the result of a modulo operation to zero.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "modulo_one",
    "rule_name": "modulo_one",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for getting the remainder of integer division by one or minus\none.</p>\n<h3>Why is this bad?</h3>\n<p>The result for a divisor of one can only ever be zero; for\nminus one it can cause panic/overflow (if the left operand is the minimal value of\nthe respective integer type) or results in zero. No one will write such code\ndeliberately, unless trying to win an Underhanded Rust Contest. Even for that\ncontest, it\u2019s probably a bad idea. Use something more underhanded.</p>\n<h3>Example</h3>\n<pre><code>let a = x % 1;\nlet a = x % -1;\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "multi_assignments",
    "rule_name": "multi_assignments",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for nested assignments.</p>\n<h3>Why is this bad?</h3>\n<p>While this is in most cases already a type mismatch,\nthe result of an assignment being <code>()</code> can throw off people coming from languages like python or C,\nwhere such assignments return a copy of the assigned value.</p>\n<h3>Example</h3>\n<pre><code>a = b = 42;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>b = 42;\na = b;\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "multiple_bound_locations",
    "rule_name": "multiple_bound_locations",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Check if a generic is defined both in the bound predicate and in the <code>where</code> clause.</p>\n<h3>Why is this bad?</h3>\n<p>It can be confusing for developers when seeing bounds for a generic in multiple places.</p>\n<h3>Example</h3>\n<pre><code>fn ty<F: std::fmt::Debug>(a: F)\nwhere\n    F: Sized,\n{}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn ty<F>(a: F)\nwhere\n    F: Sized + std::fmt::Debug,\n{}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "multiple_crate_versions",
    "rule_name": "multiple_crate_versions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks to see if multiple versions of a crate are being\nused.</p>\n<h3>Why is this bad?</h3>\n<p>This bloats the size of targets, and can lead to\nconfusing error messages when structs or traits are used interchangeably\nbetween different versions of a crate.</p>\n<h3>Known problems</h3>\n<p>Because this can be caused purely by the dependencies\nthemselves, it\u2019s not always possible to fix this issue.\nIn those cases, you can allow that specific crate using\nthe <code>allowed_duplicate_crates</code> configuration option.</p>\n<h3>Example</h3>\n<pre><code>[dependencies]\nctrlc = \"=3.1.0\"\nansi_term = \"=0.11.0\"\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allowed-duplicate-crates</code>:  A list of crate names to allow duplicates of</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "cargo",
    "lint_level": "allow"
  },
  {
    "rule_id": "multiple_inherent_impl",
    "rule_name": "multiple_inherent_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for multiple inherent implementations of a struct</p>\n<h3>Why restrict this?</h3>\n<p>Splitting the implementation of a type makes the code harder to navigate.</p>\n<h3>Example</h3>\n<pre><code>struct X;\nimpl X {\n    fn one() {}\n}\nimpl X {\n    fn other() {}\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>struct X;\nimpl X {\n    fn one() {}\n    fn other() {}\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "multiple_unsafe_ops_per_block",
    "rule_name": "multiple_unsafe_ops_per_block",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>unsafe</code> blocks that contain more than one unsafe operation.</p>\n<h3>Why restrict this?</h3>\n<p>Combined with <code>undocumented_unsafe_blocks</code>,\nthis lint ensures that each unsafe operation must be independently justified.\nCombined with <code>unused_unsafe</code>, this lint also ensures\nelimination of unnecessary unsafe blocks through refactoring.</p>\n<h3>Example</h3>\n<pre><code>/// Reads a `char` from the given pointer.\n///\n/// # Safety\n///\n/// `ptr` must point to four consecutive, initialized bytes which\n/// form a valid `char` when interpreted in the native byte order.\nfn read_char(ptr: *const u8) -> char {\n    // SAFETY: The caller has guaranteed that the value pointed\n    // to by `bytes` is a valid `char`.\n    unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>/// Reads a `char` from the given pointer.\n///\n/// # Safety\n///\n/// - `ptr` must be 4-byte aligned, point to four consecutive\n///   initialized bytes, and be valid for reads of 4 bytes.\n/// - The bytes pointed to by `ptr` must represent a valid\n///   `char` when interpreted in the native byte order.\nfn read_char(ptr: *const u8) -> char {\n    // SAFETY: `ptr` is 4-byte aligned, points to four consecutive\n    // initialized bytes, and is valid for reads of 4 bytes.\n    let int_value = unsafe { *ptr.cast::<u32>() };\n\n    // SAFETY: The caller has guaranteed that the four bytes\n    // pointed to by `bytes` represent a valid `char`.\n    unsafe { char::from_u32_unchecked(int_value) }\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "must_use_candidate",
    "rule_name": "must_use_candidate",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for public functions that have no\n<code>#[must_use]</code> attribute, but return something not already marked\nmust-use, have no mutable arg and mutate no statics.</p>\n<h3>Why is this bad?</h3>\n<p>Not bad at all, this lint just shows places where\nyou could add the attribute.</p>\n<h3>Known problems</h3>\n<p>The lint only checks the arguments for mutable\ntypes without looking if they are actually changed. On the other hand,\nit also ignores a broad range of potentially interesting side effects,\nbecause we cannot decide whether the programmer intends the function to\nbe called for the side effect or the result. Expect many false\npositives. At least we don\u2019t lint if the result type is unit or already\n<code>#[must_use]</code>.</p>\n<h3>Examples</h3>\n<pre><code>// this could be annotated with `#[must_use]`.\npub fn id<T>(t: T) -> T { t }\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "must_use_unit",
    "rule_name": "must_use_unit",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a <code>#[must_use]</code> attribute on\nunit-returning functions and methods.</p>\n<h3>Why is this bad?</h3>\n<p>Unit values are useless. The attribute is likely\na remnant of a refactoring that removed the return type.</p>\n<h3>Examples</h3>\n<pre><code>#[must_use]\nfn useless() { }\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mut_from_ref",
    "rule_name": "mut_from_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for functions that take immutable references and return\nmutable ones. This will not trigger if no unsafe code exists as there\nare multiple safe functions which will do this transformation</p>\n<p>To be on the conservative side, if there\u2019s at least one mutable\nreference with the output lifetime, this lint will not trigger.</p>\n<h3>Why is this bad?</h3>\n<p>Creating a mutable reference which can be repeatably derived from an\nimmutable reference is unsound as it allows creating multiple live\nmutable references to the same object.</p>\n<p>This <a>error</a> actually\nlead to an interim Rust release 1.15.1.</p>\n<h3>Known problems</h3>\n<p>This pattern is used by memory allocators to allow allocating multiple\nobjects while returning mutable references to each one. So long as\ndifferent mutable references are returned each time such a function may\nbe safe.</p>\n<h3>Example</h3>\n<pre><code>fn foo(&Foo) -> &mut Bar { .. }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "mut_mut",
    "rule_name": "mut_mut",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for instances of <code>mut mut</code> references.</p>\n<h3>Why is this bad?</h3>\n<p>Multiple <code>mut</code>s don\u2019t add anything meaningful to the\nsource. This is either a copy\u2019n\u2019paste error, or it shows a fundamental\nmisunderstanding of references.</p>\n<h3>Example</h3>\n<pre><code>let x = &mut &mut y;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "mut_mutex_lock",
    "rule_name": "mut_mutex_lock",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>&mut Mutex::lock</code> calls</p>\n<h3>Why is this bad?</h3>\n<p><code>Mutex::lock</code> is less efficient than\ncalling <code>Mutex::get_mut</code>. In addition you also have a statically\nguarantee that the mutex isn\u2019t locked, instead of just a runtime\nguarantee.</p>\n<h3>Example</h3>\n<pre><code>use std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet mut value = value_mutex.lock().unwrap();\n*value += 1;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet value = value_mutex.get_mut().unwrap();\n*value += 1;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "mut_range_bound",
    "rule_name": "mut_range_bound",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for loops with a range bound that is a mutable variable.</p>\n<h3>Why is this bad?</h3>\n<p>One might think that modifying the mutable variable changes the loop bounds. It doesn\u2019t.</p>\n<h3>Known problems</h3>\n<p>False positive when mutation is followed by a <code>break</code>, but the <code>break</code> is not immediately\nafter the mutation:</p>\n<pre><code>let mut x = 5;\nfor _ in 0..x {\n    x += 1; // x is a range bound that is mutated\n    ..; // some other expression\n    break; // leaves the loop, so mutation is not an issue\n}\n</code></pre>\n<p>False positive on nested loops (<a>#6072</a>)</p>\n<h3>Example</h3>\n<pre><code>let mut foo = 42;\nfor i in 0..foo {\n    foo -= 1;\n    println!(\"{i}\"); // prints numbers from 0 to 41, not 0 to 21\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "mutable_key_type",
    "rule_name": "mutable_key_type",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for sets/maps with mutable key types.</p>\n<h3>Why is this bad?</h3>\n<p>All of <code>HashMap</code>, <code>HashSet</code>, <code>BTreeMap</code> and\n<code>BtreeSet</code> rely on either the hash or the order of keys be unchanging,\nso having types with interior mutability is a bad idea.</p>\n<h3>Known problems</h3>\n<h4>False Positives</h4>\n<p>It\u2019s correct to use a struct that contains interior mutability as a key when its\nimplementation of <code>Hash</code> or <code>Ord</code> doesn\u2019t access any of the interior mutable types.\nHowever, this lint is unable to recognize this, so it will often cause false positives in\nthese cases.</p>\n<h4>False Negatives</h4>\n<p>This lint does not follow raw pointers (<code>*const T</code> or <code>*mut T</code>) as <code>Hash</code> and <code>Ord</code>\napply only to the <strong>address</strong> of the contained value. This can cause false negatives for\ncustom collections that use raw pointers internally.</p>\n<h3>Example</h3>\n<pre><code>use std::cmp::{PartialEq, Eq};\nuse std::collections::HashSet;\nuse std::hash::{Hash, Hasher};\nuse std::sync::atomic::AtomicUsize;\n\nstruct Bad(AtomicUsize);\nimpl PartialEq for Bad {\n    fn eq(&self, rhs: &Self) -> bool {\n         ..\n    }\n}\n\nimpl Eq for Bad {}\n\nimpl Hash for Bad {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        ..\n    }\n}\n\nfn main() {\n    let _: HashSet<Bad> = HashSet::new();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>\n<p>(default: <code>[\"bytes::Bytes\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "mutex_atomic",
    "rule_name": "mutex_atomic",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Mutex<X></code> where an atomic will do.</p>\n<h3>Why restrict this?</h3>\n<p>Using a mutex just to make access to a plain bool or\nreference sequential is shooting flies with cannons.\n<code>std::sync::atomic::AtomicBool</code> and <code>std::sync::atomic::AtomicPtr</code> are leaner and\nfaster.</p>\n<p>On the other hand, <code>Mutex</code>es are, in general, easier to\nverify correctness. An atomic does not behave the same as\nan equivalent mutex. See <a>this issue</a>\u2019s commentary for more details.</p>\n<h3>Known problems</h3>\n<p>This lint cannot detect if the mutex is actually used\nfor waiting before a critical section.</p>\n<h3>Example</h3>\n<pre><code>let x = Mutex::new(&y);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = AtomicBool::new(y);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "mutex_integer",
    "rule_name": "mutex_integer",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Mutex<X></code> where <code>X</code> is an integral\ntype.</p>\n<h3>Why is this bad?</h3>\n<p>Using a mutex just to make access to a plain integer\nsequential is\nshooting flies with cannons. <code>std::sync::atomic::AtomicUsize</code> is leaner and faster.</p>\n<h3>Known problems</h3>\n<p>This lint cannot detect if the mutex is actually used\nfor waiting before a critical section.</p>\n<h3>Example</h3>\n<pre><code>let x = Mutex::new(0usize);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = AtomicUsize::new(0usize);\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "naive_bytecount",
    "rule_name": "naive_bytecount",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for naive byte counts</p>\n<h3>Why is this bad?</h3>\n<p>The <a><code>bytecount</code></a>\ncrate has methods to count your bytes faster, especially for large slices.</p>\n<h3>Known problems</h3>\n<p>If you have predominantly small slices, the\n<code>bytecount::count(..)</code> method may actually be slower. However, if you can\nensure that less than 2\u00b3\u00b2-1 matches arise, the <code>naive_count_32(..)</code> can be\nfaster in those cases.</p>\n<h3>Example</h3>\n<pre><code>let count = vec.iter().filter(|x| **x == 0u8).count();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let count = bytecount::count(&vec, 0u8);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_arbitrary_self_type",
    "rule_name": "needless_arbitrary_self_type",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>The lint checks for <code>self</code> in fn parameters that\nspecify the <code>Self</code>-type explicitly</p>\n<h3>Why is this bad?</h3>\n<p>Increases the amount and decreases the readability of code</p>\n<h3>Example</h3>\n<pre><code>enum ValType {\n    I32,\n    I64,\n    F32,\n    F64,\n}\n\nimpl ValType {\n    pub fn bytes(self: Self) -> usize {\n        match self {\n            Self::I32 | Self::F32 => 4,\n            Self::I64 | Self::F64 => 8,\n        }\n    }\n}\n</code></pre>\n<p>Could be rewritten as</p>\n<pre><code>enum ValType {\n    I32,\n    I64,\n    F32,\n    F64,\n}\n\nimpl ValType {\n    pub fn bytes(self) -> usize {\n        match self {\n            Self::I32 | Self::F32 => 4,\n            Self::I64 | Self::F64 => 8,\n        }\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_as_bytes",
    "rule_name": "needless_as_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It detects useless calls to <code>str::as_bytes()</code> before calling <code>len()</code> or <code>is_empty()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>len()</code> and <code>is_empty()</code> methods are also directly available on strings, and they\nreturn identical results. In particular, <code>len()</code> on a string returns the number of\nbytes.</p>\n<h3>Example</h3>\n<pre><code>let len = \"some string\".as_bytes().len();\nlet b = \"some string\".as_bytes().is_empty();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let len = \"some string\".len();\nlet b = \"some string\".is_empty();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_bitwise_bool",
    "rule_name": "needless_bitwise_bool",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of bitwise and/or operators between booleans, where performance may be improved by using\na lazy and.</p>\n<h3>Why is this bad?</h3>\n<p>The bitwise operators do not support short-circuiting, so it may hinder code performance.\nAdditionally, boolean logic \u201cmasked\u201d as bitwise logic is not caught by lints like <code>unnecessary_fold</code></p>\n<h3>Known problems</h3>\n<p>This lint evaluates only when the right side is determined to have no side effects. At this time, that\ndetermination is quite conservative.</p>\n<h3>Example</h3>\n<pre><code>let (x,y) = (true, false);\nif x & !y {} // where both x and y are booleans\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let (x,y) = (true, false);\nif x && !y {}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_bool",
    "rule_name": "needless_bool",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions of the form <code>if c { true } else { false }</code> (or vice versa) and suggests using the condition directly.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code.</p>\n<h3>Known problems</h3>\n<p>Maybe false positives: Sometimes, the two branches are\npainstakingly documented (which we, of course, do not detect), so they <em>may</em>\nhave some value. Even then, the documentation can be rewritten to match the\nshorter code.</p>\n<h3>Example</h3>\n<pre><code>if x {\n    false\n} else {\n    true\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>!x\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_bool_assign",
    "rule_name": "needless_bool_assign",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions of the form <code>if c { x = true } else { x = false }</code>\n(or vice versa) and suggest assigning the variable directly from the\ncondition.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code.</p>\n<h3>Example</h3>\n<pre><code>if must_keep(x, y) {\n    skip = false;\n} else {\n    skip = true;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>skip = !must_keep(x, y);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_borrow",
    "rule_name": "needless_borrow",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for address of operations (<code>&</code>) that are going to\nbe dereferenced immediately by the compiler.</p>\n<h3>Why is this bad?</h3>\n<p>Suggests that the receiver of the expression borrows\nthe expression.</p>\n<h3>Known problems</h3>\n<p>The lint cannot tell when the implementation of a trait\nfor <code>&T</code> and <code>T</code> do different things. Removing a borrow\nin such a case can change the semantics of the code.</p>\n<h3>Example</h3>\n<pre><code>fn fun(_a: &i32) {}\n\nlet x: &i32 = &&&&&&5;\nfun(&x);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: &i32 = &5;\nfun(x);\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>ref_in_deref</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_borrowed_reference",
    "rule_name": "needless_borrowed_reference",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bindings that needlessly destructure a reference and borrow the inner\nvalue with <code>&ref</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This pattern has no effect in almost all cases.</p>\n<h3>Example</h3>\n<pre><code>let mut v = Vec::<String>::new();\nv.iter_mut().filter(|&ref a| a.is_empty());\n\nif let &[ref first, ref second] = v.as_slice() {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut v = Vec::<String>::new();\nv.iter_mut().filter(|a| a.is_empty());\n\nif let [first, second] = v.as_slice() {}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_borrows_for_generic_args",
    "rule_name": "needless_borrows_for_generic_args",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for borrow operations (<code>&</code>) that are used as a generic argument to a\nfunction when the borrowed value could be used.</p>\n<h3>Why is this bad?</h3>\n<p>Suggests that the receiver of the expression borrows\nthe expression.</p>\n<h3>Known problems</h3>\n<p>The lint cannot tell when the implementation of a trait\nfor <code>&T</code> and <code>T</code> do different things. Removing a borrow\nin such a case can change the semantics of the code.</p>\n<h3>Example</h3>\n<pre><code>fn f(_: impl AsRef<str>) {}\n\nlet x = \"foo\";\nf(&x);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn f(_: impl AsRef<str>) {}\n\nlet x = \"foo\";\nf(x);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_character_iteration",
    "rule_name": "needless_character_iteration",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if an iterator is used to check if a string is ascii.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>str</code> type already implements the <code>is_ascii</code> method.</p>\n<h3>Example</h3>\n<pre><code>\"foo\".chars().all(|c| c.is_ascii());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\"foo\".is_ascii();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_collect",
    "rule_name": "needless_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions collecting an iterator when collect\nis not needed.</p>\n<h3>Why is this bad?</h3>\n<p><code>collect</code> causes the allocation of a new data structure,\nwhen this allocation may not be needed.</p>\n<h3>Example</h3>\n<pre><code>let len = iterator.collect::<Vec<_>>().len();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let len = iterator.count();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_continue",
    "rule_name": "needless_continue",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>The lint checks for <code>if</code>-statements appearing in loops\nthat contain a <code>continue</code> statement in either their main blocks or their\n<code>else</code>-blocks, when omitting the <code>else</code>-block possibly with some\nrearrangement of code can make the code easier to understand.</p>\n<h3>Why is this bad?</h3>\n<p>Having explicit <code>else</code> blocks for <code>if</code> statements\ncontaining <code>continue</code> in their THEN branch adds unnecessary branching and\nnesting to the code. Having an else block containing just <code>continue</code> can\nalso be better written by grouping the statements following the whole <code>if</code>\nstatement within the THEN block and omitting the else block completely.</p>\n<h3>Example</h3>\n<pre><code>while condition() {\n    update_condition();\n    if x {\n        // ...\n    } else {\n        continue;\n    }\n    println!(\"Hello, world\");\n}\n</code></pre>\n<p>Could be rewritten as</p>\n<pre><code>while condition() {\n    update_condition();\n    if x {\n        // ...\n        println!(\"Hello, world\");\n    }\n}\n</code></pre>\n<p>As another example, the following code</p>\n<pre><code>loop {\n    if waiting() {\n        continue;\n    } else {\n        // Do something useful\n    }\n    # break;\n}\n</code></pre>\n<p>Could be rewritten as</p>\n<pre><code>loop {\n    if waiting() {\n        continue;\n    }\n    // Do something useful\n    # break;\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_doctest_main",
    "rule_name": "needless_doctest_main",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>fn main() { .. }</code> in doctests</p>\n<h3>Why is this bad?</h3>\n<p>The test can be shorter (and likely more readable)\nif the <code>fn main()</code> is left implicit.</p>\n<h3>Examples</h3>\n<pre><code>/// An example of a doctest with a `main()` function\n///\n/// # Examples\n///\n/// ```\n/// fn main() {\n///     // this needs not be in an `fn`\n/// }\n/// ```\nfn needless_main() {\n    unimplemented!();\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_else",
    "rule_name": "needless_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty <code>else</code> branches.</p>\n<h3>Why is this bad?</h3>\n<p>An empty else branch does nothing and can be removed.</p>\n<h3>Example</h3>\n<pre><code>if check() {\n    println!(\"Check successful!\");\n} else {\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if check() {\n    println!(\"Check successful!\");\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_for_each",
    "rule_name": "needless_for_each",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>for_each</code> that would be more simply written as a\n<code>for</code> loop.</p>\n<h3>Why is this bad?</h3>\n<p><code>for_each</code> may be used after applying iterator transformers like\n<code>filter</code> for better readability and performance. It may also be used to fit a simple\noperation on one line.\nBut when none of these apply, a simple <code>for</code> loop is more idiomatic.</p>\n<h3>Example</h3>\n<pre><code>let v = vec![0, 1, 2];\nv.iter().for_each(|elem| {\n    println!(\"{elem}\");\n})\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let v = vec![0, 1, 2];\nfor elem in &v {\n    println!(\"{elem}\");\n}\n</code></pre>\n<h3>Known Problems</h3>\n<p>When doing things such as:</p>\n<pre><code>let v = vec![0, 1, 2];\nv.iter().for_each(|elem| unsafe {\n    libc::printf(c\"%d\\n\".as_ptr(), elem);\n});\n</code></pre>\n<p>This lint will not trigger.</p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_if",
    "rule_name": "needless_if",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for empty <code>if</code> branches with no else branch.</p>\n<h3>Why is this bad?</h3>\n<p>It can be entirely omitted, and often the condition too.</p>\n<h3>Known issues</h3>\n<p>This will usually only suggest to remove the <code>if</code> statement, not the condition. Other lints\nsuch as <code>no_effect</code> will take care of removing the condition if it\u2019s unnecessary.</p>\n<h3>Example</h3>\n<pre><code>if really_expensive_condition(&i) {}\nif really_expensive_condition_with_side_effects(&mut i) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// <omitted>\nreally_expensive_condition_with_side_effects(&mut i);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_late_init",
    "rule_name": "needless_late_init",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for late initializations that can be replaced by a <code>let</code> statement\nwith an initializer.</p>\n<h3>Why is this bad?</h3>\n<p>Assigning in the <code>let</code> statement is less repetitive.</p>\n<h3>Example</h3>\n<pre><code>let a;\na = 1;\n\nlet b;\nmatch 3 {\n    0 => b = \"zero\",\n    1 => b = \"one\",\n    _ => b = \"many\",\n}\n\nlet c;\nif true {\n    c = 1;\n} else {\n    c = -1;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = 1;\n\nlet b = match 3 {\n    0 => \"zero\",\n    1 => \"one\",\n    _ => \"many\",\n};\n\nlet c = if true {\n    1\n} else {\n    -1\n};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_lifetimes",
    "rule_name": "needless_lifetimes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for lifetime annotations which can be removed by\nrelying on lifetime elision.</p>\n<h3>Why is this bad?</h3>\n<p>The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.</p>\n<h3>Known problems</h3>\n<ul>\n<li>We bail out if the function has a <code>where</code> clause where lifetimes\nare mentioned due to potential false positives.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>// Unnecessary lifetime annotations\nfn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n    x\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn elided(x: &u8, y: u8) -> &u8 {\n    x\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_match",
    "rule_name": "needless_match",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary <code>match</code> or match-like <code>if let</code> returns for <code>Option</code> and <code>Result</code>\nwhen function signatures are the same.</p>\n<h3>Why is this bad?</h3>\n<p>This <code>match</code> block does nothing and might not be what the coder intended.</p>\n<h3>Example</h3>\n<pre><code>fn foo() -> Result<(), i32> {\n    match result {\n        Ok(val) => Ok(val),\n        Err(err) => Err(err),\n    }\n}\n\nfn bar() -> Option<i32> {\n    if let Some(val) = option {\n        Some(val)\n    } else {\n        None\n    }\n}\n</code></pre>\n<p>Could be replaced as</p>\n<pre><code>fn foo() -> Result<(), i32> {\n    result\n}\n\nfn bar() -> Option<i32> {\n    option\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_maybe_sized",
    "rule_name": "needless_maybe_sized",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints <code>?Sized</code> bounds applied to type parameters that cannot be unsized</p>\n<h3>Why is this bad?</h3>\n<p>The <code>?Sized</code> bound is misleading because it cannot be satisfied by an\nunsized type</p>\n<h3>Example</h3>\n<pre><code>// `T` cannot be unsized because `Clone` requires it to be `Sized`\nfn f<T: Clone + ?Sized>(t: &T) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn f<T: Clone>(t: &T) {}\n\n// or choose alternative bounds for `T` so that it can be unsized\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_option_as_deref",
    "rule_name": "needless_option_as_deref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for no-op uses of <code>Option::{as_deref, as_deref_mut}</code>,\nfor example, <code>Option<&T>::as_deref()</code> returns the same type.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code and improving readability.</p>\n<h3>Example</h3>\n<pre><code>let a = Some(&1);\nlet b = a.as_deref(); // goes from Option<&i32> to Option<&i32>\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = Some(&1);\nlet b = a;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_option_take",
    "rule_name": "needless_option_take",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calling <code>take</code> function after <code>as_ref</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code. <code>take</code> writes <code>None</code> to its argument.\nIn this case the modification is useless as it\u2019s a temporary that cannot be read from afterwards.</p>\n<h3>Example</h3>\n<pre><code>let x = Some(3);\nx.as_ref().take();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = Some(3);\nx.as_ref();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_parens_on_range_literals",
    "rule_name": "needless_parens_on_range_literals",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>The lint checks for parenthesis on literals in range statements that are\nsuperfluous.</p>\n<h3>Why is this bad?</h3>\n<p>Having superfluous parenthesis makes the code less readable\noverhead when reading.</p>\n<h3>Example</h3>\n<pre><code>for i in (0)..10 {\n  println!(\"{i}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for i in 0..10 {\n  println!(\"{i}\");\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_pass_by_ref_mut",
    "rule_name": "needless_pass_by_ref_mut",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Check if a <code>&mut</code> function argument is actually used mutably.</p>\n<p>Be careful if the function is publicly reexported as it would break compatibility with\nusers of this function, when the users pass this function as an argument.</p>\n<h3>Why is this bad?</h3>\n<p>Less <code>mut</code> means less fights with the borrow checker. It can also lead to more\nopportunities for parallelization.</p>\n<h3>Example</h3>\n<pre><code>fn foo(y: &mut i32) -> i32 {\n    12 + *y\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(y: &i32) -> i32 {\n    12 + *y\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_pass_by_value",
    "rule_name": "needless_pass_by_value",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions taking arguments by value, but not\nconsuming them in its\nbody.</p>\n<h3>Why is this bad?</h3>\n<p>Taking arguments by reference is more flexible and can\nsometimes avoid\nunnecessary allocations.</p>\n<h3>Known problems</h3>\n<ul>\n<li>This lint suggests taking an argument by reference,\nhowever sometimes it is better to let users decide the argument type\n(by using <code>Borrow</code> trait, for example), depending on how the function is used.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>fn foo(v: Vec<i32>) {\n    assert_eq!(v.len(), 42);\n}\n</code></pre>\n<p>should be</p>\n<pre><code>fn foo(v: &[i32]) {\n    assert_eq!(v.len(), 42);\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_pub_self",
    "rule_name": "needless_pub_self",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>pub(self)</code> and <code>pub(in self)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s unnecessary, omitting the <code>pub</code> entirely will give the same results.</p>\n<h3>Example</h3>\n<pre><code>pub(self) type OptBox<T> = Option<Box<T>>;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>type OptBox<T> = Option<Box<T>>;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_question_mark",
    "rule_name": "needless_question_mark",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests alternatives for useless applications of <code>?</code> in terminating expressions</p>\n<h3>Why is this bad?</h3>\n<p>There\u2019s no reason to use <code>?</code> to short-circuit when execution of the body will end there anyway.</p>\n<h3>Example</h3>\n<pre><code>struct TO {\n    magic: Option<usize>,\n}\n\nfn f(to: TO) -> Option<usize> {\n    Some(to.magic?)\n}\n\nstruct TR {\n    magic: Result<usize, bool>,\n}\n\nfn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n    tr.and_then(|t| Ok(t.magic?))\n}\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct TO {\n    magic: Option<usize>,\n}\n\nfn f(to: TO) -> Option<usize> {\n   to.magic\n}\n\nstruct TR {\n    magic: Result<usize, bool>,\n}\n\nfn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n    tr.and_then(|t| t.magic)\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_range_loop",
    "rule_name": "needless_range_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for looping over the range of <code>0..len</code> of some\ncollection just to get the values by index.</p>\n<h3>Why is this bad?</h3>\n<p>Just iterating the collection itself makes the intent\nmore clear and is probably faster because it eliminates\nthe bounds check that is done when indexing.</p>\n<h3>Example</h3>\n<pre><code>let vec = vec!['a', 'b', 'c'];\nfor i in 0..vec.len() {\n    println!(\"{}\", vec[i]);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let vec = vec!['a', 'b', 'c'];\nfor i in vec {\n    println!(\"{}\", i);\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_raw_string_hashes",
    "rule_name": "needless_raw_string_hashes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for raw string literals with an unnecessary amount of hashes around them.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s just unnecessary, and makes it look like there\u2019s more escaping needed than is actually\nnecessary.</p>\n<h3>Example</h3>\n<pre><code>let r = r###\"Hello, \"world\"!\"###;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let r = r#\"Hello, \"world\"!\"#;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_raw_strings",
    "rule_name": "needless_raw_strings",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for raw string literals where a string literal can be used instead.</p>\n<h3>Why restrict this?</h3>\n<p>For consistent style by using simpler string literals whenever possible.</p>\n<p>However, there are many cases where using a raw string literal is more\nidiomatic than a string literal, so it\u2019s opt-in.</p>\n<h3>Example</h3>\n<pre><code>let r = r\"Hello, world!\";\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let r = \"Hello, world!\";\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "needless_return",
    "rule_name": "needless_return",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for return statements at the end of a block.</p>\n<h3>Why is this bad?</h3>\n<p>Removing the <code>return</code> and semicolon will make the code\nmore rusty.</p>\n<h3>Example</h3>\n<pre><code>fn foo(x: usize) -> usize {\n    return x;\n}\n</code></pre>\n<p>simplify to</p>\n<pre><code>fn foo(x: usize) -> usize {\n    x\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_return_with_question_mark",
    "rule_name": "needless_return_with_question_mark",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for return statements on <code>Err</code> paired with the <code>?</code> operator.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>return</code> is unnecessary.</p>\n<p>Returns may be used to add attributes to the return expression. Return\nstatements with attributes are therefore be accepted by this lint.</p>\n<h3>Example</h3>\n<pre><code>fn foo(x: usize) -> Result<(), Box<dyn Error>> {\n    if x == 0 {\n        return Err(...)?;\n    }\n    Ok(())\n}\n</code></pre>\n<p>simplify to</p>\n<pre><code>fn foo(x: usize) -> Result<(), Box<dyn Error>> {\n    if x == 0 {\n        Err(...)?;\n    }\n    Ok(())\n}\n</code></pre>\n<p>if paired with <code>try_err</code>, use instead:</p>\n<pre><code>fn foo(x: usize) -> Result<(), Box<dyn Error>> {\n    if x == 0 {\n        return Err(...);\n    }\n    Ok(())\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_splitn",
    "rule_name": "needless_splitn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>str::splitn</code> (or <code>str::rsplitn</code>) where using <code>str::split</code> would be the same.</p>\n<h3>Why is this bad?</h3>\n<p>The function <code>split</code> is simpler and there is no performance difference in these cases, considering\nthat both functions return a lazy iterator.</p>\n<h3>Example</h3>\n<pre><code>let str = \"key=value=add\";\nlet _ = str.splitn(3, '=').next().unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let str = \"key=value=add\";\nlet _ = str.split('=').next().unwrap();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "needless_update",
    "rule_name": "needless_update",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for needlessly including a base struct on update\nwhen all fields are changed anyway.</p>\n<p>This lint is not applied to structs marked with\n<a>non_exhaustive</a>.</p>\n<h3>Why is this bad?</h3>\n<p>This will cost resources (because the base has to be\nsomewhere), and make the code less readable.</p>\n<h3>Example</h3>\n<pre><code>Point {\n    x: 1,\n    y: 1,\n    z: 1,\n    ..zero_point\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Missing field `z`\nPoint {\n    x: 1,\n    y: 1,\n    ..zero_point\n};\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "neg_cmp_op_on_partial_ord",
    "rule_name": "neg_cmp_op_on_partial_ord",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of negated comparison operators on types which only implement\n<code>PartialOrd</code> (e.g., <code>f64</code>).</p>\n<h3>Why is this bad?</h3>\n<p>These operators make it easy to forget that the underlying types actually allow not only three\npotential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\nespecially easy to miss if the operator based comparison result is negated.</p>\n<h3>Example</h3>\n<pre><code>let a = 1.0;\nlet b = f64::NAN;\n\nlet not_less_or_equal = !(a <= b);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::cmp::Ordering;\n\nlet _not_less_or_equal = match a.partial_cmp(&b) {\n    None | Some(Ordering::Greater) => true,\n    _ => false,\n};\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "neg_multiply",
    "rule_name": "neg_multiply",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for multiplication by -1 as a form of negation.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more readable to just negate.</p>\n<h3>Known problems</h3>\n<p>This only catches integers (for now).</p>\n<h3>Example</h3>\n<pre><code>let a = x * -1;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = -x;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "negative_feature_names",
    "rule_name": "negative_feature_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for negative feature names with prefix <code>no-</code> or <code>not-</code></p>\n<h3>Why is this bad?</h3>\n<p>Features are supposed to be additive, and negatively-named features violate it.</p>\n<h3>Example</h3>\n<pre><code>[features]\ndefault = []\nno-abc = []\nnot-def = []\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>[features]\ndefault = [\"abc\", \"def\"]\nabc = []\ndef = []\n\n</code></pre>\n</div>",
    "lint_group": "cargo",
    "lint_level": "allow"
  },
  {
    "rule_id": "never_loop",
    "rule_name": "never_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for loops that will always <code>break</code>, <code>return</code> or\n<code>continue</code> an outer loop.</p>\n<h3>Why is this bad?</h3>\n<p>This loop never loops, all it does is obfuscating the\ncode.</p>\n<h3>Example</h3>\n<pre><code>loop {\n    ..;\n    break;\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "new_ret_no_self",
    "rule_name": "new_ret_no_self",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>new</code> not returning a type that contains <code>Self</code>.</p>\n<h3>Why is this bad?</h3>\n<p>As a convention, <code>new</code> methods are used to make a new\ninstance of a type.</p>\n<h3>Example</h3>\n<p>In an impl block:</p>\n<pre><code>impl Foo {\n    fn new() -> NotAFoo {\n    }\n}\n</code></pre>\n<pre><code>struct Bar(Foo);\nimpl Foo {\n    // Bad. The type name must contain `Self`\n    fn new() -> Bar {\n    }\n}\n</code></pre>\n<pre><code>impl Foo {\n    // Good. Return type contains `Self`\n    fn new() -> Result<Foo, FooError> {\n    }\n}\n</code></pre>\n<p>Or in a trait definition:</p>\n<pre><code>pub trait Trait {\n    // Bad. The type name must contain `Self`\n    fn new();\n}\n</code></pre>\n<pre><code>pub trait Trait {\n    // Good. Return type contains `Self`\n    fn new() -> Self;\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "new_without_default",
    "rule_name": "new_without_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for public types with a <code>pub fn new() -> Self</code> method and no\nimplementation of\n<a><code>Default</code></a>.</p>\n<h3>Why is this bad?</h3>\n<p>The user might expect to be able to use\n<a><code>Default</code></a> as the\ntype can be constructed without arguments.</p>\n<h3>Example</h3>\n<pre><code>pub struct Foo(Bar);\n\nimpl Foo {\n    pub fn new() -> Self {\n        Foo(Bar::new())\n    }\n}\n</code></pre>\n<p>To fix the lint, add a <code>Default</code> implementation that delegates to <code>new</code>:</p>\n<pre><code>pub struct Foo(Bar);\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Foo::new()\n    }\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>new_without_default_derive</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "no_effect",
    "rule_name": "no_effect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for statements which have no effect.</p>\n<h3>Why is this bad?</h3>\n<p>Unlike dead code, these statements are actually\nexecuted. However, as they have no effect, all they do is make the code less\nreadable.</p>\n<h3>Example</h3>\n<pre><code>0;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "no_effect_replace",
    "rule_name": "no_effect_replace",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>replace</code> statements which have no effect.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s either a mistake or confusing.</p>\n<h3>Example</h3>\n<pre><code>\"1234\".replace(\"12\", \"12\");\n\"1234\".replacen(\"12\", \"12\", 1);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "no_effect_underscore_binding",
    "rule_name": "no_effect_underscore_binding",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for binding to underscore prefixed variable without side-effects.</p>\n<h3>Why is this bad?</h3>\n<p>Unlike dead code, these bindings are actually\nexecuted. However, as they have no effect and shouldn\u2019t be used further on, all they\ndo is make the code less readable.</p>\n<h3>Example</h3>\n<pre><code>let _i_serve_no_purpose = 1;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "no_mangle_with_rust_abi",
    "rule_name": "no_mangle_with_rust_abi",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for Rust ABI functions with the <code>#[no_mangle]</code> attribute.</p>\n<h3>Why is this bad?</h3>\n<p>The Rust ABI is not stable, but in many simple cases matches\nenough with the C ABI that it is possible to forget to add\n<code>extern \"C\"</code> to a function called from C. Changes to the\nRust ABI can break this at any point.</p>\n<h3>Example</h3>\n<pre><code> #[no_mangle]\n fn example(arg_one: u32, arg_two: usize) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code> #[no_mangle]\n extern \"C\" fn example(arg_one: u32, arg_two: usize) {}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "non_ascii_literal",
    "rule_name": "non_ascii_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for non-ASCII characters in string and char literals.</p>\n<h3>Why restrict this?</h3>\n<p>Yeah, we know, the 90\u2019s called and wanted their charset\nback. Even so, there still are editors and other programs out there that\ndon\u2019t work well with Unicode. So if the code is meant to be used\ninternationally, on multiple operating systems, or has other portability\nrequirements, activating this lint could be useful.</p>\n<h3>Example</h3>\n<pre><code>let x = String::from(\"\u20ac\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = String::from(\"\\u{20ac}\");\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "non_canonical_clone_impl",
    "rule_name": "non_canonical_clone_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for non-canonical implementations of <code>Clone</code> when <code>Copy</code> is already implemented.</p>\n<h3>Why is this bad?</h3>\n<p>If both <code>Clone</code> and <code>Copy</code> are implemented, they must agree. This can done by dereferencing\n<code>self</code> in <code>Clone</code>\u2019s implementation, which will avoid any possibility of the implementations\nbecoming out of sync.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Clone for A {\n    fn clone(&self) -> Self {\n        Self(self.0)\n    }\n}\n\nimpl Copy for A {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Clone for A {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\nimpl Copy for A {}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>incorrect_clone_impl_on_copy_type</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "non_canonical_partial_ord_impl",
    "rule_name": "non_canonical_partial_ord_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for non-canonical implementations of <code>PartialOrd</code> when <code>Ord</code> is already implemented.</p>\n<h3>Why is this bad?</h3>\n<p>If both <code>PartialOrd</code> and <code>Ord</code> are implemented, they must agree. This is commonly done by\nwrapping the result of <code>cmp</code> in <code>Some</code> for <code>partial_cmp</code>. Not doing this may silently\nintroduce an error upon refactoring.</p>\n<h3>Known issues</h3>\n<p>Code that calls the <code>.into()</code> method instead will be flagged, despite <code>.into()</code> wrapping it\nin <code>Some</code>.</p>\n<h3>Example</h3>\n<pre><code>#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Ord for A {\n    fn cmp(&self, other: &Self) -> Ordering {\n        // ...\n    }\n}\n\nimpl PartialOrd for A {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        // ...\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Ord for A {\n    fn cmp(&self, other: &Self) -> Ordering {\n        // ...\n    }\n}\n\nimpl PartialOrd for A {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>incorrect_partial_ord_impl_on_ord_type</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "non_minimal_cfg",
    "rule_name": "non_minimal_cfg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>any</code> and <code>all</code> combinators in <code>cfg</code> with only one condition.</p>\n<h3>Why is this bad?</h3>\n<p>If there is only one condition, no need to wrap it into <code>any</code> or <code>all</code> combinators.</p>\n<h3>Example</h3>\n<pre><code>#[cfg(any(unix))]\npub struct Bar;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[cfg(unix)]\npub struct Bar;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "non_octal_unix_permissions",
    "rule_name": "non_octal_unix_permissions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for non-octal values used to set Unix file permissions.</p>\n<h3>Why is this bad?</h3>\n<p>They will be converted into octal, creating potentially\nunintended file permissions.</p>\n<h3>Example</h3>\n<pre><code>use std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(644);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(0o644);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "non_send_fields_in_send_ty",
    "rule_name": "non_send_fields_in_send_ty",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns about a <code>Send</code> implementation for a type that\ncontains fields that are not safe to be sent across threads.\nIt tries to detect fields that can cause a soundness issue\nwhen sent to another thread (e.g., <code>Rc</code>) while allowing <code>!Send</code> fields\nthat are expected to exist in a <code>Send</code> type, such as raw pointers.</p>\n<h3>Why is this bad?</h3>\n<p>Sending the struct to another thread effectively sends all of its fields,\nand the fields that do not implement <code>Send</code> can lead to soundness bugs\nsuch as data races when accessed in a thread\nthat is different from the thread that created it.</p>\n<p>See:</p>\n<ul>\n<li><a><em>The Rustonomicon</em> about <em>Send and Sync</em></a></li>\n<li><a>The documentation of <code>Send</code></a></li>\n</ul>\n<h3>Known Problems</h3>\n<p>This lint relies on heuristics to distinguish types that are actually\nunsafe to be sent across threads and <code>!Send</code> types that are expected to\nexist in  <code>Send</code> type. Its rule can filter out basic cases such as\n<code>Vec<*const T></code>, but it\u2019s not perfect. Feel free to create an issue if\nyou have a suggestion on how this heuristic can be improved.</p>\n<h3>Example</h3>\n<pre><code>struct ExampleStruct<T> {\n    rc_is_not_send: Rc<String>,\n    unbounded_generic_field: T,\n}\n\n// This impl is unsound because it allows sending `!Send` types through `ExampleStruct`\nunsafe impl<T> Send for ExampleStruct<T> {}\n</code></pre>\n<p>Use thread-safe types like <a><code>std::sync::Arc</code></a>\nor specify correct bounds on generic type parameters (<code>T: Send</code>).</p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>enable-raw-pointer-heuristic-for-send</code>:  Whether to apply the raw pointer heuristic to determine if a type is <code>Send</code>.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "non_zero_suggestions",
    "rule_name": "non_zero_suggestions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for conversions from <code>NonZero</code> types to regular integer types,\nand suggests using <code>NonZero</code> types for the target as well.</p>\n<h3>Why is this bad?</h3>\n<p>Converting from <code>NonZero</code> types to regular integer types and then back to <code>NonZero</code>\ntypes is less efficient and loses the type-safety guarantees provided by <code>NonZero</code> types.\nUsing <code>NonZero</code> types consistently can lead to more optimized code and prevent\ncertain classes of errors related to zero values.</p>\n<h3>Example</h3>\n<pre><code>use std::num::{NonZeroU32, NonZeroU64};\n\nfn example(x: u64, y: NonZeroU32) {\n    // Bad: Converting NonZeroU32 to u64 unnecessarily\n    let r1 = x / u64::from(y.get());\n    let r2 = x % u64::from(y.get());\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::num::{NonZeroU32, NonZeroU64};\n\nfn example(x: u64, y: NonZeroU32) {\n    // Good: Preserving the NonZero property\n    let r1 = x / NonZeroU64::from(y);\n    let r2 = x % NonZeroU64::from(y);\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "nonminimal_bool",
    "rule_name": "nonminimal_bool",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for boolean expressions that can be written more\nconcisely.</p>\n<h3>Why is this bad?</h3>\n<p>Readability of boolean expressions suffers from\nunnecessary duplication.</p>\n<h3>Known problems</h3>\n<p>Ignores short circuiting behavior of <code>||</code> and\n<code>&&</code>. Ignores <code>|</code>, <code>&</code> and <code>^</code>.</p>\n<h3>Example</h3>\n<pre><code>if a && true {}\nif !(a == b) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if a {}\nif a != b {}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "nonsensical_open_options",
    "rule_name": "nonsensical_open_options",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for duplicate open options as well as combinations\nthat make no sense.</p>\n<h3>Why is this bad?</h3>\n<p>In the best case, the code will be harder to read than\nnecessary. I don\u2019t know the worst case.</p>\n<h3>Example</h3>\n<pre><code>use std::fs::OpenOptions;\n\nOpenOptions::new().read(true).truncate(true);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "nonstandard_macro_braces",
    "rule_name": "nonstandard_macro_braces",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks that common macros are used with consistent bracing.</p>\n<h3>Why is this bad?</h3>\n<p>This is mostly a consistency lint although using () or []\ndoesn\u2019t give you a semicolon in item position, which can be unexpected.</p>\n<h3>Example</h3>\n<pre><code>vec!{1, 2, 3};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![1, 2, 3];\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li><code>standard-macro-braces</code>:  Enforce the named macros always use the braces specified.</li>\n</ul>\n<p>A <code>MacroMatcher</code> can be added like so <code>{ name = \"macro_name\", brace = \"(\" }</code>. If the macro\ncould be used with a full path two <code>MacroMatcher</code>s have to be added one with the full path\n<code>crate_name::macro_name</code> and one with just the macro name.</p>\n<p>(default: <code>[]</code>)</p>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "not_unsafe_ptr_arg_deref",
    "rule_name": "not_unsafe_ptr_arg_deref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for public functions that dereference raw pointer\narguments but are not marked <code>unsafe</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The function should almost definitely be marked <code>unsafe</code>, since for an\narbitrary raw pointer, there is no way of telling for sure if it is valid.</p>\n<p>In general, this lint should <strong>never be disabled</strong> unless it is definitely a\nfalse positive (please submit an issue if so) since it breaks Rust\u2019s\nsoundness guarantees, directly exposing API users to potentially dangerous\nprogram behavior. This is also true for internal APIs, as it is easy to leak\nunsoundness.</p>\n<h3>Context</h3>\n<p>In Rust, an <code>unsafe {...}</code> block is used to indicate that the code in that\nsection has been verified in some way that the compiler can not. For a\nfunction that accepts a raw pointer then accesses the pointer\u2019s data, this is\ngenerally impossible as the incoming pointer could point anywhere, valid or\nnot. So, the signature should be marked <code>unsafe fn</code>: this indicates that the\nfunction\u2019s caller must provide some verification that the arguments it sends\nare valid (and then call the function within an <code>unsafe</code> block).</p>\n<h3>Known problems</h3>\n<ul>\n<li>It does not check functions recursively so if the pointer is passed to a\nprivate non-<code>unsafe</code> function which does the dereferencing, the lint won\u2019t\ntrigger (false negative).</li>\n<li>It only checks for arguments whose type are raw pointers, not raw pointers\ngot from an argument in some other way (<code>fn foo(bar: &[*const u8])</code> or\n<code>some_argument.get_raw_ptr()</code>) (false negative).</li>\n</ul>\n<h3>Example</h3>\n<pre><code>pub fn foo(x: *const u8) {\n    println!(\"{}\", unsafe { *x });\n}\n\n// this call \"looks\" safe but will segfault or worse!\n// foo(invalid_ptr);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub unsafe fn foo(x: *const u8) {\n    println!(\"{}\", unsafe { *x });\n}\n\n// this would cause a compiler error for calling without `unsafe`\n// foo(invalid_ptr);\n\n// sound call if the caller knows the pointer is valid\nunsafe { foo(valid_ptr); }\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "obfuscated_if_else",
    "rule_name": "obfuscated_if_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.then_some(..).unwrap_or(..)</code></p>\n<h3>Why is this bad?</h3>\n<p>This can be written more clearly with <code>if .. else ..</code></p>\n<h3>Limitations</h3>\n<p>This lint currently only looks for usages of\n<code>.then_some(..).unwrap_or(..)</code>, but will be expanded\nto account for similar patterns.</p>\n<h3>Example</h3>\n<pre><code>let x = true;\nx.then_some(\"a\").unwrap_or(\"b\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = true;\nif x { \"a\" } else { \"b\" };\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "octal_escapes",
    "rule_name": "octal_escapes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>\\0</code> escapes in string and byte literals that look like octal\ncharacter escapes in C.</p>\n<h3>Why is this bad?</h3>\n<p>C and other languages support octal character escapes in strings, where\na backslash is followed by up to three octal digits. For example, <code>\\033</code>\nstands for the ASCII character 27 (ESC). Rust does not support this\nnotation, but has the escape code <code>\\0</code> which stands for a null\nbyte/character, and any following digits do not form part of the escape\nsequence. Therefore, <code>\\033</code> is not a compiler error but the result may\nbe surprising.</p>\n<h3>Known problems</h3>\n<p>The actual meaning can be the intended one. <code>\\x00</code> can be used in these\ncases to be unambiguous.</p>\n<p>The lint does not trigger for format strings in <code>print!()</code>, <code>write!()</code>\nand friends since the string is already preprocessed when Clippy lints\ncan see it.</p>\n<h3>Example</h3>\n<pre><code>let one = \"\\033[1m Bold? \\033[0m\";  // \\033 intended as escape\nlet two = \"\\033\\0\";                 // \\033 intended as null-3-3\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let one = \"\\x1b[1mWill this be bold?\\x1b[0m\";\nlet two = \"\\x0033\\x00\";\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "ok_expect",
    "rule_name": "ok_expect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>ok().expect(..)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Because you usually call <code>expect()</code> on the <code>Result</code>\ndirectly to get a better error message.</p>\n<h3>Known problems</h3>\n<p>The error type needs to implement <code>Debug</code></p>\n<h3>Example</h3>\n<pre><code>x.ok().expect(\"why did I do this again?\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>x.expect(\"why did I do this again?\");\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "only_used_in_recursion",
    "rule_name": "only_used_in_recursion",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for arguments that are only used in recursion with no side-effects.</p>\n<h3>Why is this bad?</h3>\n<p>It could contain a useless calculation and can make function simpler.</p>\n<p>The arguments can be involved in calculations and assignments but as long as\nthe calculations have no side-effects (function calls or mutating dereference)\nand the assigned variables are also only in recursion, it is useless.</p>\n<h3>Known problems</h3>\n<p>Too many code paths in the linting code are currently untested and prone to produce false\npositives or are prone to have performance implications.</p>\n<p>In some cases, this would not catch all useless arguments.</p>\n<pre><code>fn foo(a: usize, b: usize) -> usize {\n    let f = |x| x + 1;\n\n    if a == 0 {\n        1\n    } else {\n        foo(a - 1, f(b))\n    }\n}\n</code></pre>\n<p>For example, the argument <code>b</code> is only used in recursion, but the lint would not catch it.</p>\n<p>List of some examples that can not be caught:</p>\n<ul>\n<li>binary operation of non-primitive types</li>\n<li>closure usage</li>\n<li>some <code>break</code> relative operations</li>\n<li>struct pattern binding</li>\n</ul>\n<p>Also, when you recurse the function name with path segments, it is not possible to detect.</p>\n<h3>Example</h3>\n<pre><code>fn f(a: usize, b: usize) -> usize {\n    if a == 0 {\n        1\n    } else {\n        f(a - 1, b + 1)\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn f(a: usize) -> usize {\n    if a == 0 {\n        1\n    } else {\n        f(a - 1)\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "op_ref",
    "rule_name": "op_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for arguments to <code>==</code> which have their address\ntaken to satisfy a bound\nand suggests to dereference the other argument instead</p>\n<h3>Why is this bad?</h3>\n<p>It is more idiomatic to dereference the other argument.</p>\n<h3>Example</h3>\n<pre><code>&x == y\n</code></pre>\n<p>Use instead:</p>\n<pre><code>x == *y\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_as_ref_cloned",
    "rule_name": "option_as_ref_cloned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.as_ref().cloned()</code> and <code>.as_mut().cloned()</code> on <code>Option</code>s</p>\n<h3>Why is this bad?</h3>\n<p>This can be written more concisely by cloning the <code>Option</code> directly.</p>\n<h3>Example</h3>\n<pre><code>fn foo(bar: &Option<Vec<u8>>) -> Option<Vec<u8>> {\n    bar.as_ref().cloned()\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(bar: &Option<Vec<u8>>) -> Option<Vec<u8>> {\n    bar.clone()\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "option_as_ref_deref",
    "rule_name": "option_as_ref_deref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.as_ref().map(Deref::deref)</code> or its aliases (such as String::as_str).</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.as_deref()</code>.</p>\n<h3>Example</h3>\n<pre><code>opt.as_ref().map(String::as_str)\n</code></pre>\n<p>Can be written as</p>\n<pre><code>opt.as_deref()\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_env_unwrap",
    "rule_name": "option_env_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>option_env!(...).unwrap()</code> and\nsuggests usage of the <code>env!</code> macro.</p>\n<h3>Why is this bad?</h3>\n<p>Unwrapping the result of <code>option_env!</code> will panic\nat run-time if the environment variable doesn\u2019t exist, whereas <code>env!</code>\ncatches it at compile-time.</p>\n<h3>Example</h3>\n<pre><code>let _ = option_env!(\"HOME\").unwrap();\n</code></pre>\n<p>Is better expressed as:</p>\n<pre><code>let _ = env!(\"HOME\");\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "option_filter_map",
    "rule_name": "option_filter_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iterators of <code>Option</code>s using <code>.filter(Option::is_some).map(Option::unwrap)</code> that may\nbe replaced with a <code>.flatten()</code> call.</p>\n<h3>Why is this bad?</h3>\n<p><code>Option</code> is like a collection of 0-1 things, so <code>flatten</code>\nautomatically does this without suspicious-looking <code>unwrap</code> calls.</p>\n<h3>Example</h3>\n<pre><code>let _ = std::iter::empty::<Option<i32>>().filter(Option::is_some).map(Option::unwrap);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = std::iter::empty::<Option<i32>>().flatten();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_if_let_else",
    "rule_name": "option_if_let_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints usage of <code>if let Some(v) = ... { y } else { x }</code> and\n<code>match .. { Some(v) => y, None/_ => x }</code> which are more\nidiomatically done with <code>Option::map_or</code> (if the else bit is a pure\nexpression) or <code>Option::map_or_else</code> (if the else bit is an impure\nexpression).</p>\n<h3>Why is this bad?</h3>\n<p>Using the dedicated functions of the <code>Option</code> type is clearer and\nmore concise than an <code>if let</code> expression.</p>\n<h3>Notes</h3>\n<p>This lint uses a deliberately conservative metric for checking if the\ninside of either body contains loop control expressions <code>break</code> or\n<code>continue</code> (which cannot be used within closures). If these are found,\nthis lint will not be raised.</p>\n<h3>Example</h3>\n<pre><code>let _ = if let Some(foo) = optional {\n    foo\n} else {\n    5\n};\nlet _ = match optional {\n    Some(val) => val + 1,\n    None => 5\n};\nlet _ = if let Some(foo) = optional {\n    foo\n} else {\n    let y = do_complicated_function();\n    y*y\n};\n</code></pre>\n<p>should be</p>\n<pre><code>let _ = optional.map_or(5, |foo| foo);\nlet _ = optional.map_or(5, |val| val + 1);\nlet _ = optional.map_or_else(||{\n    let y = do_complicated_function();\n    y*y\n}, |foo| foo);\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "option_map_or_err_ok",
    "rule_name": "option_map_or_err_ok",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.map_or(Err(_), Ok)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.ok_or(_)</code>.</p>\n<h3>Example</h3>\n<pre><code>opt.map_or(Err(\"error\"), Ok);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>opt.ok_or(\"error\");\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_map_or_none",
    "rule_name": "option_map_or_none",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.map_or(None, _)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.and_then(_)</code>.</p>\n<h3>Known problems</h3>\n<p>The order of the arguments is not in execution order.</p>\n<h3>Example</h3>\n<pre><code>opt.map_or(None, |a| Some(a + 1));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>opt.and_then(|a| Some(a + 1));\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_map_unit_fn",
    "rule_name": "option_map_unit_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>option.map(f)</code> where f is a function\nor closure that returns the unit type <code>()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more clearly with\nan if let statement</p>\n<h3>Example</h3>\n<pre><code>let x: Option<String> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)));\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let x: Option<String> = do_stuff();\nif let Some(msg) = x {\n    log_err_msg(msg);\n}\n\nif let Some(msg) = x {\n    log_err_msg(format_msg(msg));\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "option_option",
    "rule_name": "option_option",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Option<Option<_>></code> in function signatures and type\ndefinitions</p>\n<h3>Why is this bad?</h3>\n<p><code>Option<_></code> represents an optional value. <code>Option<Option<_>></code>\nrepresents an optional value which itself wraps an optional. This is logically the\nsame thing as an optional value but has an unneeded extra level of wrapping.</p>\n<p>If you have a case where <code>Some(Some(_))</code>, <code>Some(None)</code> and <code>None</code> are distinct cases,\nconsider a custom <code>enum</code> instead, with clear names for each case.</p>\n<h3>Example</h3>\n<pre><code>fn get_data() -> Option<Option<u32>> {\n    None\n}\n</code></pre>\n<p>Better:</p>\n<pre><code>pub enum Contents {\n    Data(Vec<u8>), // Was Some(Some(Vec<u8>))\n    NotYetFetched, // Was Some(None)\n    None,          // Was None\n}\n\nfn get_data() -> Contents {\n    Contents::None\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "or_fun_call",
    "rule_name": "or_fun_call",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>.or(foo(..))</code>, <code>.unwrap_or(foo(..))</code>,\n<code>.or_insert(foo(..))</code> etc., and suggests to use <code>.or_else(|| foo(..))</code>,\n<code>.unwrap_or_else(|| foo(..))</code>, <code>.unwrap_or_default()</code> or <code>.or_default()</code>\netc. instead.</p>\n<h3>Why is this bad?</h3>\n<p>The function will always be called. This is only bad if it allocates or\ndoes some non-trivial amount of work.</p>\n<h3>Known problems</h3>\n<p>If the function has side-effects, not calling it will change the\nsemantic of the program, but you shouldn\u2019t rely on that.</p>\n<p>The lint also cannot figure out whether the function you call is\nactually expensive to call or not.</p>\n<h3>Example</h3>\n<pre><code>foo.unwrap_or(String::from(\"empty\"));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>foo.unwrap_or_else(|| String::from(\"empty\"));\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "or_then_unwrap",
    "rule_name": "or_then_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.or(\u2026).unwrap()</code> calls to Options and Results.</p>\n<h3>Why is this bad?</h3>\n<p>You should use <code>.unwrap_or(\u2026)</code> instead for clarity.</p>\n<h3>Example</h3>\n<pre><code>// Result\nlet value = result.or::<Error>(Ok(fallback)).unwrap();\n\n// Option\nlet value = option.or(Some(fallback)).unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Result\nlet value = result.unwrap_or(fallback);\n\n// Option\nlet value = option.unwrap_or(fallback);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "out_of_bounds_indexing",
    "rule_name": "out_of_bounds_indexing",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for out of bounds array indexing with a constant\nindex.</p>\n<h3>Why is this bad?</h3>\n<p>This will always panic at runtime.</p>\n<h3>Example</h3>\n<pre><code>let x = [1, 2, 3, 4];\n\nx[9];\n&x[2..9];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Index within bounds\n\nx[0];\nx[3];\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "overly_complex_bool_expr",
    "rule_name": "overly_complex_bool_expr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for boolean expressions that contain terminals that\ncan be eliminated.</p>\n<h3>Why is this bad?</h3>\n<p>This is most likely a logic bug.</p>\n<h3>Known problems</h3>\n<p>Ignores short circuiting behavior.</p>\n<h3>Example</h3>\n<pre><code>// The `b` is unnecessary, the expression is equivalent to `if a`.\nif a && b || a { ... }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if a {}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>logic_bug</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "panic",
    "rule_name": "panic",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>panic!</code>.</p>\n<h3>Why restrict this?</h3>\n<p>This macro, or panics in general, may be unwanted in production code.</p>\n<h3>Example</h3>\n<pre><code>panic!(\"even with a good reason\");\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-panic-in-tests</code>:  Whether <code>panic</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "panic_in_result_fn",
    "rule_name": "panic_in_result_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>panic!</code> or assertions in a function whose return type is <code>Result</code>.</p>\n<h3>Why restrict this?</h3>\n<p>For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.</p>\n<h3>Known problems</h3>\n<p>Functions called from a function returning a <code>Result</code> may invoke a panicking macro. This is not checked.</p>\n<h3>Example</h3>\n<pre><code>fn result_with_panic() -> Result<bool, String>\n{\n    panic!(\"error\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn result_without_panic() -> Result<bool, String> {\n    Err(String::from(\"error\"))\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "panicking_overflow_checks",
    "rule_name": "panicking_overflow_checks",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects C-style underflow/overflow checks.</p>\n<h3>Why is this bad?</h3>\n<p>These checks will, by default, panic in debug builds rather than check\nwhether the operation caused an overflow.</p>\n<h3>Example</h3>\n<pre><code>if a + b < a {\n    // handle overflow\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if a.checked_add(b).is_none() {\n    // handle overflow\n}\n</code></pre>\n<p>Or:</p>\n<pre><code>if a.overflowing_add(b).1 {\n    // handle overflow\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>overflow_check_conditional</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "panicking_unwrap",
    "rule_name": "panicking_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls of <code>unwrap[_err]()</code> that will always fail.</p>\n<h3>Why is this bad?</h3>\n<p>If panicking is desired, an explicit <code>panic!()</code> should be used.</p>\n<h3>Known problems</h3>\n<p>This lint only checks <code>if</code> conditions not assignments.\nSo something like <code>let x: Option<()> = None; x.unwrap();</code> will not be recognized.</p>\n<h3>Example</h3>\n<pre><code>if option.is_none() {\n    do_something_with(option.unwrap())\n}\n</code></pre>\n<p>This code will always panic. The if condition should probably be inverted.</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "partial_pub_fields",
    "rule_name": "partial_pub_fields",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks whether some but not all fields of a <code>struct</code> are public.</p>\n<p>Either make all fields of a type public, or make none of them public</p>\n<h3>Why restrict this?</h3>\n<p>Most types should either be:</p>\n<ul>\n<li>Abstract data types: complex objects with opaque implementation which guard\ninterior invariants and expose intentionally limited API to the outside world.</li>\n<li>Data:\u2009relatively simple objects which group a bunch of related attributes together,\nbut have no invariants.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>pub struct Color {\n    pub r: u8,\n    pub g: u8,\n    b: u8,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub struct Color {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "partialeq_ne_impl",
    "rule_name": "partialeq_ne_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for manual re-implementations of <code>PartialEq::ne</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>PartialEq::ne</code> is required to always return the\nnegated result of <code>PartialEq::eq</code>, which is exactly what the default\nimplementation does. Therefore, there should never be any need to\nre-implement it.</p>\n<h3>Example</h3>\n<pre><code>struct Foo;\n\nimpl PartialEq for Foo {\n   fn eq(&self, other: &Foo) -> bool { true }\n   fn ne(&self, other: &Foo) -> bool { !(self == other) }\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "partialeq_to_none",
    "rule_name": "partialeq_to_none",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for binary comparisons to a literal <code>Option::None</code>.</p>\n<h3>Why is this bad?</h3>\n<p>A programmer checking if some <code>foo</code> is <code>None</code> via a comparison <code>foo == None</code>\nis usually inspired from other programming languages (e.g. <code>foo is None</code>\nin Python).\nChecking if a value of type <code>Option<T></code> is (not) equal to <code>None</code> in that\nway relies on <code>T: PartialEq</code> to do the comparison, which is unneeded.</p>\n<h3>Example</h3>\n<pre><code>fn foo(f: Option<u32>) -> &'static str {\n    if f != None { \"yay\" } else { \"nay\" }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(f: Option<u32>) -> &'static str {\n    if f.is_some() { \"yay\" } else { \"nay\" }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "path_buf_push_overwrite",
    "rule_name": "path_buf_push_overwrite",
    "rule_description_html": "<div><h3>What it does</h3>\n<ul>\n<li>Checks for <a>push</a>\ncalls on <code>PathBuf</code> that can cause overwrites.</li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>Calling <code>push</code> with a root path at the start can overwrite the\nprevious defined path.</p>\n<h3>Example</h3>\n<pre><code>use std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"/bar\");\nassert_eq!(x, PathBuf::from(\"/bar\"));\n</code></pre>\n<p>Could be written:</p>\n<pre><code>use std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"bar\");\nassert_eq!(x, PathBuf::from(\"/foo/bar\"));\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "path_ends_with_ext",
    "rule_name": "path_ends_with_ext",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for calls to <code>Path::ends_with</code> calls where the argument looks like a file extension.</p>\n<p>By default, Clippy has a short list of known filenames that start with a dot\nbut aren\u2019t necessarily file extensions (e.g. the <code>.git</code> folder), which are allowed by default.\nThe <code>allowed-dotfiles</code> configuration can be used to allow additional\nfile extensions that Clippy should not lint.</p>\n<h3>Why is this bad?</h3>\n<p>This doesn\u2019t actually compare file extensions. Rather, <code>ends_with</code> compares the given argument\nto the last <strong>component</strong> of the path and checks if it matches exactly.</p>\n<h3>Known issues</h3>\n<p>File extensions are often at most three characters long, so this only lints in those cases\nin an attempt to avoid false positives.\nAny extension names longer than that are assumed to likely be real path components and are\ntherefore ignored.</p>\n<h3>Example</h3>\n<pre><code>fn is_markdown(path: &Path) -> bool {\n    path.ends_with(\".md\")\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn is_markdown(path: &Path) -> bool {\n    path.extension().is_some_and(|ext| ext == \"md\")\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allowed-dotfiles</code>:  Additional dotfiles (files or directories starting with a dot) to allow</p>\n<p>(default: <code>[]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "pathbuf_init_then_push",
    "rule_name": "pathbuf_init_then_push",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>push</code> immediately after creating a new <code>PathBuf</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Multiple <code>.join()</code> calls are usually easier to read than multiple <code>.push</code>\ncalls across multiple statements. It might also be possible to use\n<code>PathBuf::from</code> instead.</p>\n<h3>Known problems</h3>\n<p><code>.join()</code> introduces an implicit <code>clone()</code>. <code>PathBuf::from</code> can alternatively be\nused when the <code>PathBuf</code> is newly constructed. This will avoid the implicit clone.</p>\n<h3>Example</h3>\n<pre><code>let mut path_buf = PathBuf::new();\npath_buf.push(\"foo\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let path_buf = PathBuf::from(\"foo\");\n// or\nlet path_buf = PathBuf::new().join(\"foo\");\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "pattern_type_mismatch",
    "rule_name": "pattern_type_mismatch",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for patterns that aren\u2019t exact representations of the types\nthey are applied to.</p>\n<p>To satisfy this lint, you will have to adjust either the expression that is matched\nagainst or the pattern itself, as well as the bindings that are introduced by the\nadjusted patterns. For matching you will have to either dereference the expression\nwith the <code>*</code> operator, or amend the patterns to explicitly match against <code>&<pattern></code>\nor <code>&mut <pattern></code> depending on the reference mutability. For the bindings you need\nto use the inverse. You can leave them as plain bindings if you wish for the value\nto be copied, but you must use <code>ref mut <variable></code> or <code>ref <variable></code> to construct\na reference into the matched structure.</p>\n<p>If you are looking for a way to learn about ownership semantics in more detail, it\nis recommended to look at IDE options available to you to highlight types, lifetimes\nand reference semantics in your code. The available tooling would expose these things\nin a general way even outside of the various pattern matching mechanics. Of course\nthis lint can still be used to highlight areas of interest and ensure a good understanding\nof ownership semantics.</p>\n<h3>Why restrict this?</h3>\n<p>It increases ownership hints in the code, and will guard against some changes\nin ownership.</p>\n<h3>Example</h3>\n<p>This example shows the basic adjustments necessary to satisfy the lint. Note how\nthe matched expression is explicitly dereferenced with <code>*</code> and the <code>inner</code> variable\nis bound to a shared borrow via <code>ref inner</code>.</p>\n<pre><code>// Bad\nlet value = &Some(Box::new(23));\nmatch value {\n    Some(inner) => println!(\"{}\", inner),\n    None => println!(\"none\"),\n}\n\n// Good\nlet value = &Some(Box::new(23));\nmatch *value {\n    Some(ref inner) => println!(\"{}\", inner),\n    None => println!(\"none\"),\n}\n</code></pre>\n<p>The following example demonstrates one of the advantages of the more verbose style.\nNote how the second version uses <code>ref mut a</code> to explicitly declare <code>a</code> a shared mutable\nborrow, while <code>b</code> is simply taken by value. This ensures that the loop body cannot\naccidentally modify the wrong part of the structure.</p>\n<pre><code>// Bad\nlet mut values = vec![(2, 3), (3, 4)];\nfor (a, b) in &mut values {\n    *a += *b;\n}\n\n// Good\nlet mut values = vec![(2, 3), (3, 4)];\nfor &mut (ref mut a, b) in &mut values {\n    *a += b;\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "permissions_set_readonly_false",
    "rule_name": "permissions_set_readonly_false",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>std::fs::Permissions.set_readonly</code> with argument <code>false</code>.</p>\n<h3>Why is this bad?</h3>\n<p>On Unix platforms this results in the file being world writable,\nequivalent to <code>chmod a+w <file></code>.</p>\n<h3>Example</h3>\n<pre><code>use std::fs::File;\nlet f = File::create(\"foo.txt\").unwrap();\nlet metadata = f.metadata().unwrap();\nlet mut permissions = metadata.permissions();\npermissions.set_readonly(false);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "pointers_in_nomem_asm_block",
    "rule_name": "pointers_in_nomem_asm_block",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if any pointer is being passed to an asm! block with <code>nomem</code> option.</p>\n<h3>Why is this bad?</h3>\n<p><code>nomem</code> forbids any reads or writes to memory and passing a pointer suggests\nthat either of those will happen.</p>\n<h3>Example</h3>\n<pre><code>fn f(p: *mut u32) {\n    unsafe { core::arch::asm!(\"mov [{p}], 42\", p = in(reg) p, options(nomem, nostack)); }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn f(p: *mut u32) {\n    unsafe { core::arch::asm!(\"mov [{p}], 42\", p = in(reg) p, options(nostack)); }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "possible_missing_comma",
    "rule_name": "possible_missing_comma",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for possible missing comma in an array. It lints if\nan array element is a binary operator expression and it lies on two lines.</p>\n<h3>Why is this bad?</h3>\n<p>This could lead to unexpected results.</p>\n<h3>Example</h3>\n<pre><code>let a = &[\n    -1, -2, -3 // <= no comma here\n    -4, -5, -6\n];\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "precedence",
    "rule_name": "precedence",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for operations where precedence may be unclear\nand suggests to add parentheses. Currently it catches the following:</p>\n<ul>\n<li>mixed usage of arithmetic and bit shifting/combining operators without\nparentheses</li>\n<li>mixed usage of bitmasking and bit shifting operators without parentheses</li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>Not everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode.</p>\n<h3>Example</h3>\n<ul>\n<li><code>1 << 2 + 3</code> equals 32, while <code>(1 << 2) + 3</code> equals 7</li>\n<li><code>0x2345 & 0xF000 >> 12</code> equals 5, while <code>(0x2345 & 0xF000) >> 12</code> equals 2</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "print_in_format_impl",
    "rule_name": "print_in_format_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>println</code>, <code>print</code>, <code>eprintln</code> or <code>eprint</code> in an\nimplementation of a formatting trait.</p>\n<h3>Why is this bad?</h3>\n<p>Using a print macro is likely unintentional since formatting traits\nshould write to the <code>Formatter</code>, not stdout/stderr.</p>\n<h3>Example</h3>\n<pre><code>use std::fmt::{Display, Error, Formatter};\n\nstruct S;\nimpl Display for S {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        println!(\"S\");\n\n        Ok(())\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt::{Display, Error, Formatter};\n\nstruct S;\nimpl Display for S {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        writeln!(f, \"S\");\n\n        Ok(())\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "print_literal",
    "rule_name": "print_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns about the use of literals as <code>print!</code>/<code>println!</code> args.</p>\n<h3>Why is this bad?</h3>\n<p>Using literals as <code>println!</code> args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)</p>\n<h3>Example</h3>\n<pre><code>println!(\"{}\", \"foo\");\n</code></pre>\n<p>use the literal without formatting:</p>\n<pre><code>println!(\"foo\");\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "print_stderr",
    "rule_name": "print_stderr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for printing on <em>stderr</em>. The purpose of this lint\nis to catch debugging remnants.</p>\n<h3>Why restrict this?</h3>\n<p>People often print on <em>stderr</em> while debugging an\napplication and might forget to remove those prints afterward.</p>\n<h3>Known problems</h3>\n<p>Only catches <code>eprint!</code> and <code>eprintln!</code> calls.</p>\n<h3>Example</h3>\n<pre><code>eprintln!(\"Hello world!\");\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-print-in-tests</code>:  Whether print macros (ex. <code>println!</code>) should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "print_stdout",
    "rule_name": "print_stdout",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for printing on <em>stdout</em>. The purpose of this lint\nis to catch debugging remnants.</p>\n<h3>Why restrict this?</h3>\n<p>People often print on <em>stdout</em> while debugging an\napplication and might forget to remove those prints afterward.</p>\n<h3>Known problems</h3>\n<p>Only catches <code>print!</code> and <code>println!</code> calls.</p>\n<h3>Example</h3>\n<pre><code>println!(\"Hello world!\");\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-print-in-tests</code>:  Whether print macros (ex. <code>println!</code>) should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "print_with_newline",
    "rule_name": "print_with_newline",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns when you use <code>print!()</code> with a format\nstring that ends in a newline.</p>\n<h3>Why is this bad?</h3>\n<p>You should use <code>println!()</code> instead, which appends the\nnewline.</p>\n<h3>Example</h3>\n<pre><code>print!(\"Hello {}!\\n\", name);\n</code></pre>\n<p>use println!() instead</p>\n<pre><code>println!(\"Hello {}!\", name);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "println_empty_string",
    "rule_name": "println_empty_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns when you use <code>println!(\"\")</code> to\nprint a newline.</p>\n<h3>Why is this bad?</h3>\n<p>You should use <code>println!()</code>, which is simpler.</p>\n<h3>Example</h3>\n<pre><code>println!(\"\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "ptr_arg",
    "rule_name": "ptr_arg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for function arguments of type <code>&String</code>, <code>&Vec</code>,\n<code>&PathBuf</code>, and <code>Cow<_></code>. It will also suggest you replace <code>.clone()</code> calls\nwith the appropriate <code>.to_owned()</code>/<code>to_string()</code> calls.</p>\n<h3>Why is this bad?</h3>\n<p>Requiring the argument to be of the specific type\nmakes the function less useful for no benefit; slices in the form of <code>&[T]</code>\nor <code>&str</code> usually suffice and can be obtained from other types, too.</p>\n<h3>Known problems</h3>\n<p>There may be <code>fn(&Vec)</code>-typed references pointing to your function.\nIf you have them, you will get a compiler error after applying this lint\u2019s\nsuggestions. You then have the choice to undo your changes or change the\ntype of the reference.</p>\n<p>Note that if the function is part of your public interface, there may be\nother crates referencing it, of which you may not be aware. Carefully\ndeprecate the function before applying the lint suggestions in this case.</p>\n<h3>Example</h3>\n<pre><code>fn foo(&Vec<u32>) { .. }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(&[u32]) { .. }\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "ptr_as_ptr",
    "rule_name": "ptr_as_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>as</code> casts between raw pointers that don\u2019t change their\nconstness, namely <code>*const T</code> to <code>*const U</code> and <code>*mut T</code> to <code>*mut U</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Though <code>as</code> casts between raw pointers are not terrible,\n<code>pointer::cast</code> is safer because it cannot accidentally change the\npointer\u2019s mutability, nor cast the pointer to other types like <code>usize</code>.</p>\n<h3>Example</h3>\n<pre><code>let ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr as *const i32;\nlet _ = mut_ptr as *mut i32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr.cast::<i32>();\nlet _ = mut_ptr.cast::<i32>();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ptr_cast_constness",
    "rule_name": "ptr_cast_constness",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>as</code> casts between raw pointers that change their constness, namely <code>*const T</code> to\n<code>*mut T</code> and <code>*mut T</code> to <code>*const T</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Though <code>as</code> casts between raw pointers are not terrible, <code>pointer::cast_mut</code> and\n<code>pointer::cast_const</code> are safer because they cannot accidentally cast the pointer to another\ntype. Or, when null pointers are involved, <code>null()</code> and <code>null_mut()</code> can be used directly.</p>\n<h3>Example</h3>\n<pre><code>let ptr: *const u32 = &42_u32;\nlet mut_ptr = ptr as *mut u32;\nlet ptr = mut_ptr as *const u32;\nlet ptr1 = std::ptr::null::<u32>() as *mut u32;\nlet ptr2 = std::ptr::null_mut::<u32>() as *const u32;\nlet ptr3 = std::ptr::null::<u32>().cast_mut();\nlet ptr4 = std::ptr::null_mut::<u32>().cast_const();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let ptr: *const u32 = &42_u32;\nlet mut_ptr = ptr.cast_mut();\nlet ptr = mut_ptr.cast_const();\nlet ptr1 = std::ptr::null_mut::<u32>();\nlet ptr2 = std::ptr::null::<u32>();\nlet ptr3 = std::ptr::null_mut::<u32>();\nlet ptr4 = std::ptr::null::<u32>();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ptr_eq",
    "rule_name": "ptr_eq",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Use <code>std::ptr::eq</code> when applicable</p>\n<h3>Why is this bad?</h3>\n<p><code>ptr::eq</code> can be used to compare <code>&T</code> references\n(which coerce to <code>*const T</code> implicitly) by their address rather than\ncomparing the values they point to.</p>\n<h3>Example</h3>\n<pre><code>let a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(a as *const _ as usize == b as *const _ as usize);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(std::ptr::eq(a, b));\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "ptr_offset_with_cast",
    "rule_name": "ptr_offset_with_cast",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of the <code>offset</code> pointer method with a <code>usize</code> casted to an\n<code>isize</code>.</p>\n<h3>Why is this bad?</h3>\n<p>If we\u2019re always increasing the pointer address, we can avoid the numeric\ncast by using the <code>add</code> method instead.</p>\n<h3>Example</h3>\n<pre><code>let vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\n    ptr.offset(offset as isize);\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>let vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\n    ptr.add(offset);\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "pub_enum_variant_names",
    "rule_name": "pub_enum_variant_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>clippy::enum_variant_names</code> now covers this case via the <code>avoid-breaking-exported-api</code> config.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "pub_underscore_fields",
    "rule_name": "pub_underscore_fields",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks whether any field of the struct is prefixed with an <code>_</code> (underscore) and also marked\n<code>pub</code> (public)</p>\n<h3>Why is this bad?</h3>\n<p>Fields prefixed with an <code>_</code> are inferred as unused, which suggests it should not be marked\nas <code>pub</code>, because marking it as <code>pub</code> infers it will be used.</p>\n<h3>Example</h3>\n<pre><code>struct FileHandle {\n    pub _descriptor: usize,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct FileHandle {\n    _descriptor: usize,\n}\n</code></pre>\n<p>OR</p>\n<pre><code>struct FileHandle {\n    pub descriptor: usize,\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>pub-underscore-fields-behavior</code>:  Lint \u201cpublic\u201d fields in a struct that are prefixed with an underscore based on their\nexported visibility, or whether they are marked as \u201cpub\u201d.</p>\n<p>(default: <code>\"PubliclyExported\"</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "pub_use",
    "rule_name": "pub_use",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Restricts the usage of <code>pub use ...</code></p>\n<h3>Why restrict this?</h3>\n<p>A project may wish to limit <code>pub use</code> instances to prevent\nunintentional exports, or to encourage placing exported items directly in public modules.</p>\n<h3>Example</h3>\n<pre><code>pub mod outer {\n    mod inner {\n        pub struct Test {}\n    }\n    pub use inner::Test;\n}\n\nuse outer::Test;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub mod outer {\n    pub struct Test {}\n}\n\nuse outer::Test;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "pub_with_shorthand",
    "rule_name": "pub_with_shorthand",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>pub(<loc>)</code> with <code>in</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Consistency. Use it or don\u2019t, just be consistent about it.</p>\n<p>Also see the <code>pub_without_shorthand</code> lint for an alternative.</p>\n<h3>Example</h3>\n<pre><code>pub(super) type OptBox<T> = Option<Box<T>>;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub(in super) type OptBox<T> = Option<Box<T>>;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "pub_without_shorthand",
    "rule_name": "pub_without_shorthand",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>pub(<loc>)</code> without <code>in</code>.</p>\n<p>Note: As you cannot write a module\u2019s path in <code>pub(<loc>)</code>, this will only trigger on\n<code>pub(super)</code> and the like.</p>\n<h3>Why restrict this?</h3>\n<p>Consistency. Use it or don\u2019t, just be consistent about it.</p>\n<p>Also see the <code>pub_with_shorthand</code> lint for an alternative.</p>\n<h3>Example</h3>\n<pre><code>pub(in super) type OptBox<T> = Option<Box<T>>;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub(super) type OptBox<T> = Option<Box<T>>;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "question_mark",
    "rule_name": "question_mark",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions that could be replaced by the question mark operator.</p>\n<h3>Why is this bad?</h3>\n<p>Question mark usage is more idiomatic.</p>\n<h3>Example</h3>\n<pre><code>if option.is_none() {\n    return None;\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>option?;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "question_mark_used",
    "rule_name": "question_mark_used",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expressions that use the question mark operator and rejects them.</p>\n<h3>Why restrict this?</h3>\n<p>Sometimes code wants to avoid the question mark operator because for instance a local\nblock requires a macro to re-throw errors to attach additional information to the\nerror.</p>\n<h3>Example</h3>\n<pre><code>let result = expr?;\n</code></pre>\n<p>Could be written:</p>\n<pre><code>utility_macro!(expr);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "range_minus_one",
    "rule_name": "range_minus_one",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for inclusive ranges where 1 is subtracted from\nthe upper bound, e.g., <code>x..=(y-1)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The code is more readable with an exclusive range\nlike <code>x..y</code>.</p>\n<h3>Known problems</h3>\n<p>This will cause a warning that cannot be fixed if\nthe consumer of the range only accepts a specific range type, instead of\nthe generic <code>RangeBounds</code> trait\n(<a>#3307</a>).</p>\n<h3>Example</h3>\n<pre><code>for i in x..=(y-1) {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for i in x..y {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "range_plus_one",
    "rule_name": "range_plus_one",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for exclusive ranges where 1 is added to the\nupper bound, e.g., <code>x..(y+1)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The code is more readable with an inclusive range\nlike <code>x..=y</code>.</p>\n<h3>Known problems</h3>\n<p>Will add unnecessary pair of parentheses when the\nexpression is not wrapped in a pair but starts with an opening parenthesis\nand ends with a closing one.\nI.e., <code>let _ = (f()+1)..(f()+1)</code> results in <code>let _ = ((f()+1)..=f())</code>.</p>\n<p>Also in many cases, inclusive ranges are still slower to run than\nexclusive ranges, because they essentially add an extra branch that\nLLVM may fail to hoist out of the loop.</p>\n<p>This will cause a warning that cannot be fixed if the consumer of the\nrange only accepts a specific range type, instead of the generic\n<code>RangeBounds</code> trait\n(<a>#3307</a>).</p>\n<h3>Example</h3>\n<pre><code>for i in x..(y+1) {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for i in x..=y {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "range_step_by_zero",
    "rule_name": "range_step_by_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>Iterator::step_by(0)</code> now panics and is no longer an infinite iterator.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "range_zip_with_len",
    "rule_name": "range_zip_with_len",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for zipping a collection with the range of\n<code>0.._.len()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The code is better expressed with <code>.enumerate()</code>.</p>\n<h3>Example</h3>\n<pre><code>let _ = x.iter().zip(0..x.len());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = x.iter().enumerate();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "rc_buffer",
    "rule_name": "rc_buffer",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Rc<T></code> and <code>Arc<T></code> when <code>T</code> is a mutable buffer type such as <code>String</code> or <code>Vec</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Expressions such as <code>Rc<String></code> usually have no advantage over <code>Rc<str></code>, since\nit is larger and involves an extra level of indirection, and doesn\u2019t implement <code>Borrow<str></code>.</p>\n<p>While mutating a buffer type would still be possible with <code>Rc::get_mut()</code>, it only\nworks if there are no additional references yet, which usually defeats the purpose of\nenclosing it in a shared ownership type. Instead, additionally wrapping the inner\ntype with an interior mutable container (such as <code>RefCell</code> or <code>Mutex</code>) would normally\nbe used.</p>\n<h3>Known problems</h3>\n<p>This pattern can be desirable to avoid the overhead of a <code>RefCell</code> or <code>Mutex</code> for\ncases where mutation only happens before there are any additional references.</p>\n<h3>Example</h3>\n<pre><code>fn foo(interned: Rc<String>) { ... }\n</code></pre>\n<p>Better:</p>\n<pre><code>fn foo(interned: Rc<str>) { ... }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "rc_clone_in_vec_init",
    "rule_name": "rc_clone_in_vec_init",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for reference-counted pointers (<code>Arc</code>, <code>Rc</code>, <code>rc::Weak</code>, and <code>sync::Weak</code>)\nin <code>vec![elem; len]</code></p>\n<h3>Why is this bad?</h3>\n<p>This will create <code>elem</code> once and clone it <code>len</code> times - doing so with <code>Arc</code>/<code>Rc</code>/<code>Weak</code>\nis a bit misleading, as it will create references to the same pointer, rather\nthan different instances.</p>\n<h3>Example</h3>\n<pre><code>let v = vec![std::sync::Arc::new(\"some data\".to_string()); 100];\n// or\nlet v = vec![std::rc::Rc::new(\"some data\".to_string()); 100];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// Initialize each value separately:\nlet mut data = Vec::with_capacity(100);\nfor _ in 0..100 {\n    data.push(std::rc::Rc::new(\"some data\".to_string()));\n}\n\n// Or if you want clones of the same reference,\n// Create the reference beforehand to clarify that\n// it should be cloned for each value\nlet data = std::rc::Rc::new(\"some data\".to_string());\nlet v = vec![data; 100];\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "rc_mutex",
    "rule_name": "rc_mutex",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Rc<Mutex<T>></code>.</p>\n<h3>Why restrict this?</h3>\n<p><code>Rc</code> is used in single thread and <code>Mutex</code> is used in multi thread.\nConsider using <code>Rc<RefCell<T>></code> in single thread or <code>Arc<Mutex<T>></code> in multi thread.</p>\n<h3>Known problems</h3>\n<p>Sometimes combining generic types can lead to the requirement that a\ntype use Rc in conjunction with Mutex. We must consider those cases false positives, but\nalas they are quite hard to rule out. Luckily they are also rare.</p>\n<h3>Example</h3>\n<pre><code>use std::rc::Rc;\nuse std::sync::Mutex;\nfn foo(interned: Rc<Mutex<i32>>) { ... }\n</code></pre>\n<p>Better:</p>\n<pre><code>use std::rc::Rc;\nuse std::cell::RefCell\nfn foo(interned: Rc<RefCell<i32>>) { ... }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "read_line_without_trim",
    "rule_name": "read_line_without_trim",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for calls to [<code>Stdin::read_line</code>] to read a line from the standard input\ninto a string, then later attempting to use that string for an operation that will never\nwork for strings with a trailing newline character in it (e.g. parsing into a <code>i32</code>).</p>\n<h3>Why is this bad?</h3>\n<p>The operation will always fail at runtime no matter what the user enters, thus\nmaking it a useless operation.</p>\n<h3>Example</h3>\n<pre><code>let mut input = String::new();\nstd::io::stdin().read_line(&mut input).expect(\"Failed to read a line\");\nlet num: i32 = input.parse().expect(\"Not a number!\");\nassert_eq!(num, 42); // we never even get here!\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut input = String::new();\nstd::io::stdin().read_line(&mut input).expect(\"Failed to read a line\");\nlet num: i32 = input.trim_end().parse().expect(\"Not a number!\");\n//                  ^^^^^^^^^^^ remove the trailing newline\nassert_eq!(num, 42);\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "read_zero_byte_vec",
    "rule_name": "read_zero_byte_vec",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint catches reads into a zero-length <code>Vec</code>.\nEspecially in the case of a call to <code>with_capacity</code>, this lint warns that read\ngets the number of bytes from the <code>Vec</code>\u2019s length, not its capacity.</p>\n<h3>Why is this bad?</h3>\n<p>Reading zero bytes is almost certainly not the intended behavior.</p>\n<h3>Known problems</h3>\n<p>In theory, a very unusual read implementation could assign some semantic meaning\nto zero-byte reads. But it seems exceptionally unlikely that code intending to do\na zero-byte read would allocate a <code>Vec</code> for it.</p>\n<h3>Example</h3>\n<pre><code>use std::io;\nfn foo<F: io::Read>(mut f: F) {\n    let mut data = Vec::with_capacity(100);\n    f.read(&mut data).unwrap();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::io;\nfn foo<F: io::Read>(mut f: F) {\n    let mut data = Vec::with_capacity(100);\n    data.resize(100, 0);\n    f.read(&mut data).unwrap();\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "readonly_write_lock",
    "rule_name": "readonly_write_lock",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for calls to <code>RwLock::write</code> where the lock is only used for reading.</p>\n<h3>Why is this bad?</h3>\n<p>The write portion of <code>RwLock</code> is exclusive, meaning that no other thread\ncan access the lock while this writer is active.</p>\n<h3>Example</h3>\n<pre><code>use std::sync::RwLock;\nfn assert_is_zero(lock: &RwLock<i32>) {\n    let num = lock.write().unwrap();\n    assert_eq!(*num, 0);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::sync::RwLock;\nfn assert_is_zero(lock: &RwLock<i32>) {\n    let num = lock.read().unwrap();\n    assert_eq!(*num, 0);\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "recursive_format_impl",
    "rule_name": "recursive_format_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for format trait implementations (e.g. <code>Display</code>) with a recursive call to itself\nwhich uses <code>self</code> as a parameter.\nThis is typically done indirectly with the <code>write!</code> macro or with <code>to_string()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This will lead to infinite recursion and a stack overflow.</p>\n<h3>Example</h3>\n<pre><code>use std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.to_string())\n    }\n}\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>to_string_in_display</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "redundant_allocation",
    "rule_name": "redundant_allocation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of redundant allocations anywhere in the code.</p>\n<h3>Why is this bad?</h3>\n<p>Expressions such as <code>Rc<&T></code>, <code>Rc<Rc<T>></code>, <code>Rc<Arc<T>></code>, <code>Rc<Box<T>></code>, <code>Arc<&T></code>, <code>Arc<Rc<T>></code>,\n<code>Arc<Arc<T>></code>, <code>Arc<Box<T>></code>, <code>Box<&T></code>, <code>Box<Rc<T>></code>, <code>Box<Arc<T>></code>, <code>Box<Box<T>></code>, add an unnecessary level of indirection.</p>\n<h3>Example</h3>\n<pre><code>fn foo(bar: Rc<&usize>) {}\n</code></pre>\n<p>Better:</p>\n<pre><code>fn foo(bar: &usize) {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_as_str",
    "rule_name": "redundant_as_str",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>as_str()</code> on a <code>String</code> chained with a method available on the <code>String</code> itself.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>as_str()</code> conversion is pointless and can be removed for simplicity and cleanliness.</p>\n<h3>Example</h3>\n<pre><code>let owned_string = \"This is a string\".to_owned();\nowned_string.as_str().as_bytes()\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let owned_string = \"This is a string\".to_owned();\nowned_string.as_bytes()\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_async_block",
    "rule_name": "redundant_async_block",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>async</code> block that only returns <code>await</code> on a future.</p>\n<h3>Why is this bad?</h3>\n<p>It is simpler and more efficient to use the future directly.</p>\n<h3>Example</h3>\n<pre><code>let f = async {\n   1 + 2\n};\nlet fut = async {\n    f.await\n};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let f = async {\n   1 + 2\n};\nlet fut = f;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_at_rest_pattern",
    "rule_name": "redundant_at_rest_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>[all @ ..]</code> patterns.</p>\n<h3>Why is this bad?</h3>\n<p>In all cases, <code>all</code> works fine and can often make code simpler, as you possibly won\u2019t need\nto convert from say a <code>Vec</code> to a slice by dereferencing.</p>\n<h3>Example</h3>\n<pre><code>if let [all @ ..] = &*v {\n    // NOTE: Type is a slice here\n    println!(\"all elements: {all:#?}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if let all = v {\n    // NOTE: Type is a `Vec` here\n    println!(\"all elements: {all:#?}\");\n}\n// or\nprintln!(\"all elements: {v:#?}\");\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_clone",
    "rule_name": "redundant_clone",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a redundant <code>clone()</code> (and its relatives) which clones an owned\nvalue that is going to be dropped without further use.</p>\n<h3>Why is this bad?</h3>\n<p>It is not always possible for the compiler to eliminate useless\nallocations and deallocations generated by redundant <code>clone()</code>s.</p>\n<h3>Known problems</h3>\n<p>False-negatives: analysis performed by this lint is conservative and limited.</p>\n<h3>Example</h3>\n<pre><code>{\n    let x = Foo::new();\n    call(x.clone());\n    call(x.clone()); // this can just pass `x`\n}\n\n[\"lorem\", \"ipsum\"].join(\" \").to_string();\n\nPath::new(\"/a/b\").join(\"c\").to_path_buf();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "redundant_closure",
    "rule_name": "redundant_closure",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for closures which just call another function where\nthe function can be called directly. <code>unsafe</code> functions, calls where types\nget adjusted or where the callee is marked <code>#[track_caller]</code> are ignored.</p>\n<h3>Why is this bad?</h3>\n<p>Needlessly creating a closure adds code for no benefit\nand gives the optimizer more work.</p>\n<h3>Known problems</h3>\n<p>If creating the closure inside the closure has a side-\neffect then moving the closure creation out will change when that side-\neffect runs.\nSee <a>#1439</a> for more details.</p>\n<h3>Example</h3>\n<pre><code>xs.map(|x| foo(x))\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// where `foo(_)` is a plain function that takes the exact argument type of `x`.\nxs.map(foo)\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_closure_call",
    "rule_name": "redundant_closure_call",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects closures called in the same expression where they\nare defined.</p>\n<h3>Why is this bad?</h3>\n<p>It is unnecessarily adding to the expression\u2019s\ncomplexity.</p>\n<h3>Example</h3>\n<pre><code>let a = (|| 42)();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = 42;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_closure_for_method_calls",
    "rule_name": "redundant_closure_for_method_calls",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for closures which only invoke a method on the closure\nargument and can be replaced by referencing the method directly.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s unnecessary to create the closure.</p>\n<h3>Example</h3>\n<pre><code>Some('a').map(|s| s.to_uppercase());\n</code></pre>\n<p>may be rewritten as</p>\n<pre><code>Some('a').map(char::to_uppercase);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "redundant_comparisons",
    "rule_name": "redundant_comparisons",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for ineffective double comparisons against constants.</p>\n<h3>Why is this bad?</h3>\n<p>Only one of the comparisons has any effect on the result, the programmer\nprobably intended to flip one of the comparison operators, or compare a\ndifferent value entirely.</p>\n<h3>Example</h3>\n<pre><code>if status_code <= 400 && status_code < 500 {}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "redundant_else",
    "rule_name": "redundant_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>else</code> blocks that can be removed without changing semantics.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>else</code> block adds unnecessary indentation and verbosity.</p>\n<h3>Known problems</h3>\n<p>Some may prefer to keep the <code>else</code> block for clarity.</p>\n<h3>Example</h3>\n<pre><code>fn my_func(count: u32) {\n    if count == 0 {\n        print!(\"Nothing to do\");\n        return;\n    } else {\n        print!(\"Moving on...\");\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn my_func(count: u32) {\n    if count == 0 {\n        print!(\"Nothing to do\");\n        return;\n    }\n    print!(\"Moving on...\");\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "redundant_feature_names",
    "rule_name": "redundant_feature_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for feature names with prefix <code>use-</code>, <code>with-</code> or suffix <code>-support</code></p>\n<h3>Why is this bad?</h3>\n<p>These prefixes and suffixes have no significant meaning.</p>\n<h3>Example</h3>\n<pre><code>[features]\ndefault = [\"use-abc\", \"with-def\", \"ghi-support\"]\nuse-abc = []  // redundant\nwith-def = []   // redundant\nghi-support = []   // redundant\n</code></pre>\n<p>Use instead:</p>\n<pre><code>[features]\ndefault = [\"abc\", \"def\", \"ghi\"]\nabc = []\ndef = []\nghi = []\n</code></pre>\n</div>",
    "lint_group": "cargo",
    "lint_level": "allow"
  },
  {
    "rule_id": "redundant_field_names",
    "rule_name": "redundant_field_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for fields in struct literals where shorthands\ncould be used.</p>\n<h3>Why is this bad?</h3>\n<p>If the field and variable names are the same,\nthe field name is redundant.</p>\n<h3>Example</h3>\n<pre><code>let bar: u8 = 123;\n\nstruct Foo {\n    bar: u8,\n}\n\nlet foo = Foo { bar: bar };\n</code></pre>\n<p>the last line can be simplified to</p>\n<pre><code>let foo = Foo { bar };\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_guards",
    "rule_name": "redundant_guards",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary guards in match expressions.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more complex and much less readable. Making it part of the pattern can improve\nexhaustiveness checking as well.</p>\n<h3>Example</h3>\n<pre><code>match x {\n    Some(x) if matches!(x, Some(1)) => ..,\n    Some(x) if x == Some(2) => ..,\n    _ => todo!(),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match x {\n    Some(Some(1)) => ..,\n    Some(Some(2)) => ..,\n    _ => todo!(),\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_locals",
    "rule_name": "redundant_locals",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for redundant redefinitions of local bindings.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant redefinitions of local bindings do not change behavior and are likely to be unintended.</p>\n<p>Note that although these bindings do not affect your code\u2019s meaning, they <em>may</em> affect <code>rustc</code>\u2019s stack allocation.</p>\n<h3>Example</h3>\n<pre><code>let a = 0;\nlet a = a;\n\nfn foo(b: i32) {\n   let b = b;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = 0;\n// no redefinition with the same name\n\nfn foo(b: i32) {\n  // no redefinition with the same name\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "redundant_pattern",
    "rule_name": "redundant_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for patterns in the form <code>name @ _</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s almost always more readable to just use direct\nbindings.</p>\n<h3>Example</h3>\n<pre><code>match v {\n    Some(x) => (),\n    y @ _ => (),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match v {\n    Some(x) => (),\n    y => (),\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_pattern_matching",
    "rule_name": "redundant_pattern_matching",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lint for redundant pattern matching over <code>Result</code>, <code>Option</code>,\n<code>std::task::Poll</code>, <code>std::net::IpAddr</code> or <code>bool</code>s</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s more concise and clear to just use the proper\nutility function or using the condition directly</p>\n<h3>Known problems</h3>\n<p>For suggestions involving bindings in patterns, this will change the drop order for the matched type.\nBoth <code>if let</code> and <code>while let</code> will drop the value at the end of the block, both <code>if</code> and <code>while</code> will drop the\nvalue before entering the block. For most types this change will not matter, but for a few\ntypes this will not be an acceptable change (e.g. locks). See the\n<a>reference</a> for more about\ndrop order.</p>\n<h3>Example</h3>\n<pre><code>if let Ok(_) = Ok::<i32, i32>(42) {}\nif let Err(_) = Err::<i32, i32>(42) {}\nif let None = None::<()> {}\nif let Some(_) = Some(42) {}\nif let Poll::Pending = Poll::Pending::<()> {}\nif let Poll::Ready(_) = Poll::Ready(42) {}\nif let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\nif let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\nmatch Ok::<i32, i32>(42) {\n    Ok(_) => true,\n    Err(_) => false,\n};\n\nlet cond = true;\nif let true = cond {}\nmatches!(cond, true);\n</code></pre>\n<p>The more idiomatic use would be:</p>\n<pre><code>if Ok::<i32, i32>(42).is_ok() {}\nif Err::<i32, i32>(42).is_err() {}\nif None::<()>.is_none() {}\nif Some(42).is_some() {}\nif Poll::Pending::<()>.is_pending() {}\nif Poll::Ready(42).is_ready() {}\nif IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\nif IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\nOk::<i32, i32>(42).is_ok();\n\nlet cond = true;\nif cond {}\ncond;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>if_let_redundant_pattern_matching</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_pub_crate",
    "rule_name": "redundant_pub_crate",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items declared <code>pub(crate)</code> that are not crate visible because they\nare inside a private module.</p>\n<h3>Why is this bad?</h3>\n<p>Writing <code>pub(crate)</code> is misleading when it\u2019s redundant due to the parent\nmodule\u2019s visibility.</p>\n<h3>Example</h3>\n<pre><code>mod internal {\n    pub(crate) fn internal_fn() { }\n}\n</code></pre>\n<p>This function is not visible outside the module and it can be declared with <code>pub</code> or\nprivate visibility</p>\n<pre><code>mod internal {\n    pub fn internal_fn() { }\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "redundant_slicing",
    "rule_name": "redundant_slicing",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for redundant slicing expressions which use the full range, and\ndo not change the type.</p>\n<h3>Why is this bad?</h3>\n<p>It unnecessarily adds complexity to the expression.</p>\n<h3>Known problems</h3>\n<p>If the type being sliced has an implementation of <code>Index<RangeFull></code>\nthat actually changes anything then it can\u2019t be removed. However, this would be surprising\nto people reading the code and should have a note with it.</p>\n<h3>Example</h3>\n<pre><code>fn get_slice(x: &[u32]) -> &[u32] {\n    &x[..]\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn get_slice(x: &[u32]) -> &[u32] {\n    x\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_static_lifetimes",
    "rule_name": "redundant_static_lifetimes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for constants and statics with an explicit <code>'static</code> lifetime.</p>\n<h3>Why is this bad?</h3>\n<p>Adding <code>'static</code> to every reference can create very\ncomplicated types.</p>\n<h3>Example</h3>\n<pre><code>const FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\nstatic FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\n</code></pre>\n<p>This code can be rewritten as</p>\n<pre><code> const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n static FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>const_static_lifetime</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "redundant_type_annotations",
    "rule_name": "redundant_type_annotations",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns about needless / redundant type annotations.</p>\n<h3>Why restrict this?</h3>\n<p>Code without type annotations is shorter and in most cases\nmore idiomatic and easier to modify.</p>\n<h3>Limitations</h3>\n<p>This lint doesn\u2019t support:</p>\n<ul>\n<li>Generics</li>\n<li>Refs returned from anything else than a <code>MethodCall</code></li>\n<li>Complex types (tuples, arrays, etc\u2026)</li>\n<li><code>Path</code> to anything else than a primitive type.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let foo: String = String::new();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let foo = String::new();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "ref_as_ptr",
    "rule_name": "ref_as_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts of references to pointer using <code>as</code>\nand suggests <code>std::ptr::from_ref</code> and <code>std::ptr::from_mut</code> instead.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>as</code> casts may result in silently changing mutability or type.</p>\n<h3>Example</h3>\n<pre><code>let a_ref = &1;\nlet a_ptr = a_ref as *const _;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a_ref = &1;\nlet a_ptr = std::ptr::from_ref(a_ref);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ref_binding_to_reference",
    "rule_name": "ref_binding_to_reference",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>ref</code> bindings which create a reference to a reference.</p>\n<h3>Why is this bad?</h3>\n<p>The address-of operator at the use site is clearer about the need for a reference.</p>\n<h3>Example</h3>\n<pre><code>let x = Some(\"\");\nif let Some(ref x) = x {\n    // use `x` here\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = Some(\"\");\nif let Some(x) = x {\n    // use `&x` here\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ref_option",
    "rule_name": "ref_option",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns when a function signature uses <code>&Option<T></code> instead of <code>Option<&T></code>.</p>\n<h3>Why is this bad?</h3>\n<p>More flexibility, better memory optimization, and more idiomatic Rust code.</p>\n<p><code>&Option<T></code> in a function signature breaks encapsulation because the caller must own T\nand move it into an Option to call with it. When returned, the owner must internally store\nit as <code>Option<T></code> in order to return it.\nAt a lower level, <code>&Option<T></code> points to memory with the <code>presence</code> bit flag plus the <code>T</code> value,\nwhereas <code>Option<&T></code> is usually <a>optimized</a>\nto a single pointer, so it may be more optimal.</p>\n<p>See this <a>YouTube video</a> by\nLogan Smith for an in-depth explanation of why this is important.</p>\n<h3>Known problems</h3>\n<p>This lint recommends changing the function signatures, but it cannot\nautomatically change the function calls or the function implementations.</p>\n<h3>Example</h3>\n<pre><code>// caller uses  foo(&opt)\nfn foo(a: &Option<String>) {}\nfn bar(&self) -> &Option<String> { &None }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// caller should use  `foo1(opt.as_ref())`\nfn foo1(a: Option<&String>) {}\n// better yet, use string slice  `foo2(opt.as_deref())`\nfn foo2(a: Option<&str>) {}\nfn bar(&self) -> Option<&String> { None }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ref_option_ref",
    "rule_name": "ref_option_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>&Option<&T></code>.</p>\n<h3>Why is this bad?</h3>\n<p>Since <code>&</code> is Copy, it\u2019s useless to have a\nreference on <code>Option<&T></code>.</p>\n<h3>Known problems</h3>\n<p>It may be irrelevant to use this lint on\npublic API code as it will make a breaking change to apply it.</p>\n<h3>Example</h3>\n<pre><code>let x: &Option<&u32> = &Some(&0u32);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Option<&u32> = Some(&0u32);\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "ref_patterns",
    "rule_name": "ref_patterns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usages of the <code>ref</code> keyword.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>ref</code> keyword can be confusing for people unfamiliar with it, and often\nit is more concise to use <code>&</code> instead.</p>\n<h3>Example</h3>\n<pre><code>let opt = Some(5);\nif let Some(ref foo) = opt {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let opt = Some(5);\nif let Some(foo) = &opt {}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "regex_creation_in_loops",
    "rule_name": "regex_creation_in_loops",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <a>regex</a> compilation inside a loop with a literal.</p>\n<h3>Why is this bad?</h3>\n<p>Compiling a regex is a much more expensive operation than using one, and a compiled regex can be used multiple times.\nThis is documented as an antipattern <a>on the regex documentation</a></p>\n<h3>Example</h3>\n<pre><code>for haystack in haystacks {\n    let regex = regex::Regex::new(MY_REGEX).unwrap();\n    if regex.is_match(haystack) {\n        // Perform operation\n    }\n}\n</code></pre>\n<p>can be replaced with</p>\n<pre><code>let regex = regex::Regex::new(MY_REGEX).unwrap();\nfor haystack in haystacks {\n    if regex.is_match(haystack) {\n        // Perform operation\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "regex_macro",
    "rule_name": "regex_macro",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p>The <code>regex!</code> macro was removed from the regex crate in 2018.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "renamed_function_params",
    "rule_name": "renamed_function_params",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints when the name of function parameters from trait impl is\ndifferent than its default implementation.</p>\n<h3>Why restrict this?</h3>\n<p>Using the default name for parameters of a trait method is more consistent.</p>\n<h3>Example</h3>\n<pre><code>struct A(u32);\n\nimpl PartialEq for A {\n    fn eq(&self, b: &Self) -> bool {\n        self.0 == b.0\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct A(u32);\n\nimpl PartialEq for A {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li><code>allow-renamed-params-for</code>:  List of trait paths to ignore when checking renamed function parameters.</li>\n</ul>\n<h4>Example</h4>\n<pre><code>allow-renamed-params-for = [ \"std::convert::From\" ]\n</code></pre>\n<h4>Noteworthy</h4>\n<ul>\n<li>\n<p>By default, the following traits are ignored: <code>From</code>, <code>TryFrom</code>, <code>FromStr</code></p>\n</li>\n<li>\n<p><code>\"..\"</code> can be used as part of the list to indicate that the configured values should be appended to the\ndefault configuration of Clippy. By default, any configuration will replace the default value.</p>\n<p>(default: <code>[\"core::convert::From\", \"core::convert::TryFrom\", \"core::str::FromStr\"]</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "repeat_once",
    "rule_name": "repeat_once",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.repeat(1)</code> and suggest the following method for each types.</p>\n<ul>\n<li><code>.to_string()</code> for <code>str</code></li>\n<li><code>.clone()</code> for <code>String</code></li>\n<li><code>.to_vec()</code> for <code>slice</code></li>\n</ul>\n<p>The lint will evaluate constant expressions and values as arguments of <code>.repeat(..)</code> and emit a message if\nthey are equivalent to <code>1</code>. (Related discussion in <a>rust-clippy#7306</a>)</p>\n<h3>Why is this bad?</h3>\n<p>For example, <code>String.repeat(1)</code> is equivalent to <code>.clone()</code>. If cloning\nthe string is the intention behind this, <code>clone()</code> should be used.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    let x = String::from(\"hello world\").repeat(1);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    let x = String::from(\"hello world\").clone();\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "repeat_vec_with_capacity",
    "rule_name": "repeat_vec_with_capacity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for patterns such as <code>vec![Vec::with_capacity(x); n]</code> or <code>iter::repeat(Vec::with_capacity(x))</code>.</p>\n<h3>Why is this bad?</h3>\n<p>These constructs work by cloning the element, but cloning a <code>Vec<_></code> does not\nrespect the old vector\u2019s capacity and effectively discards it.</p>\n<p>This makes <code>iter::repeat(Vec::with_capacity(x))</code> especially suspicious because the user most certainly\nexpected that the yielded <code>Vec<_></code> will have the requested capacity, otherwise one can simply write\n<code>iter::repeat(Vec::new())</code> instead and it will have the same effect.</p>\n<p>Similarly for <code>vec![x; n]</code>, the element <code>x</code> is cloned to fill the vec.\nUnlike <code>iter::repeat</code> however, the vec repeat macro does not have to clone the value <code>n</code> times\nbut just <code>n - 1</code> times, because it can reuse the passed value for the last slot.\nThat means that the last <code>Vec<_></code> gets the requested capacity but all other ones do not.</p>\n<h3>Example</h3>\n<pre><code>\nlet _: Vec<Vec<u8>> = vec![Vec::with_capacity(42); 123];\nlet _: Vec<Vec<u8>> = iter::repeat(Vec::with_capacity(42)).take(123).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\nlet _: Vec<Vec<u8>> = iter::repeat_with(|| Vec::with_capacity(42)).take(123).collect();\n//                                      ^^^ this closure executes 123 times\n//                                          and the vecs will have the expected capacity\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "replace_consts",
    "rule_name": "replace_consts",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>min_value</code> and <code>max_value</code> are now deprecated.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "repr_packed_without_abi",
    "rule_name": "repr_packed_without_abi",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for items with <code>#[repr(packed)]</code>-attribute without ABI qualification</p>\n<h3>Why is this bad?</h3>\n<p>Without qualification, <code>repr(packed)</code> implies <code>repr(Rust)</code>. The Rust-ABI is inherently unstable.\nWhile this is fine as long as the type is accessed correctly within Rust-code, most uses\nof <code>#[repr(packed)]</code> involve FFI and/or data structures specified by network-protocols or\nother external specifications. In such situations, the unstable Rust-ABI implied in\n<code>#[repr(packed)]</code> may lead to future bugs should the Rust-ABI change.</p>\n<p>In case you are relying on a well defined and stable memory layout, qualify the type\u2019s\nrepresentation using the <code>C</code>-ABI. Otherwise, if the type in question is only ever\naccessed from Rust-code according to Rust\u2019s rules, use the <code>Rust</code>-ABI explicitly.</p>\n<h3>Example</h3>\n<pre><code>#[repr(packed)]\nstruct NetworkPacketHeader {\n    header_length: u8,\n    header_version: u16\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[repr(C, packed)]\nstruct NetworkPacketHeader {\n    header_length: u8,\n    header_version: u16\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "reserve_after_initialization",
    "rule_name": "reserve_after_initialization",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Informs the user about a more concise way to create a vector with a known capacity.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>Vec::with_capacity</code> constructor is less complex.</p>\n<h3>Example</h3>\n<pre><code>let mut v: Vec<usize> = vec![];\nv.reserve(10);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut v: Vec<usize> = Vec::with_capacity(10);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "rest_pat_in_fully_bound_structs",
    "rule_name": "rest_pat_in_fully_bound_structs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary \u2018..\u2019 pattern binding on struct when all fields are explicitly matched.</p>\n<h3>Why restrict this?</h3>\n<p>Correctness and readability. It\u2019s like having a wildcard pattern after\nmatching all enum variants explicitly.</p>\n<h3>Example</h3>\n<pre><code>let a = A { a: 5 };\n\nmatch a {\n    A { a: 5, .. } => {},\n    _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match a {\n    A { a: 5 } => {},\n    _ => {},\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "result_filter_map",
    "rule_name": "result_filter_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for iterators of <code>Result</code>s using <code>.filter(Result::is_ok).map(Result::unwrap)</code> that may\nbe replaced with a <code>.flatten()</code> call.</p>\n<h3>Why is this bad?</h3>\n<p><code>Result</code> implements <code>IntoIterator<Item = T></code>. This means that <code>Result</code> can be flattened\nautomatically without suspicious-looking <code>unwrap</code> calls.</p>\n<h3>Example</h3>\n<pre><code>let _ = std::iter::empty::<Result<i32, ()>>().filter(Result::is_ok).map(Result::unwrap);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = std::iter::empty::<Result<i32, ()>>().flatten();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "result_large_err",
    "rule_name": "result_large_err",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions that return <code>Result</code> with an unusually large\n<code>Err</code>-variant.</p>\n<h3>Why is this bad?</h3>\n<p>A <code>Result</code> is at least as large as the <code>Err</code>-variant. While we\nexpect that variant to be seldom used, the compiler needs to reserve\nand move that much memory every single time.\nFurthermore, errors are often simply passed up the call-stack, making\nuse of the <code>?</code>-operator and its type-conversion mechanics. If the\n<code>Err</code>-variant further up the call-stack stores the <code>Err</code>-variant in\nquestion (as library code often does), it itself needs to be at least\nas large, propagating the problem.</p>\n<h3>Known problems</h3>\n<p>The size determined by Clippy is platform-dependent.</p>\n<h3>Examples</h3>\n<pre><code>pub enum ParseError {\n    UnparsedBytes([u8; 512]),\n    UnexpectedEof,\n}\n\n// The `Result` has at least 512 bytes, even in the `Ok`-case\npub fn parse() -> Result<(), ParseError> {\n    Ok(())\n}\n</code></pre>\n<p>should be</p>\n<pre><code>pub enum ParseError {\n    UnparsedBytes(Box<[u8; 512]>),\n    UnexpectedEof,\n}\n\n// The `Result` is slightly larger than a pointer\npub fn parse() -> Result<(), ParseError> {\n    Ok(())\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>large-error-threshold</code>:  The maximum size of the <code>Err</code>-variant in a <code>Result</code> returned from a function</p>\n<p>(default: <code>128</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "result_map_or_into_option",
    "rule_name": "result_map_or_into_option",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.map_or(None, Some)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.ok()</code>.</p>\n<h3>Example</h3>\n<pre><code>assert_eq!(Some(1), r.map_or(None, Some));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>assert_eq!(Some(1), r.ok());\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "result_map_unit_fn",
    "rule_name": "result_map_unit_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>result.map(f)</code> where f is a function\nor closure that returns the unit type <code>()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more clearly with\nan if let statement</p>\n<h3>Example</h3>\n<pre><code>let x: Result<String, String> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)));\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let x: Result<String, String> = do_stuff();\nif let Ok(msg) = x {\n    log_err_msg(msg);\n};\nif let Ok(msg) = x {\n    log_err_msg(format_msg(msg));\n};\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "result_unit_err",
    "rule_name": "result_unit_err",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for public functions that return a <code>Result</code>\nwith an <code>Err</code> type of <code>()</code>. It suggests using a custom type that\nimplements <code>std::error::Error</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Unit does not implement <code>Error</code> and carries no\nfurther information about what went wrong.</p>\n<h3>Known problems</h3>\n<p>Of course, this lint assumes that <code>Result</code> is used\nfor a fallible operation (which is after all the intended use). However\ncode may opt to (mis)use it as a basic two-variant-enum. In that case,\nthe suggestion is misguided, and the code should use a custom enum\ninstead.</p>\n<h3>Examples</h3>\n<pre><code>pub fn read_u8() -> Result<u8, ()> { Err(()) }\n</code></pre>\n<p>should become</p>\n<pre><code>use std::fmt;\n\n#[derive(Debug)]\npub struct EndOfStream;\n\nimpl fmt::Display for EndOfStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"End of Stream\")\n    }\n}\n\nimpl std::error::Error for EndOfStream { }\n\npub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n</code></pre>\n<p>Note that there are crates that simplify creating the error type, e.g.\n<a><code>thiserror</code></a>.</p>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "return_self_not_must_use",
    "rule_name": "return_self_not_must_use",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns when a method returning <code>Self</code> doesn\u2019t have the <code>#[must_use]</code> attribute.</p>\n<h3>Why is this bad?</h3>\n<p>Methods returning <code>Self</code> often create new values, having the <code>#[must_use]</code> attribute\nprevents users from \u201cforgetting\u201d to use the newly created value.</p>\n<p>The <code>#[must_use]</code> attribute can be added to the type itself to ensure that instances\nare never forgotten. Functions returning a type marked with <code>#[must_use]</code> will not be\nlinted, as the usage is already enforced by the type attribute.</p>\n<h3>Limitations</h3>\n<p>This lint is only applied on methods taking a <code>self</code> argument. It would be mostly noise\nif it was added on constructors for example.</p>\n<h3>Example</h3>\n<pre><code>pub struct Bar;\nimpl Bar {\n    // Missing attribute\n    pub fn bar(&self) -> Self {\n        Self\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// It's better to have the `#[must_use]` attribute on the method like this:\npub struct Bar;\nimpl Bar {\n    #[must_use]\n    pub fn bar(&self) -> Self {\n        Self\n    }\n}\n\n// Or on the type definition like this:\n#[must_use]\npub struct Bar;\nimpl Bar {\n    pub fn bar(&self) -> Self {\n        Self\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "reversed_empty_ranges",
    "rule_name": "reversed_empty_ranges",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for range expressions <code>x..y</code> where both <code>x</code> and <code>y</code>\nare constant and <code>x</code> is greater to <code>y</code>. Also triggers if <code>x</code> is equal to <code>y</code> when they are conditions to a <code>for</code> loop.</p>\n<h3>Why is this bad?</h3>\n<p>Empty ranges yield no values so iterating them is a no-op.\nMoreover, trying to use a reversed range to index a slice will panic at run-time.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    (10..=0).for_each(|x| println!(\"{}\", x));\n\n    let arr = [1, 2, 3, 4, 5];\n    let sub = &arr[3..1];\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    (0..=10).rev().for_each(|x| println!(\"{}\", x));\n\n    let arr = [1, 2, 3, 4, 5];\n    let sub = &arr[1..3];\n}\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>reverse_range_loop</li>\n</ul>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "same_functions_in_if_condition",
    "rule_name": "same_functions_in_if_condition",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for consecutive <code>if</code>s with the same function call.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a copy & paste error.\nDespite the fact that function can have side effects and <code>if</code> works as\nintended, such an approach is implicit and can be considered a \u201ccode smell\u201d.</p>\n<h3>Example</h3>\n<pre><code>if foo() == bar {\n    \u2026\n} else if foo() == bar {\n    \u2026\n}\n</code></pre>\n<p>This probably should be:</p>\n<pre><code>if foo() == bar {\n    \u2026\n} else if foo() == baz {\n    \u2026\n}\n</code></pre>\n<p>or if the original code was not a typo and called function mutates a state,\nconsider move the mutation out of the <code>if</code> condition to avoid similarity to\na copy & paste error:</p>\n<pre><code>let first = foo();\nif first == bar {\n    \u2026\n} else {\n    let second = foo();\n    if second == bar {\n    \u2026\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "same_item_push",
    "rule_name": "same_item_push",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks whether a for loop is being used to push a constant\nvalue into a Vec.</p>\n<h3>Why is this bad?</h3>\n<p>This kind of operation can be expressed more succinctly with\n<code>vec![item; SIZE]</code> or <code>vec.resize(NEW_SIZE, item)</code> and using these alternatives may also\nhave better performance.</p>\n<h3>Example</h3>\n<pre><code>let item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = Vec::new();\nfor _ in 0..20 {\n   vec.push(item1);\n}\nfor _ in 0..30 {\n    vec.push(item2);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = vec![item1; 20];\nvec.resize(20 + 30, item2);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "same_name_method",
    "rule_name": "same_name_method",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It lints if a struct has two methods with the same name:\none from a trait, another not from a trait.</p>\n<h3>Why restrict this?</h3>\n<p>Confusing.</p>\n<h3>Example</h3>\n<pre><code>trait T {\n    fn foo(&self) {}\n}\n\nstruct S;\n\nimpl T for S {\n    fn foo(&self) {}\n}\n\nimpl S {\n    fn foo(&self) {}\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "search_is_some",
    "rule_name": "search_is_some",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for an iterator or string search (such as <code>find()</code>,\n<code>position()</code>, or <code>rposition()</code>) followed by a call to <code>is_some()</code> or <code>is_none()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as:</p>\n<ul>\n<li><code>_.any(_)</code>, or <code>_.contains(_)</code> for <code>is_some()</code>,</li>\n<li><code>!_.any(_)</code>, or <code>!_.contains(_)</code> for <code>is_none()</code>.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let vec = vec![1];\nvec.iter().find(|x| **x == 0).is_some();\n\n\"hello world\".find(\"world\").is_none();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let vec = vec![1];\nvec.iter().any(|x| *x == 0);\n\n!\"hello world\".contains(\"world\");\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "seek_from_current",
    "rule_name": "seek_from_current",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if the <code>seek</code> method of the <code>Seek</code> trait is called with <code>SeekFrom::Current(0)</code>,\nand if it is, suggests using <code>stream_position</code> instead.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. Use dedicated method.</p>\n<h3>Example</h3>\n<pre><code>use std::fs::File;\nuse std::io::{self, Write, Seek, SeekFrom};\n\nfn main() -> io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    f.write_all(b\"Hello\")?;\n    eprintln!(\"Written {} bytes\", f.seek(SeekFrom::Current(0))?);\n\n    Ok(())\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fs::File;\nuse std::io::{self, Write, Seek, SeekFrom};\n\nfn main() -> io::Result<()> {\n    let mut f = File::create(\"foo.txt\")?;\n    f.write_all(b\"Hello\")?;\n    eprintln!(\"Written {} bytes\", f.stream_position()?);\n\n    Ok(())\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "seek_to_start_instead_of_rewind",
    "rule_name": "seek_to_start_instead_of_rewind",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for jumps to the start of a stream that implements <code>Seek</code>\nand uses the <code>seek</code> method providing <code>Start</code> as parameter.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. There is a specific method that was implemented for\nthis exact scenario.</p>\n<h3>Example</h3>\n<pre><code>fn foo<T: io::Seek>(t: &mut T) {\n    t.seek(io::SeekFrom::Start(0));\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo<T: io::Seek>(t: &mut T) {\n    t.rewind();\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "self_assignment",
    "rule_name": "self_assignment",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for explicit self-assignments.</p>\n<h3>Why is this bad?</h3>\n<p>Self-assignments are redundant and unlikely to be\nintentional.</p>\n<h3>Known problems</h3>\n<p>If expression contains any deref coercions or\nindexing operations they are assumed not to have any side effects.</p>\n<h3>Example</h3>\n<pre><code>struct Event {\n    x: i32,\n}\n\nfn copy_position(a: &mut Event, b: &Event) {\n    a.x = a.x;\n}\n</code></pre>\n<p>Should be:</p>\n<pre><code>struct Event {\n    x: i32,\n}\n\nfn copy_position(a: &mut Event, b: &Event) {\n    a.x = b.x;\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "self_named_constructors",
    "rule_name": "self_named_constructors",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns when constructors have the same name as their types.</p>\n<h3>Why is this bad?</h3>\n<p>Repeating the name of the type is redundant.</p>\n<h3>Example</h3>\n<pre><code>struct Foo {}\n\nimpl Foo {\n    pub fn foo() -> Foo {\n        Foo {}\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Foo {}\n\nimpl Foo {\n    pub fn new() -> Foo {\n        Foo {}\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "self_named_module_files",
    "rule_name": "self_named_module_files",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks that module layout uses only <code>mod.rs</code> files.</p>\n<h3>Why restrict this?</h3>\n<p>Having multiple module layout styles in a project can be confusing.</p>\n<h3>Example</h3>\n<pre><code>src/\n  stuff/\n    stuff_files.rs\n  stuff.rs\n  lib.rs\n</code></pre>\n<p>Use instead:</p>\n<pre><code>src/\n  stuff/\n    stuff_files.rs\n    mod.rs\n  lib.rs\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "semicolon_if_nothing_returned",
    "rule_name": "semicolon_if_nothing_returned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for blocks of expressions and fires if the last expression returns\n<code>()</code> but is not followed by a semicolon.</p>\n<h3>Why is this bad?</h3>\n<p>The semicolon might be optional but when extending the block with new\ncode, it doesn\u2019t require a change in previous last line.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    println!(\"Hello world\")\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    println!(\"Hello world\");\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "semicolon_inside_block",
    "rule_name": "semicolon_inside_block",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests moving the semicolon after a block to the inside of the block, after its last\nexpression.</p>\n<h3>Why restrict this?</h3>\n<p>For consistency it\u2019s best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests inside the block.\nTake a look at <code>semicolon_outside_block</code> for the other alternative.</p>\n<h3>Example</h3>\n<pre><code>unsafe { f(x) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>unsafe { f(x); }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>semicolon-inside-block-ignore-singleline</code>:  Whether to lint only if it\u2019s multiline.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "semicolon_outside_block",
    "rule_name": "semicolon_outside_block",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests moving the semicolon from a block\u2019s final expression outside of the block.</p>\n<h3>Why restrict this?</h3>\n<p>For consistency it\u2019s best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests outside the block.\nTake a look at <code>semicolon_inside_block</code> for the other alternative.</p>\n<h3>Example</h3>\n<pre><code>unsafe { f(x); }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>unsafe { f(x) };\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>semicolon-outside-block-ignore-multiline</code>:  Whether to lint only if it\u2019s singleline.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "separated_literal_suffix",
    "rule_name": "separated_literal_suffix",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if literal suffixes are separated by an underscore.\nTo enforce separated literal suffix style,\nsee the <code>unseparated_literal_suffix</code> lint.</p>\n<h3>Why restrict this?</h3>\n<p>Suffix style should be consistent.</p>\n<h3>Example</h3>\n<pre><code>123832_i32\n</code></pre>\n<p>Use instead:</p>\n<pre><code>123832i32\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "serde_api_misuse",
    "rule_name": "serde_api_misuse",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for misuses of the serde API.</p>\n<h3>Why is this bad?</h3>\n<p>Serde is very finicky about how its API should be\nused, but the type system can\u2019t be used to enforce it (yet?).</p>\n<h3>Example</h3>\n<p>Implementing <code>Visitor::visit_string</code> but not\n<code>Visitor::visit_str</code>.</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "set_contains_or_insert",
    "rule_name": "set_contains_or_insert",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>contains</code> to see if a value is not present\nin a set like <code>HashSet</code> or <code>BTreeSet</code>, followed by an <code>insert</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using just <code>insert</code> and checking the returned <code>bool</code> is more efficient.</p>\n<h3>Known problems</h3>\n<p>In case the value that wants to be inserted is borrowed and also expensive or impossible\nto clone. In such a scenario, the developer might want to check with <code>contains</code> before inserting,\nto avoid the clone. In this case, it will report a false positive.</p>\n<h3>Example</h3>\n<pre><code>use std::collections::HashSet;\nlet mut set = HashSet::new();\nlet value = 5;\nif !set.contains(&value) {\n    set.insert(value);\n    println!(\"inserted {value:?}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::collections::HashSet;\nlet mut set = HashSet::new();\nlet value = 5;\nif set.insert(&value) {\n    println!(\"inserted {value:?}\");\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "shadow_reuse",
    "rule_name": "shadow_reuse",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bindings that shadow other bindings already in\nscope, while reusing the original value.</p>\n<h3>Why restrict this?</h3>\n<p>Some argue that name shadowing like this hurts readability,\nbecause a value may be bound to different things depending on position in\nthe code.</p>\n<p>See also <code>shadow_same</code> and <code>shadow_unrelated</code> for other restrictions on shadowing.</p>\n<h3>Example</h3>\n<pre><code>let x = 2;\nlet x = x + 1;\n</code></pre>\n<p>use different variable name:</p>\n<pre><code>let x = 2;\nlet y = x + 1;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "shadow_same",
    "rule_name": "shadow_same",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bindings that shadow other bindings already in\nscope, while just changing reference level or mutability.</p>\n<h3>Why restrict this?</h3>\n<p>To require that what are formally distinct variables be given distinct names.</p>\n<p>See also <code>shadow_reuse</code> and <code>shadow_unrelated</code> for other restrictions on shadowing.</p>\n<h3>Example</h3>\n<pre><code>let x = &x;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let y = &x; // use different variable name\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "shadow_unrelated",
    "rule_name": "shadow_unrelated",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bindings that shadow other bindings already in\nscope, either without an initialization or with one that does not even use\nthe original value.</p>\n<h3>Why restrict this?</h3>\n<p>Shadowing a binding with a closely related one is part of idiomatic Rust,\nbut shadowing a binding by accident with an unrelated one may indicate a mistake.</p>\n<p>Additionally, name shadowing in general can hurt readability, especially in\nlarge code bases, because it is easy to lose track of the active binding at\nany place in the code. If linting against all shadowing is desired, you may wish\nto use the <code>shadow_same</code> and <code>shadow_reuse</code> lints as well.</p>\n<h3>Example</h3>\n<pre><code>let x = y;\nlet x = z; // shadows the earlier binding\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = y;\nlet w = z; // use different variable name\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "short_circuit_statement",
    "rule_name": "short_circuit_statement",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of short circuit boolean conditions as\na\nstatement.</p>\n<h3>Why is this bad?</h3>\n<p>Using a short circuit boolean condition as a statement\nmay hide the fact that the second part is executed or not depending on the\noutcome of the first part.</p>\n<h3>Example</h3>\n<pre><code>f() && g(); // We should write `if f() { g(); }`.\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "should_assert_eq",
    "rule_name": "should_assert_eq",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>assert!(a == b)</code> can now print the values the same way `assert_eq!(a, b) can.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "should_implement_trait",
    "rule_name": "should_implement_trait",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for methods that should live in a trait\nimplementation of a <code>std</code> trait (see <a>llogiq\u2019s blog\npost</a> for further\ninformation) instead of an inherent implementation.</p>\n<h3>Why is this bad?</h3>\n<p>Implementing the traits improve ergonomics for users of\nthe code, often with very little cost. Also people seeing a <code>mul(...)</code>\nmethod\nmay expect <code>*</code> to work equally, so you should have good reason to disappoint\nthem.</p>\n<h3>Example</h3>\n<pre><code>struct X;\nimpl X {\n    fn add(&self, other: &X) -> X {\n        // ..\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "should_panic_without_expect",
    "rule_name": "should_panic_without_expect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[should_panic]</code> attributes without specifying the expected panic message.</p>\n<h3>Why is this bad?</h3>\n<p>The expected panic message should be specified to ensure that the test is actually\npanicking with the expected message, and not another unrelated panic.</p>\n<h3>Example</h3>\n<pre><code>fn random() -> i32 { 0 }\n\n#[should_panic]\n#[test]\nfn my_test() {\n    let _ = 1 / random();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn random() -> i32 { 0 }\n\n#[should_panic = \"attempt to divide by zero\"]\n#[test]\nfn my_test() {\n    let _ = 1 / random();\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "significant_drop_in_scrutinee",
    "rule_name": "significant_drop_in_scrutinee",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for temporaries returned from function calls in a match scrutinee that have the\n<code>clippy::has_significant_drop</code> attribute.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>clippy::has_significant_drop</code> attribute can be added to types whose Drop impls have\nan important side-effect, such as unlocking a mutex, making it important for users to be\nable to accurately understand their lifetimes. When a temporary is returned in a function\ncall in a match scrutinee, its lifetime lasts until the end of the match block, which may\nbe surprising.</p>\n<p>For <code>Mutex</code>es this can lead to a deadlock. This happens when the match scrutinee uses a\nfunction call that returns a <code>MutexGuard</code> and then tries to lock again in one of the match\narms. In that case the <code>MutexGuard</code> in the scrutinee will not be dropped until the end of\nthe match block and thus will not unlock.</p>\n<h3>Example</h3>\n<pre><code>let mutex = Mutex::new(State {});\n\nmatch mutex.lock().unwrap().foo() {\n    true => {\n        mutex.lock().unwrap().bar(); // Deadlock!\n    }\n    false => {}\n};\n\nprintln!(\"All done!\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mutex = Mutex::new(State {});\n\nlet is_foo = mutex.lock().unwrap().foo();\nmatch is_foo {\n    true => {\n        mutex.lock().unwrap().bar();\n    }\n    false => {}\n};\n\nprintln!(\"All done!\");\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "significant_drop_tightening",
    "rule_name": "significant_drop_tightening",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Searches for elements marked with <code>#[clippy::has_significant_drop]</code> that could be early\ndropped but are in fact dropped at the end of their scopes. In other words, enforces the\n\u201ctightening\u201d of their possible lifetimes.</p>\n<h3>Why is this bad?</h3>\n<p>Elements marked with <code>#[clippy::has_significant_drop]</code> are generally synchronizing\nprimitives that manage shared resources, as such, it is desired to release them as soon as\npossible to avoid unnecessary resource contention.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n  let lock = some_sync_resource.lock();\n  let owned_rslt = lock.do_stuff_with_resource();\n  // Only `owned_rslt` is needed but `lock` is still held.\n  do_heavy_computation_that_takes_time(owned_rslt);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    let owned_rslt = some_sync_resource.lock().do_stuff_with_resource();\n    do_heavy_computation_that_takes_time(owned_rslt);\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "similar_names",
    "rule_name": "similar_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for names that are very similar and thus confusing.</p>\n<p>Note: this lint looks for similar names throughout each\nscope. To allow it, you need to allow it on the scope\nlevel, not on the name that is reported.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s hard to distinguish between names that differ only\nby a single character.</p>\n<h3>Example</h3>\n<pre><code>let checked_exp = something;\nlet checked_expr = something_else;\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "single_call_fn",
    "rule_name": "single_call_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions that are only used once. Does not lint tests.</p>\n<h3>Why restrict this?</h3>\n<p>If a function is only used once (perhaps because it used to be used more widely),\nthen the code could be simplified by moving that function\u2019s code into its caller.</p>\n<p>However, there are reasons not to do this everywhere:</p>\n<ul>\n<li>Splitting a large function into multiple parts often improves readability\nby giving names to its parts.</li>\n<li>A function\u2019s signature might serve a necessary purpose, such as constraining\nthe type of a closure passed to it.</li>\n<li>Generic functions might call non-generic functions to reduce duplication\nin the produced machine code.</li>\n</ul>\n<p>If this lint is used, prepare to <code>#[allow]</code> it a lot.</p>\n<h3>Example</h3>\n<pre><code>pub fn a<T>(t: &T)\nwhere\n    T: AsRef<str>,\n{\n    a_inner(t.as_ref())\n}\n\nfn a_inner(t: &str) {\n    /* snip */\n}\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub fn a<T>(t: &T)\nwhere\n    T: AsRef<str>,\n{\n    let t = t.as_ref();\n    /* snip */\n}\n\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "single_char_add_str",
    "rule_name": "single_char_add_str",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns when using <code>push_str</code>/<code>insert_str</code> with a single-character string literal\nwhere <code>push</code>/<code>insert</code> with a <code>char</code> would work fine.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s less clear that we are pushing a single character.</p>\n<h3>Example</h3>\n<pre><code>string.insert_str(0, \"R\");\nstring.push_str(\"R\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>string.insert(0, 'R');\nstring.push('R');\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>single_char_push_str</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "single_char_lifetime_names",
    "rule_name": "single_char_lifetime_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for lifetimes with names which are one character\nlong.</p>\n<h3>Why restrict this?</h3>\n<p>A single character is likely not enough to express the\npurpose of a lifetime. Using a longer name can make code\neasier to understand.</p>\n<h3>Known problems</h3>\n<p>Rust programmers and learning resources tend to use single\ncharacter lifetimes, so this lint is at odds with the\necosystem at large. In addition, the lifetime\u2019s purpose may\nbe obvious or, rarely, expressible in one character.</p>\n<h3>Example</h3>\n<pre><code>struct DiagnosticCtx<'a> {\n    source: &'a str,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct DiagnosticCtx<'src> {\n    source: &'src str,\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "single_char_pattern",
    "rule_name": "single_char_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for string methods that receive a single-character\n<code>str</code> as an argument, e.g., <code>_.split(\"x\")</code>.</p>\n<h3>Why is this bad?</h3>\n<p>While this can make a perf difference on some systems,\nbenchmarks have proven inconclusive. But at least using a\nchar literal makes it clear that we are looking at a single\ncharacter.</p>\n<h3>Known problems</h3>\n<p>Does not catch multi-byte unicode characters. This is by\ndesign, on many machines, splitting by a non-ascii char is\nactually slower. Please do your own measurements instead of\nrelying solely on the results of this lint.</p>\n<h3>Example</h3>\n<pre><code>_.split(\"x\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>_.split('x');\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "single_component_path_imports",
    "rule_name": "single_component_path_imports",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checking for imports with single component use path.</p>\n<h3>Why is this bad?</h3>\n<p>Import with single component use path such as <code>use cratename;</code>\nis not necessary, and thus should be removed.</p>\n<h3>Example</h3>\n<pre><code>use regex;\n\nfn main() {\n    regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n</code></pre>\n<p>Better as</p>\n<pre><code>fn main() {\n    regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "single_element_loop",
    "rule_name": "single_element_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks whether a for loop has a single element.</p>\n<h3>Why is this bad?</h3>\n<p>There is no reason to have a loop of a\nsingle element.</p>\n<h3>Example</h3>\n<pre><code>let item1 = 2;\nfor item in &[item1] {\n    println!(\"{}\", item);\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let item1 = 2;\nlet item = &item1;\nprintln!(\"{}\", item);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "single_match",
    "rule_name": "single_match",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for matches with a single arm where an <code>if let</code>\nwill usually suffice.</p>\n<p>This intentionally does not lint if there are comments\ninside of the other arm, so as to allow the user to document\nwhy having another explicit pattern with an empty body is necessary,\nor because the comments need to be preserved for other reasons.</p>\n<h3>Why is this bad?</h3>\n<p>Just readability \u2013 <code>if let</code> nests less than a <code>match</code>.</p>\n<h3>Example</h3>\n<pre><code>match x {\n    Some(ref foo) => bar(foo),\n    _ => (),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if let Some(ref foo) = x {\n    bar(foo);\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "single_match_else",
    "rule_name": "single_match_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for matches with two arms where an <code>if let else</code> will\nusually suffice.</p>\n<h3>Why is this bad?</h3>\n<p>Just readability \u2013 <code>if let</code> nests less than a <code>match</code>.</p>\n<h3>Known problems</h3>\n<p>Personal style preferences may differ.</p>\n<h3>Example</h3>\n<p>Using <code>match</code>:</p>\n<pre><code>match x {\n    Some(ref foo) => bar(foo),\n    _ => bar(&other_ref),\n}\n</code></pre>\n<p>Using <code>if let</code> with <code>else</code>:</p>\n<pre><code>if let Some(ref foo) = x {\n    bar(foo);\n} else {\n    bar(&other_ref);\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "single_range_in_vec_init",
    "rule_name": "single_range_in_vec_init",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Vec</code> or array initializations that contain only one range.</p>\n<h3>Why is this bad?</h3>\n<p>This is almost always incorrect, as it will result in a <code>Vec</code> that has only one element.\nAlmost always, the programmer intended for it to include all elements in the range or for\nthe end of the range to be the length instead.</p>\n<h3>Example</h3>\n<pre><code>let x = [0..200];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// If it was intended to include every element in the range...\nlet x = (0..200).collect::<Vec<i32>>();\n// ...Or if 200 was meant to be the len\nlet x = [0; 200];\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "size_of_in_element_count",
    "rule_name": "size_of_in_element_count",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects expressions where\n<code>size_of::<T></code> or <code>size_of_val::<T></code> is used as a\ncount of elements of type <code>T</code></p>\n<h3>Why is this bad?</h3>\n<p>These functions expect a count\nof <code>T</code> and not a number of bytes</p>\n<h3>Example</h3>\n<pre><code>const SIZE: usize = 128;\nlet x = [2u8; SIZE];\nlet mut y = [2u8; SIZE];\nunsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "size_of_ref",
    "rule_name": "size_of_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>std::mem::size_of_val()</code> where the argument is\na reference to a reference.</p>\n<h3>Why is this bad?</h3>\n<p>Calling <code>size_of_val()</code> with a reference to a reference as the argument\nyields the size of the reference-type, not the size of the value behind\nthe reference.</p>\n<h3>Example</h3>\n<pre><code>struct Foo {\n    buffer: [u8],\n}\n\nimpl Foo {\n    fn size(&self) -> usize {\n        // Note that `&self` as an argument is a `&&Foo`: Because `self`\n        // is already a reference, `&self` is a double-reference.\n        // The return value of `size_of_val()` therefore is the\n        // size of the reference-type, not the size of `self`.\n        std::mem::size_of_val(&self)\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Foo {\n    buffer: [u8],\n}\n\nimpl Foo {\n    fn size(&self) -> usize {\n        // Correct\n        std::mem::size_of_val(self)\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "skip_while_next",
    "rule_name": "skip_while_next",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>_.skip_while(condition).next()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability, this can be written more concisely as\n<code>_.find(!condition)</code>.</p>\n<h3>Example</h3>\n<pre><code>vec.iter().skip_while(|x| **x == 0).next();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.iter().find(|x| **x != 0);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "slow_vector_initialization",
    "rule_name": "slow_vector_initialization",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks slow zero-filled vector initialization</p>\n<h3>Why is this bad?</h3>\n<p>These structures are non-idiomatic and less efficient than simply using\n<code>vec![0; len]</code>.</p>\n<p>Specifically, for <code>vec![0; len]</code>, the compiler can use a specialized type of allocation\nthat also zero-initializes the allocated memory in the same call\n(see: <a>alloc_zeroed</a>).</p>\n<p>Writing <code>Vec::new()</code> followed by <code>vec.resize(len, 0)</code> is suboptimal because,\nwhile it does do the same number of allocations,\nit involves two operations for allocating and initializing.\nThe <code>resize</code> call first allocates memory (since <code>Vec::new()</code> did not), and only <em>then</em> zero-initializes it.</p>\n<h3>Example</h3>\n<pre><code>let mut vec1 = Vec::new();\nvec1.resize(len, 0);\n\nlet mut vec2 = Vec::with_capacity(len);\nvec2.resize(len, 0);\n\nlet mut vec3 = Vec::with_capacity(len);\nvec3.extend(repeat(0).take(len));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut vec1 = vec![0; len];\nlet mut vec2 = vec![0; len];\nlet mut vec3 = vec![0; len];\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "stable_sort_primitive",
    "rule_name": "stable_sort_primitive",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>When sorting primitive values (integers, bools, chars, as well\nas arrays, slices, and tuples of such items), it is typically better to\nuse an unstable sort than a stable sort.</p>\n<h3>Why is this bad?</h3>\n<p>Typically, using a stable sort consumes more memory and cpu cycles.\nBecause values which compare equal are identical, preserving their\nrelative order (the guarantee that a stable sort provides) means\nnothing, while the extra costs still apply.</p>\n<h3>Known problems</h3>\n<p>As pointed out in\n<a>issue #8241</a>,\na stable sort can instead be significantly faster for certain scenarios\n(eg. when a sorted vector is extended with new data and resorted).</p>\n<p>For more information and benchmarking results, please refer to the\nissue linked above.</p>\n<h3>Example</h3>\n<pre><code>let mut vec = vec![2, 1, 3];\nvec.sort();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut vec = vec![2, 1, 3];\nvec.sort_unstable();\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "std_instead_of_alloc",
    "rule_name": "std_instead_of_alloc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds items imported through <code>std</code> when available through <code>alloc</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Crates which have <code>no_std</code> compatibility and require alloc may wish to ensure types are imported from\nalloc to ensure disabling <code>std</code> does not cause the crate to fail to compile. This lint is also useful\nfor crates migrating to become <code>no_std</code> compatible.</p>\n<h3>Example</h3>\n<pre><code>use std::vec::Vec;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use alloc::vec::Vec;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "std_instead_of_core",
    "rule_name": "std_instead_of_core",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds items imported through <code>std</code> when available through <code>core</code>.</p>\n<h3>Why restrict this?</h3>\n<p>Crates which have <code>no_std</code> compatibility may wish to ensure types are imported from core to ensure\ndisabling <code>std</code> does not cause the crate to fail to compile. This lint is also useful for crates\nmigrating to become <code>no_std</code> compatible.</p>\n<h3>Example</h3>\n<pre><code>use std::hash::Hasher;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use core::hash::Hasher;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "str_split_at_newline",
    "rule_name": "str_split_at_newline",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usages of <code>str.trim().split(\"\\n\")</code> and <code>str.trim().split(\"\\r\\n\")</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Hard-coding the line endings makes the code less compatible. <code>str.lines</code> should be used instead.</p>\n<h3>Example</h3>\n<pre><code>\"some\\ntext\\nwith\\nnewlines\\n\".trim().split('\\n');\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\"some\\ntext\\nwith\\nnewlines\\n\".lines();\n</code></pre>\n<h3>Known Problems</h3>\n<p>This lint cannot detect if the split is intentionally restricted to a single type of newline (<code>\"\\n\"</code> or\n<code>\"\\r\\n\"</code>), for example during the parsing of a specific file format in which precisely one newline type is\nvalid.</p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "str_to_string",
    "rule_name": "str_to_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for <code>.to_string()</code> method calls on values of type <code>&str</code>.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>to_string</code> method is also used on other types to convert them to a string.\nWhen called on a <code>&str</code> it turns the <code>&str</code> into the owned variant <code>String</code>, which can be\nmore specifically expressed with <code>.to_owned()</code>.</p>\n<h3>Example</h3>\n<pre><code>let _ = \"str\".to_string();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = \"str\".to_owned();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_add",
    "rule_name": "string_add",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for all instances of <code>x + _</code> where <code>x</code> is of type\n<code>String</code>, but only if <a><code>string_add_assign</code></a> does <em>not</em>\nmatch.</p>\n<h3>Why restrict this?</h3>\n<p>This particular\n<code>Add</code> implementation is asymmetric (the other operand need not be <code>String</code>,\nbut <code>x</code> does), while addition as mathematically defined is symmetric, and\nthe <code>String::push_str(_)</code> function is a perfectly good replacement.\nTherefore, some dislike it and wish not to have it in their code.</p>\n<p>That said, other people think that string addition, having a long tradition\nin other languages is actually fine, which is why we decided to make this\nparticular lint <code>allow</code> by default.</p>\n<h3>Example</h3>\n<pre><code>let x = \"Hello\".to_owned();\nx + \", World\";\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut x = \"Hello\".to_owned();\nx.push_str(\", World\");\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_add_assign",
    "rule_name": "string_add_assign",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for string appends of the form <code>x = x + y</code> (without\n<code>let</code>!).</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s not really bad, but some people think that the\n<code>.push_str(_)</code> method is more readable.</p>\n<h3>Example</h3>\n<pre><code>let mut x = \"Hello\".to_owned();\nx = x + \", World\";\n\n// More readable\nx += \", World\";\nx.push_str(\", World\");\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_extend_chars",
    "rule_name": "string_extend_chars",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>.extend(s.chars())</code> where s is a\n<code>&str</code> or <code>String</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>.push_str(s)</code> is clearer</p>\n<h3>Example</h3>\n<pre><code>let abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.extend(abc.chars());\ns.extend(def.chars());\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.push_str(abc);\ns.push_str(&def);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "string_from_utf8_as_bytes",
    "rule_name": "string_from_utf8_as_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Check if the string is transformed to byte array and casted back to string.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s unnecessary, the string can be used directly.</p>\n<h3>Example</h3>\n<pre><code>std::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]).unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>&\"Hello World!\"[6..11];\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "string_lit_as_bytes",
    "rule_name": "string_lit_as_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the <code>as_bytes</code> method called on string literals\nthat contain only ASCII characters.</p>\n<h3>Why is this bad?</h3>\n<p>Byte string literals (e.g., <code>b\"foo\"</code>) can be used\ninstead. They are shorter but less discoverable than <code>as_bytes()</code>.</p>\n<h3>Known problems</h3>\n<p><code>\"str\".as_bytes()</code> and the suggested replacement of <code>b\"str\"</code> are not\nequivalent because they have different types. The former is <code>&[u8]</code>\nwhile the latter is <code>&[u8; 3]</code>. That means in general they will have a\ndifferent set of methods and different trait implementations.</p>\n<pre><code>fn f(v: Vec<u8>) {}\n\nf(\"...\".as_bytes().to_owned()); // works\nf(b\"...\".to_owned()); // does not work, because arg is [u8; 3] not Vec<u8>\n\nfn g(r: impl std::io::Read) {}\n\ng(\"...\".as_bytes()); // works\ng(b\"...\"); // does not work\n</code></pre>\n<p>The actual equivalent of <code>\"str\".as_bytes()</code> with the same type is not\n<code>b\"str\"</code> but <code>&b\"str\"[..]</code>, which is a great deal of punctuation and not\nmore readable than a function call.</p>\n<h3>Example</h3>\n<pre><code>let bstr = \"a byte string\".as_bytes();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let bstr = b\"a byte string\";\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_lit_chars_any",
    "rule_name": "string_lit_chars_any",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code><string_lit>.chars().any(|i| i == c)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s significantly slower than using a pattern instead, like\n<code>matches!(c, '\\\\' | '.' | '+')</code>.</p>\n<p>Despite this being faster, this is not <code>perf</code> as this is pretty common, and is a rather nice\nway to check if a <code>char</code> is any in a set. In any case, this <code>restriction</code> lint is available\nfor situations where that additional performance is absolutely necessary.</p>\n<h3>Example</h3>\n<pre><code>\"\\\\.+*?()|[]{}^$#&-~\".chars().any(|x| x == c);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>matches!(c, '\\\\' | '.' | '+' | '*' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^' | '$' | '#' | '&' | '-' | '~');\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_slice",
    "rule_name": "string_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for slice operations on strings</p>\n<h3>Why restrict this?</h3>\n<p>UTF-8 characters span multiple bytes, and it is easy to inadvertently confuse character\ncounts and string indices. This may lead to panics, and should warrant some test cases\ncontaining wide UTF-8 characters. This lint is most useful in code that should avoid\npanics at all costs.</p>\n<h3>Known problems</h3>\n<p>Probably lots of false positives. If an index comes from a known valid position (e.g.\nobtained via <code>char_indices</code> over the same string), it is totally OK.</p>\n<h3>Example</h3>\n<pre><code>&\"\u00d6lkanne\"[1..];\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "string_to_string",
    "rule_name": "string_to_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint checks for <code>.to_string()</code> method calls on values of type <code>String</code>.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>to_string</code> method is also used on other types to convert them to a string.\nWhen called on a <code>String</code> it only clones the <code>String</code>, which can be more specifically\nexpressed with <code>.clone()</code>.</p>\n<h3>Example</h3>\n<pre><code>let msg = String::from(\"Hello World\");\nlet _ = msg.to_string();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let msg = String::from(\"Hello World\");\nlet _ = msg.clone();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "strlen_on_c_strings",
    "rule_name": "strlen_on_c_strings",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>libc::strlen</code> on a <code>CString</code> or <code>CStr</code> value,\nand suggest calling <code>as_bytes().len()</code> or <code>to_bytes().len()</code> respectively instead.</p>\n<h3>Why is this bad?</h3>\n<p>This avoids calling an unsafe <code>libc</code> function.\nCurrently, it also avoids calculating the length.</p>\n<h3>Example</h3>\n<pre><code>use std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = unsafe { libc::strlen(cstring.as_ptr()) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = cstring.as_bytes().len();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "struct_excessive_bools",
    "rule_name": "struct_excessive_bools",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for excessive\nuse of bools in structs.</p>\n<h3>Why is this bad?</h3>\n<p>Excessive bools in a struct\nis often a sign that it\u2019s used as a state machine,\nwhich is much better implemented as an enum.\nIf it\u2019s not the case, excessive bools usually benefit\nfrom refactoring into two-variant enums for better\nreadability and API.</p>\n<h3>Example</h3>\n<pre><code>struct S {\n    is_pending: bool,\n    is_processing: bool,\n    is_finished: bool,\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>enum S {\n    Pending,\n    Processing,\n    Finished,\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>max-struct-bools</code>:  The maximum number of bool fields a struct can have</p>\n<p>(default: <code>3</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "struct_field_names",
    "rule_name": "struct_field_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects struct fields that are prefixed or suffixed\nby the same characters or the name of the struct itself.</p>\n<h3>Why is this bad?</h3>\n<p>Information common to all struct fields is better represented in the struct name.</p>\n<h3>Limitations</h3>\n<p>Characters with no casing will be considered when comparing prefixes/suffixes\nThis applies to numbers and non-ascii characters without casing\ne.g. <code>foo1</code> and <code>foo2</code> is considered to have different prefixes\n(the prefixes are <code>foo1</code> and <code>foo2</code> respectively), as also <code>bar\u8783</code>, <code>bar\u87f9</code></p>\n<h3>Example</h3>\n<pre><code>struct Cake {\n    cake_sugar: u8,\n    cake_flour: u8,\n    cake_eggs: u8\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Cake {\n    sugar: u8,\n    flour: u8,\n    eggs: u8\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>struct-field-name-threshold</code>:  The minimum number of struct fields for the lints about field names to trigger</p>\n<p>(default: <code>3</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "suboptimal_flops",
    "rule_name": "suboptimal_flops",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for floating-point expressions that\ncan be expressed using built-in methods to improve both\naccuracy and performance.</p>\n<h3>Why is this bad?</h3>\n<p>Negatively impacts accuracy and performance.</p>\n<h3>Example</h3>\n<pre><code>use std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = (2f32).powf(a);\nlet _ = E.powf(a);\nlet _ = a.powf(1.0 / 2.0);\nlet _ = a.log(2.0);\nlet _ = a.log(10.0);\nlet _ = a.log(E);\nlet _ = a.powf(2.0);\nlet _ = a * 2.0 + 4.0;\nlet _ = if a < 0.0 {\n    -a\n} else {\n    a\n};\nlet _ = if a < 0.0 {\n    a\n} else {\n    -a\n};\n</code></pre>\n<p>is better expressed as</p>\n<pre><code>use std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = a.exp2();\nlet _ = a.exp();\nlet _ = a.sqrt();\nlet _ = a.log2();\nlet _ = a.log10();\nlet _ = a.ln();\nlet _ = a.powi(2);\nlet _ = a.mul_add(2.0, 4.0);\nlet _ = a.abs();\nlet _ = -a.abs();\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "suspicious_arithmetic_impl",
    "rule_name": "suspicious_arithmetic_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints for suspicious operations in impls of arithmetic operators, e.g.\nsubtracting elements in an Add impl.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a typo or copy-and-paste error and not intended.</p>\n<h3>Example</h3>\n<pre><code>impl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, other: Foo) -> Foo {\n        Foo(self.0 - other.0)\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_assignment_formatting",
    "rule_name": "suspicious_assignment_formatting",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of the non-existent <code>=*</code>, <code>=!</code> and <code>=-</code>\noperators.</p>\n<h3>Why is this bad?</h3>\n<p>This is either a typo of <code>*=</code>, <code>!=</code> or <code>-=</code> or\nconfusing.</p>\n<h3>Example</h3>\n<pre><code>a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_command_arg_space",
    "rule_name": "suspicious_command_arg_space",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Command::arg()</code> invocations that look like they\nshould be multiple arguments instead, such as <code>arg(\"-t ext2\")</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>Command::arg()</code> does not split arguments by space. An argument like <code>arg(\"-t ext2\")</code>\nwill be passed as a single argument to the command,\nwhich is likely not what was intended.</p>\n<h3>Example</h3>\n<pre><code>std::process::Command::new(\"echo\").arg(\"-n hello\").spawn().unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>std::process::Command::new(\"echo\").args([\"-n\", \"hello\"]).spawn().unwrap();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_doc_comments",
    "rule_name": "suspicious_doc_comments",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects the use of outer doc comments (<code>///</code>, <code>/**</code>) followed by a bang (<code>!</code>): <code>///!</code></p>\n<h3>Why is this bad?</h3>\n<p>Triple-slash comments (known as \u201couter doc comments\u201d) apply to items that follow it.\nAn outer doc comment followed by a bang (i.e. <code>///!</code>) has no specific meaning.</p>\n<p>The user most likely meant to write an inner doc comment (<code>//!</code>, <code>/*!</code>), which\napplies to the parent item (i.e. the item that the comment is contained in,\nusually a module or crate).</p>\n<h3>Known problems</h3>\n<p>Inner doc comments can only appear before items, so there are certain cases where the suggestion\nmade by this lint is not valid code. For example:</p>\n<pre><code>fn foo() {}\n///!\nfn bar() {}\n</code></pre>\n<p>This lint detects the doc comment and suggests changing it to <code>//!</code>, but an inner doc comment\nis not valid at that position.</p>\n<h3>Example</h3>\n<p>In this example, the doc comment is attached to the <em>function</em>, rather than the <em>module</em>.</p>\n<pre><code>pub mod util {\n    ///! This module contains utility functions.\n\n    pub fn dummy() {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub mod util {\n    //! This module contains utility functions.\n\n    pub fn dummy() {}\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_else_formatting",
    "rule_name": "suspicious_else_formatting",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for formatting of <code>else</code>. It lints if the <code>else</code>\nis followed immediately by a newline or the <code>else</code> seems to be missing.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably some refactoring remnant, even if the\ncode is correct, it might look confusing.</p>\n<h3>Example</h3>\n<pre><code>if foo {\n} { // looks like an `else` is missing here\n}\n\nif foo {\n} if bar { // looks like an `else` is missing here\n}\n\nif foo {\n} else\n\n{ // this is the `else` block of the previous `if`, but should it be?\n}\n\nif foo {\n} else\n\nif bar { // this is the `else` block of the previous `if`, but should it be?\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_map",
    "rule_name": "suspicious_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>map</code> followed by a <code>count</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It looks suspicious. Maybe <code>map</code> was confused with <code>filter</code>.\nIf the <code>map</code> call is intentional, this should be rewritten\nusing <code>inspect</code>. Or, if you intend to drive the iterator to\ncompletion, you can just use <code>for_each</code> instead.</p>\n<h3>Example</h3>\n<pre><code>let _ = (0..3).map(|x| x + 2).count();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_op_assign_impl",
    "rule_name": "suspicious_op_assign_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints for suspicious operations in impls of OpAssign, e.g.\nsubtracting elements in an AddAssign impl.</p>\n<h3>Why is this bad?</h3>\n<p>This is probably a typo or copy-and-paste error and not intended.</p>\n<h3>Example</h3>\n<pre><code>impl AddAssign for Foo {\n    fn add_assign(&mut self, other: Foo) {\n        *self = *self - other;\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_open_options",
    "rule_name": "suspicious_open_options",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the suspicious use of <code>OpenOptions::create()</code>\nwithout an explicit <code>OpenOptions::truncate()</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>create()</code> alone will either create a new file or open an\nexisting file. If the file already exists, it will be\noverwritten when written to, but the file will not be\ntruncated by default.\nIf less data is written to the file\nthan it already contains, the remainder of the file will\nremain unchanged, and the end of the file will contain old\ndata.\nIn most cases, one should either use <code>create_new</code> to ensure\nthe file is created from scratch, or ensure <code>truncate</code> is\ncalled so that the truncation behaviour is explicit. <code>truncate(true)</code>\nwill ensure the file is entirely overwritten with new data, whereas\n<code>truncate(false)</code> will explicitly keep the default behavior.</p>\n<h3>Example</h3>\n<pre><code>use std::fs::OpenOptions;\n\nOpenOptions::new().create(true);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fs::OpenOptions;\n\nOpenOptions::new().create(true).truncate(true);\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_operation_groupings",
    "rule_name": "suspicious_operation_groupings",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unlikely usages of binary operators that are almost\ncertainly typos and/or copy/paste errors, given the other usages\nof binary operators nearby.</p>\n<h3>Why is this bad?</h3>\n<p>They are probably bugs and if they aren\u2019t then they look like bugs\nand you should add a comment explaining why you are doing such an\nodd set of operations.</p>\n<h3>Known problems</h3>\n<p>There may be some false positives if you are trying to do something\nunusual that happens to look like a typo.</p>\n<h3>Example</h3>\n<pre><code>struct Vec3 {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nimpl Eq for Vec3 {}\n\nimpl PartialEq for Vec3 {\n    fn eq(&self, other: &Self) -> bool {\n        // This should trigger the lint because `self.x` is compared to `other.y`\n        self.x == other.y && self.y == other.y && self.z == other.z\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>// same as above except:\nimpl PartialEq for Vec3 {\n    fn eq(&self, other: &Self) -> bool {\n        // Note we now compare other.x to self.x\n        self.x == other.x && self.y == other.y && self.z == other.z\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "suspicious_splitn",
    "rule_name": "suspicious_splitn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to [<code>splitn</code>]\n(https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and\nrelated functions with either zero or one splits.</p>\n<h3>Why is this bad?</h3>\n<p>These calls don\u2019t actually split the value and are\nlikely to be intended as a different number.</p>\n<h3>Example</h3>\n<pre><code>for x in s.splitn(1, \":\") {\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for x in s.splitn(2, \":\") {\n    // ..\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "suspicious_to_owned",
    "rule_name": "suspicious_to_owned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the usage of <code>_.to_owned()</code>, on a <code>Cow<'_, _></code>.</p>\n<h3>Why is this bad?</h3>\n<p>Calling <code>to_owned()</code> on a <code>Cow</code> creates a clone of the <code>Cow</code>\nitself, without taking ownership of the <code>Cow</code> contents (i.e.\nit\u2019s equivalent to calling <code>Cow::clone</code>).\nThe similarly named <code>into_owned</code> method, on the other hand,\nclones the <code>Cow</code> contents, effectively turning any <code>Cow::Borrowed</code>\ninto a <code>Cow::Owned</code>.</p>\n<p>Given the potential ambiguity, consider replacing <code>to_owned</code>\nwith <code>clone</code> for better readability or, if getting a <code>Cow::Owned</code>\nwas the original intent, using <code>into_owned</code> instead.</p>\n<h3>Example</h3>\n<pre><code>let s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet data = cow.to_owned();\nassert!(matches!(data, Cow::Borrowed(_)))\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet data = cow.clone();\nassert!(matches!(data, Cow::Borrowed(_)))\n</code></pre>\n<p>or</p>\n<pre><code>let s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet _data: String = cow.into_owned();\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_unary_op_formatting",
    "rule_name": "suspicious_unary_op_formatting",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks the formatting of a unary operator on the right hand side\nof a binary operator. It lints if there is no space between the binary and unary operators,\nbut there is a space between the unary and its operand.</p>\n<h3>Why is this bad?</h3>\n<p>This is either a typo in the binary operator or confusing.</p>\n<h3>Example</h3>\n<pre><code>// &&! looks like a different operator\nif foo &&! bar {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if foo && !bar {}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "suspicious_xor_used_as_pow",
    "rule_name": "suspicious_xor_used_as_pow",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns for a Bitwise XOR (<code>^</code>) operator being probably confused as a powering. It will not trigger if any of the numbers are not in decimal.</p>\n<h3>Why restrict this?</h3>\n<p>It\u2019s most probably a typo and may lead to unexpected behaviours.</p>\n<h3>Example</h3>\n<pre><code>let x = 3_i32 ^ 4_i32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = 3_i32.pow(4);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "swap_ptr_to_ref",
    "rule_name": "swap_ptr_to_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>core::mem::swap</code> where either parameter is derived from a pointer</p>\n<h3>Why is this bad?</h3>\n<p>When at least one parameter to <code>swap</code> is derived from a pointer it may overlap with the\nother. This would then lead to undefined behavior.</p>\n<h3>Example</h3>\n<pre><code>unsafe fn swap(x: &[*mut u32], y: &[*mut u32]) {\n    for (&x, &y) in x.iter().zip(y) {\n        core::mem::swap(&mut *x, &mut *y);\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>unsafe fn swap(x: &[*mut u32], y: &[*mut u32]) {\n    for (&x, &y) in x.iter().zip(y) {\n        core::ptr::swap(x, y);\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "tabs_in_doc_comments",
    "rule_name": "tabs_in_doc_comments",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks doc comments for usage of tab characters.</p>\n<h3>Why is this bad?</h3>\n<p>The rust style-guide promotes spaces instead of tabs for indentation.\nTo keep a consistent view on the source, also doc comments should not have tabs.\nAlso, explaining ascii-diagrams containing tabs can get displayed incorrectly when the\ndisplay settings of the author and reader differ.</p>\n<h3>Example</h3>\n<pre><code>///\n/// Struct to hold two strings:\n/// \t- first\t\tone\n/// \t- second\tone\npub struct DoubleString {\n   ///\n   /// \t- First String:\n   /// \t\t- needs to be inside here\n   first_string: String,\n   ///\n   /// \t- Second String:\n   /// \t\t- needs to be inside here\n   second_string: String,\n}\n</code></pre>\n<p>Will be converted to:</p>\n<pre><code>///\n/// Struct to hold two strings:\n///     - first        one\n///     - second    one\npub struct DoubleString {\n   ///\n   ///     - First String:\n   ///         - needs to be inside here\n   first_string: String,\n   ///\n   ///     - Second String:\n   ///         - needs to be inside here\n   second_string: String,\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "temporary_assignment",
    "rule_name": "temporary_assignment",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for construction of a structure or tuple just to\nassign a value in it.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. If the structure is only created to be\nupdated, why not write the structure you want in the first place?</p>\n<h3>Example</h3>\n<pre><code>(0, 0).0 = 1\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "test_attr_in_doctest",
    "rule_name": "test_attr_in_doctest",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[test]</code> in doctests unless they are marked with\neither <code>ignore</code>, <code>no_run</code> or <code>compile_fail</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Code in examples marked as <code>#[test]</code> will somewhat\nsurprisingly not be run by <code>cargo test</code>. If you really want\nto show how to test stuff in an example, mark it <code>no_run</code> to\nmake the intent clear.</p>\n<h3>Examples</h3>\n<pre><code>/// An example of a doctest with a `main()` function\n///\n/// # Examples\n///\n/// ```\n/// #[test]\n/// fn equality_works() {\n///     assert_eq!(1_u8, 1);\n/// }\n/// ```\nfn test_attr_in_doctest() {\n    unimplemented!();\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "tests_outside_test_module",
    "rule_name": "tests_outside_test_module",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Triggers when a testing function (marked with the <code>#[test]</code> attribute) isn\u2019t inside a testing module\n(marked with <code>#[cfg(test)]</code>).</p>\n<h3>Why restrict this?</h3>\n<p>The idiomatic (and more performant) way of writing tests is inside a testing module (flagged with <code>#[cfg(test)]</code>),\nhaving test functions outside of this module is confusing and may lead to them being \u201chidden\u201d.</p>\n<h3>Example</h3>\n<pre><code>#[test]\nfn my_cool_test() {\n    // [...]\n}\n\n#[cfg(test)]\nmod tests {\n    // [...]\n}\n\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[cfg(test)]\nmod tests {\n    #[test]\n    fn my_cool_test() {\n        // [...]\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "to_digit_is_some",
    "rule_name": "to_digit_is_some",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.to_digit(..).is_some()</code> on <code>char</code>s.</p>\n<h3>Why is this bad?</h3>\n<p>This is a convoluted way of checking if a <code>char</code> is a digit. It\u2019s\nmore straight forward to use the dedicated <code>is_digit</code> method.</p>\n<h3>Example</h3>\n<pre><code>let is_digit = c.to_digit(radix).is_some();\n</code></pre>\n<p>can be written as:</p>\n<pre><code>let is_digit = c.is_digit(radix);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "to_string_in_format_args",
    "rule_name": "to_string_in_format_args",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <a><code>ToString::to_string</code></a>\napplied to a type that implements <a><code>Display</code></a>\nin a macro that does formatting.</p>\n<h3>Why is this bad?</h3>\n<p>Since the type implements <code>Display</code>, the use of <code>to_string</code> is\nunnecessary.</p>\n<h3>Example</h3>\n<pre><code>println!(\"error: something failed at {}\", Location::caller().to_string());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!(\"error: something failed at {}\", Location::caller());\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "to_string_trait_impl",
    "rule_name": "to_string_trait_impl",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for direct implementations of <code>ToString</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This trait is automatically implemented for any type which implements the <code>Display</code> trait.\nAs such, <code>ToString</code> shouldn\u2019t be implemented directly: <code>Display</code> should be implemented instead,\nand you get the <code>ToString</code> implementation for free.</p>\n<h3>Example</h3>\n<pre><code>struct Point {\n  x: usize,\n  y: usize,\n}\n\nimpl ToString for Point {\n  fn to_string(&self) -> String {\n    format!(\"({}, {})\", self.x, self.y)\n  }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct Point {\n  x: usize,\n  y: usize,\n}\n\nimpl std::fmt::Display for Point {\n  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n    write!(f, \"({}, {})\", self.x, self.y)\n  }\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "todo",
    "rule_name": "todo",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>todo!</code>.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>todo!</code> macro indicates the presence of unfinished code,\nso it should not be present in production code.</p>\n<h3>Example</h3>\n<pre><code>todo!();\n</code></pre>\n<p>Finish the implementation, or consider marking it as explicitly unimplemented.</p>\n<pre><code>unimplemented!();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "too_long_first_doc_paragraph",
    "rule_name": "too_long_first_doc_paragraph",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks if the first paragraph in the documentation of items listed in the module page is too long.</p>\n<h3>Why is this bad?</h3>\n<p>Documentation will show the first paragraph of the docstring in the summary page of a\nmodule. Having a nice, short summary in the first paragraph is part of writing good docs.</p>\n<h3>Example</h3>\n<pre><code>/// A very short summary.\n/// A much longer explanation that goes into a lot more detail about\n/// how the thing works, possibly with doclinks and so one,\n/// and probably spanning a many rows.\nstruct Foo {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>/// A very short summary.\n///\n/// A much longer explanation that goes into a lot more detail about\n/// how the thing works, possibly with doclinks and so one,\n/// and probably spanning a many rows.\nstruct Foo {}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "too_many_arguments",
    "rule_name": "too_many_arguments",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions with too many parameters.</p>\n<h3>Why is this bad?</h3>\n<p>Functions with lots of parameters are considered bad\nstyle and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\ngrouping some parameters into a new type.</p>\n<h3>Example</h3>\n<pre><code>fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n    // ..\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>too-many-arguments-threshold</code>:  The maximum number of argument a function or method can have</p>\n<p>(default: <code>7</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "too_many_lines",
    "rule_name": "too_many_lines",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions with a large amount of lines.</p>\n<h3>Why is this bad?</h3>\n<p>Functions with a lot of lines are harder to understand\ndue to having to look at a larger amount of code to understand what the\nfunction is doing. Consider splitting the body of the function into\nmultiple functions.</p>\n<h3>Example</h3>\n<pre><code>fn im_too_long() {\n    println!(\"\");\n    // ... 100 more LoC\n    println!(\"\");\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>too-many-lines-threshold</code>:  The maximum number of lines a function or method can have</p>\n<p>(default: <code>100</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "toplevel_ref_arg",
    "rule_name": "toplevel_ref_arg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for function arguments and let bindings denoted as\n<code>ref</code>.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>ref</code> declaration makes the function take an owned\nvalue, but turns the argument into a reference (which means that the value\nis destroyed when exiting the function). This adds not much value: either\ntake a reference type, or take an owned value and create references in the\nbody.</p>\n<p>For let bindings, <code>let x = &foo;</code> is preferred over <code>let ref x = foo</code>. The\ntype of <code>x</code> is more obvious with the former.</p>\n<h3>Known problems</h3>\n<p>If the argument is dereferenced within the function,\nremoving the <code>ref</code> will lead to errors. This can be fixed by removing the\ndereferences, e.g., changing <code>*x</code> to <code>x</code> within the function.</p>\n<h3>Example</h3>\n<pre><code>fn foo(ref _x: u8) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(_x: &u8) {}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "trailing_empty_array",
    "rule_name": "trailing_empty_array",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Displays a warning when a struct with a trailing zero-sized array is declared without a <code>repr</code> attribute.</p>\n<h3>Why is this bad?</h3>\n<p>Zero-sized arrays aren\u2019t very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjunction with manual allocation to make it easy to compute the offset of the array). Either way, <code>#[repr(C)]</code> (or another <code>repr</code> attribute) is needed.</p>\n<h3>Example</h3>\n<pre><code>struct RarelyUseful {\n    some_field: u32,\n    last: [u32; 0],\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[repr(C)]\nstruct MoreOftenUseful {\n    some_field: usize,\n    last: [u32; 0],\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "trait_duplication_in_bounds",
    "rule_name": "trait_duplication_in_bounds",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for cases where generics or trait objects are being used and multiple\nsyntax specifications for trait bounds are used simultaneously.</p>\n<h3>Why is this bad?</h3>\n<p>Duplicate bounds makes the code\nless readable than specifying them only once.</p>\n<h3>Example</h3>\n<pre><code>fn func<T: Clone + Default>(arg: T) where T: Clone + Default {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn func<T: Clone + Default>(arg: T) {}\n\n// or\n\nfn func<T>(arg: T) where T: Clone + Default {}\n</code></pre>\n<pre><code>fn foo<T: Default + Default>(bar: T) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo<T: Default>(bar: T) {}\n</code></pre>\n<pre><code>fn foo<T>(bar: T) where T: Default + Default {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo<T>(bar: T) where T: Default {}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "transmute_bytes_to_str",
    "rule_name": "transmute_bytes_to_str",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from a <code>&[u8]</code> to a <code>&str</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Not every byte slice is a valid UTF-8 string.</p>\n<h3>Known problems</h3>\n<ul>\n<li><a><code>from_utf8</code></a> which this lint suggests using is slower than <code>transmute</code>\nas it needs to validate the input.\nIf you are certain that the input is always a valid UTF-8,\nuse <a><code>from_utf8_unchecked</code></a> which is as fast as <code>transmute</code>\nbut has a semantically meaningful name.</li>\n<li>You might want to handle errors returned from <a><code>from_utf8</code></a> instead of calling <code>unwrap</code>.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let b: &[u8] = &[1_u8, 2_u8];\nunsafe {\n    let _: &str = std::mem::transmute(b); // where b: &[u8]\n}\n\n// should be:\nlet _ = std::str::from_utf8(b).unwrap();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_float_to_int",
    "rule_name": "transmute_float_to_int",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from a float to an integer.</p>\n<h3>Why is this bad?</h3>\n<p>Transmutes are dangerous and error-prone, whereas <code>to_bits</code> is intuitive\nand safe.</p>\n<h3>Example</h3>\n<pre><code>unsafe {\n    let _: u32 = std::mem::transmute(1f32);\n}\n\n// should be:\nlet _: u32 = 1f32.to_bits();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_int_to_bool",
    "rule_name": "transmute_int_to_bool",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from an integer to a <code>bool</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This might result in an invalid in-memory representation of a <code>bool</code>.</p>\n<h3>Example</h3>\n<pre><code>let x = 1_u8;\nunsafe {\n    let _: bool = std::mem::transmute(x); // where x: u8\n}\n\n// should be:\nlet _: bool = x != 0;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_int_to_char",
    "rule_name": "transmute_int_to_char",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from an integer to a <code>char</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Not every integer is a Unicode scalar value.</p>\n<h3>Known problems</h3>\n<ul>\n<li><a><code>from_u32</code></a> which this lint suggests using is slower than <code>transmute</code>\nas it needs to validate the input.\nIf you are certain that the input is always a valid Unicode scalar value,\nuse <a><code>from_u32_unchecked</code></a> which is as fast as <code>transmute</code>\nbut has a semantically meaningful name.</li>\n<li>You might want to handle <code>None</code> returned from <a><code>from_u32</code></a> instead of calling <code>unwrap</code>.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>let x = 1_u32;\nunsafe {\n    let _: char = std::mem::transmute(x); // where x: u32\n}\n\n// should be:\nlet _ = std::char::from_u32(x).unwrap();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_int_to_float",
    "rule_name": "transmute_int_to_float",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from an integer to a float.</p>\n<h3>Why is this bad?</h3>\n<p>Transmutes are dangerous and error-prone, whereas <code>from_bits</code> is intuitive\nand safe.</p>\n<h3>Example</h3>\n<pre><code>unsafe {\n    let _: f32 = std::mem::transmute(1_u32); // where x: u32\n}\n\n// should be:\nlet _: f32 = f32::from_bits(1_u32);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_int_to_non_zero",
    "rule_name": "transmute_int_to_non_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from <code>T</code> to <code>NonZero<T></code>, and suggests the <code>new_unchecked</code>\nmethod instead.</p>\n<h3>Why is this bad?</h3>\n<p>Transmutes work on any types and thus might cause unsoundness when those types change\nelsewhere. <code>new_unchecked</code> only works for the appropriate types instead.</p>\n<h3>Example</h3>\n<pre><code>let _: NonZero<u32> = unsafe { std::mem::transmute(123) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _: NonZero<u32> = unsafe { NonZero::new_unchecked(123) };\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_null_to_fn",
    "rule_name": "transmute_null_to_fn",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for null function pointer creation through transmute.</p>\n<h3>Why is this bad?</h3>\n<p>Creating a null function pointer is undefined behavior.</p>\n<p>More info: https://doc.rust-lang.org/nomicon/ffi.html#the-nullable-pointer-optimization</p>\n<h3>Known problems</h3>\n<p>Not all cases can be detected at the moment of this writing.\nFor example, variables which hold a null pointer and are then fed to a <code>transmute</code>\ncall, aren\u2019t detectable yet.</p>\n<h3>Example</h3>\n<pre><code>let null_fn: fn() = unsafe { std::mem::transmute( std::ptr::null::<()>() ) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let null_fn: Option<fn()> = None;\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "transmute_num_to_bytes",
    "rule_name": "transmute_num_to_bytes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from a number to an array of <code>u8</code></p>\n<h3>Why this is bad?</h3>\n<p>Transmutes are dangerous and error-prone, whereas <code>to_ne_bytes</code>\nis intuitive and safe.</p>\n<h3>Example</h3>\n<pre><code>unsafe {\n    let x: [u8; 8] = std::mem::transmute(1i64);\n}\n\n// should be\nlet x: [u8; 8] = 0i64.to_ne_bytes();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_ptr_to_ptr",
    "rule_name": "transmute_ptr_to_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from a pointer to a pointer, or\nfrom a reference to a reference.</p>\n<h3>Why is this bad?</h3>\n<p>Transmutes are dangerous, and these can instead be\nwritten as casts.</p>\n<h3>Example</h3>\n<pre><code>let ptr = &1u32 as *const u32;\nunsafe {\n    // pointer-to-pointer transmute\n    let _: *const f32 = std::mem::transmute(ptr);\n    // ref-ref transmute\n    let _: &f32 = std::mem::transmute(&1u32);\n}\n// These can be respectively written:\nlet _ = ptr as *const f32;\nlet _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "transmute_ptr_to_ref",
    "rule_name": "transmute_ptr_to_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes from a pointer to a reference.</p>\n<h3>Why is this bad?</h3>\n<p>This can always be rewritten with <code>&</code> and <code>*</code>.</p>\n<h3>Known problems</h3>\n<ul>\n<li><code>mem::transmute</code> in statics and constants is stable from Rust 1.46.0,\nwhile dereferencing raw pointer is not stable yet.\nIf you need to do this in those places,\nyou would have to use <code>transmute</code> instead.</li>\n</ul>\n<h3>Example</h3>\n<pre><code>unsafe {\n    let _: &T = std::mem::transmute(p); // where p: *const T\n}\n\n// can be written:\nlet _: &T = &*p;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmute_undefined_repr",
    "rule_name": "transmute_undefined_repr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes between types which do not have a representation defined relative to\neach other.</p>\n<h3>Why is this bad?</h3>\n<p>The results of such a transmute are not defined.</p>\n<h3>Known problems</h3>\n<p>This lint has had multiple problems in the past and was moved to <code>nursery</code>. See issue\n<a>#8496</a> for more details.</p>\n<h3>Example</h3>\n<pre><code>struct Foo<T>(u32, T);\nlet _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[repr(C)]\nstruct Foo<T>(u32, T);\nlet _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "transmutes_expressible_as_ptr_casts",
    "rule_name": "transmutes_expressible_as_ptr_casts",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes that could be a pointer cast.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. The code tricks people into thinking that\nsomething complex is going on.</p>\n<h3>Example</h3>\n<pre><code>unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>p as *const [u16];\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "transmuting_null",
    "rule_name": "transmuting_null",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmute calls which would receive a null pointer.</p>\n<h3>Why is this bad?</h3>\n<p>Transmuting a null pointer is undefined behavior.</p>\n<h3>Known problems</h3>\n<p>Not all cases can be detected at the moment of this writing.\nFor example, variables which hold a null pointer and are then fed to a <code>transmute</code>\ncall, aren\u2019t detectable yet.</p>\n<h3>Example</h3>\n<pre><code>let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "trim_split_whitespace",
    "rule_name": "trim_split_whitespace",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns about calling <code>str::trim</code> (or variants) before <code>str::split_whitespace</code>.</p>\n<h3>Why is this bad?</h3>\n<p><code>split_whitespace</code> already ignores leading and trailing whitespace.</p>\n<h3>Example</h3>\n<pre><code>\" A B C \".trim().split_whitespace();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>\" A B C \".split_whitespace();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "trivial_regex",
    "rule_name": "trivial_regex",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for trivial <a>regex</a>\ncreation (with <code>Regex::new</code>, <code>RegexBuilder::new</code>, or <code>RegexSet::new</code>).</p>\n<h3>Why is this bad?</h3>\n<p>Matching the regex can likely be replaced by <code>==</code> or\n<code>str::starts_with</code>, <code>str::ends_with</code> or <code>std::contains</code> or other <code>str</code>\nmethods.</p>\n<h3>Known problems</h3>\n<p>If the same regex is going to be applied to multiple\ninputs, the precomputations done by <code>Regex</code> construction can give\nsignificantly better performance than any of the <code>str</code>-based methods.</p>\n<h3>Example</h3>\n<pre><code>Regex::new(\"^foobar\")\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "trivially_copy_pass_by_ref",
    "rule_name": "trivially_copy_pass_by_ref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions taking arguments by reference, where\nthe argument type is <code>Copy</code> and small enough to be more efficient to always\npass by value.</p>\n<h3>Why is this bad?</h3>\n<p>In many calling conventions instances of structs will\nbe passed through registers if they fit into two or less general purpose\nregisters.</p>\n<h3>Known problems</h3>\n<p>This lint is target register size dependent, it is\nlimited to 32-bit to try and reduce portability problems between 32 and\n64-bit, but if you are compiling for 8 or 16-bit targets then the limit\nwill be different.</p>\n<p>The configuration option <code>trivial_copy_size_limit</code> can be set to override\nthis limit for a project.</p>\n<p>This lint attempts to allow passing arguments by reference if a reference\nto that argument is returned. This is implemented by comparing the lifetime\nof the argument and return value for equality. However, this can cause\nfalse positives in cases involving multiple lifetimes that are bounded by\neach other.</p>\n<p>Also, it does not take account of other similar cases where getting memory addresses\nmatters; namely, returning the pointer to the argument in question,\nand passing the argument, as both references and pointers,\nto a function that needs the memory address. For further details, refer to\n<a>this issue</a>\nthat explains a real case in which this false positive\nled to an <strong>undefined behavior</strong> introduced with unsafe code.</p>\n<h3>Example</h3>\n<pre><code>fn foo(v: &u32) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo(v: u32) {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>trivial-copy-size-limit</code>:  The maximum size (in bytes) to consider a <code>Copy</code> type for passing by value instead of by\nreference.</p>\n<p>(default: <code>target_pointer_width * 2</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "try_err",
    "rule_name": "try_err",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Err(x)?</code>.</p>\n<h3>Why restrict this?</h3>\n<p>The <code>?</code> operator is designed to allow calls that\ncan fail to be easily chained. For example, <code>foo()?.bar()</code> or\n<code>foo(bar()?)</code>. Because <code>Err(x)?</code> can\u2019t be used that way (it will\nalways return), it is more clear to write <code>return Err(x)</code>.</p>\n<h3>Example</h3>\n<pre><code>fn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      Err(\"failed\")?;\n    }\n    Ok(0)\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>fn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      return Err(\"failed\".into());\n    }\n    Ok(0)\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "tuple_array_conversions",
    "rule_name": "tuple_array_conversions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for tuple<=>array conversions that are not done with <code>.into()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It may be unnecessary complexity. <code>.into()</code> works for converting tuples<=> arrays of up to\n12 elements and conveys the intent more clearly, while also leaving less room for hard to\nspot bugs!</p>\n<h3>Known issues</h3>\n<p>The suggested code may hide potential asymmetry in some cases. See\n<a>#11085</a> for more info.</p>\n<h3>Example</h3>\n<pre><code>let t1 = &[(1, 2), (3, 4)];\nlet v1: Vec<[u32; 2]> = t1.iter().map(|&(a, b)| [a, b]).collect();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let t1 = &[(1, 2), (3, 4)];\nlet v1: Vec<[u32; 2]> = t1.iter().map(|&t| t.into()).collect();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "type_complexity",
    "rule_name": "type_complexity",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for types used in structs, parameters and <code>let</code>\ndeclarations above a certain complexity threshold.</p>\n<h3>Why is this bad?</h3>\n<p>Too complex types make the code less readable. Consider\nusing a <code>type</code> definition to simplify them.</p>\n<h3>Example</h3>\n<pre><code>struct PointMatrixContainer {\n    matrix: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n}\n\nfn main() {\n    let point_matrix: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![\n        vec![\n            Box::new((1, 2, 3, 4)),\n            Box::new((5, 6, 7, 8)),\n        ],\n        vec![\n            Box::new((9, 10, 11, 12)),\n        ],\n    ];\n\n    let shared_point_matrix: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> = Rc::new(point_matrix);\n\n    let container = PointMatrixContainer {\n        matrix: shared_point_matrix,\n    };\n\n    // ...\n}\n</code></pre>\n<p>Use instead:</p>\n<h3>Example</h3>\n<pre><code>type PointMatrix = Vec<Vec<Box<(u32, u32, u32, u32)>>>;\ntype SharedPointMatrix = Rc<PointMatrix>;\n\nstruct PointMatrixContainer {\n    matrix: SharedPointMatrix,\n}\n\nfn main() {\n    let point_matrix: PointMatrix = vec![\n        vec![\n            Box::new((1, 2, 3, 4)),\n            Box::new((5, 6, 7, 8)),\n        ],\n        vec![\n            Box::new((9, 10, 11, 12)),\n        ],\n    ];\n\n    let shared_point_matrix: SharedPointMatrix = Rc::new(point_matrix);\n\n    let container = PointMatrixContainer {\n        matrix: shared_point_matrix,\n    };\n\n    // ...\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>type-complexity-threshold</code>:  The maximum complexity a type can have</p>\n<p>(default: <code>250</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "type_id_on_box",
    "rule_name": "type_id_on_box",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for calls to <code>.type_id()</code> on a <code>Box<dyn _></code>.</p>\n<h3>Why is this bad?</h3>\n<p>This almost certainly does not do what the user expects and can lead to subtle bugs.\nCalling <code>.type_id()</code> on a <code>Box<dyn Trait></code> returns a fixed <code>TypeId</code> of the <code>Box</code> itself,\nrather than returning the <code>TypeId</code> of the underlying type behind the trait object.</p>\n<p>For <code>Box<dyn Any></code> specifically (and trait objects that have <code>Any</code> as its supertrait),\nthis lint will provide a suggestion, which is to dereference the receiver explicitly\nto go from <code>Box<dyn Any></code> to <code>dyn Any</code>.\nThis makes sure that <code>.type_id()</code> resolves to a dynamic call on the trait object\nand not on the box.</p>\n<p>If the fixed <code>TypeId</code> of the <code>Box</code> is the intended behavior, it\u2019s better to be explicit about it\nand write <code>TypeId::of::<Box<dyn Trait>>()</code>:\nthis makes it clear that a fixed <code>TypeId</code> is returned and not the <code>TypeId</code> of the implementor.</p>\n<h3>Example</h3>\n<pre><code>use std::any::{Any, TypeId};\n\nlet any_box: Box<dyn Any> = Box::new(42_i32);\nassert_eq!(any_box.type_id(), TypeId::of::<i32>()); // \u26a0\ufe0f this fails!\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::any::{Any, TypeId};\n\nlet any_box: Box<dyn Any> = Box::new(42_i32);\nassert_eq!((*any_box).type_id(), TypeId::of::<i32>());\n//          ^ dereference first, to call `type_id` on `dyn Any`\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "type_repetition_in_bounds",
    "rule_name": "type_repetition_in_bounds",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns about unnecessary type repetitions in trait bounds</p>\n<h3>Why is this bad?</h3>\n<p>Repeating the type for every bound makes the code\nless readable than combining the bounds</p>\n<h3>Example</h3>\n<pre><code>pub fn foo<T>(t: T) where T: Copy, T: Clone {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub fn foo<T>(t: T) where T: Copy + Clone {}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>max-trait-bounds</code>:  The maximum number of bounds a trait can have to be linted</p>\n<p>(default: <code>3</code>)</p>\n</li>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "unchecked_duration_subtraction",
    "rule_name": "unchecked_duration_subtraction",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Lints subtraction between an <code>Instant</code> and a <code>Duration</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Unchecked subtraction could cause underflow on certain platforms, leading to\nunintentional panics.</p>\n<h3>Example</h3>\n<pre><code>let time_passed = Instant::now() - Duration::from_secs(5);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let time_passed = Instant::now().checked_sub(Duration::from_secs(5));\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unconditional_recursion",
    "rule_name": "unconditional_recursion",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks that there isn\u2019t an infinite recursion in trait\nimplementations.</p>\n<h3>Why is this bad?</h3>\n<p>This is a hard to find infinite recursion that will crash any code\nusing it.</p>\n<h3>Example</h3>\n<pre><code>enum Foo {\n    A,\n    B,\n}\n\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool {\n        self == other // bad!\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<p>In such cases, either use <code>#[derive(PartialEq)]</code> or don\u2019t implement it.</p>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "undocumented_unsafe_blocks",
    "rule_name": "undocumented_unsafe_blocks",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>unsafe</code> blocks and impls without a <code>// SAFETY: </code> comment\nexplaining why the unsafe operations performed inside\nthe block are safe.</p>\n<p>Note the comment must appear on the line(s) preceding the unsafe block\nwith nothing appearing in between. The following is ok:</p>\n<pre><code>foo(\n    // SAFETY:\n    // This is a valid safety comment\n    unsafe { *x }\n)\n</code></pre>\n<p>But neither of these are:</p>\n<pre><code>// SAFETY:\n// This is not a valid safety comment\nfoo(\n    /* SAFETY: Neither is this */ unsafe { *x },\n);\n</code></pre>\n<h3>Why restrict this?</h3>\n<p>Undocumented unsafe blocks and impls can make it difficult to read and maintain code.\nWriting out the safety justification may help in discovering unsoundness or bugs.</p>\n<h3>Example</h3>\n<pre><code>use std::ptr::NonNull;\nlet a = &mut 42;\n\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::ptr::NonNull;\nlet a = &mut 42;\n\n// SAFETY: references are guaranteed to be non-null.\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>accept-comment-above-attributes</code>:  Whether to accept a safety comment to be placed above the attributes for the <code>unsafe</code> block</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>accept-comment-above-statement</code>:  Whether to accept a safety comment to be placed above the statement containing the <code>unsafe</code> block</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unicode_not_nfc",
    "rule_name": "unicode_not_nfc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for string literals that contain Unicode in a form\nthat is not equal to its\n<a>NFC-recomposition</a>.</p>\n<h3>Why is this bad?</h3>\n<p>If such a string is compared to another, the results\nmay be surprising.</p>\n<h3>Example</h3>\n<p>You may not see it, but \u201ca\u0300\u201d\u201c and \u201c\u00e0\u201d\u201c aren\u2019t the same string. The\nformer when escaped is actually <code>\"a\\u{300}\"</code> while the latter is <code>\"\\u{e0}\"</code>.</p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unimplemented",
    "rule_name": "unimplemented",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>unimplemented!</code>.</p>\n<h3>Why restrict this?</h3>\n<p>This macro, or panics in general, may be unwanted in production code.</p>\n<h3>Example</h3>\n<pre><code>unimplemented!();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "uninhabited_references",
    "rule_name": "uninhabited_references",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>It detects references to uninhabited types, such as <code>!</code> and\nwarns when those are either dereferenced or returned from a function.</p>\n<h3>Why is this bad?</h3>\n<p>Dereferencing a reference to an uninhabited type would create\nan instance of such a type, which cannot exist. This constitutes\nundefined behaviour. Such a reference could have been created\nby <code>unsafe</code> code.</p>\n<h3>Example</h3>\n<p>The following function can return a reference to an uninhabited type\n(<code>Infallible</code>) because it uses <code>unsafe</code> code to create it. However,\nthe user of such a function could dereference the return value and\ntrigger an undefined behavior from safe code.</p>\n<pre><code>fn create_ref() -> &'static std::convert::Infallible {\n    unsafe { std::mem::transmute(&()) }\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "uninit_assumed_init",
    "rule_name": "uninit_assumed_init",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>MaybeUninit::uninit().assume_init()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>For most types, this is undefined behavior.</p>\n<h3>Known problems</h3>\n<p>For now, we accept empty tuples and tuples / arrays\nof <code>MaybeUninit</code>. There may be other types that allow uninitialized\ndata, but those are not yet rigorously defined.</p>\n<h3>Example</h3>\n<pre><code>// Beware the UB\nuse std::mem::MaybeUninit;\n\nlet _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n</code></pre>\n<p>Note that the following is OK:</p>\n<pre><code>use std::mem::MaybeUninit;\n\nlet _: [MaybeUninit<bool>; 5] = unsafe {\n    MaybeUninit::uninit().assume_init()\n};\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "uninit_vec",
    "rule_name": "uninit_vec",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>set_len()</code> call that creates <code>Vec</code> with uninitialized elements.\nThis is commonly caused by calling <code>set_len()</code> right after allocating or\nreserving a buffer with <code>new()</code>, <code>default()</code>, <code>with_capacity()</code>, or <code>reserve()</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It creates a <code>Vec</code> with uninitialized data, which leads to\nundefined behavior with most safe operations. Notably, uninitialized\n<code>Vec<u8></code> must not be used with generic <code>Read</code>.</p>\n<p>Moreover, calling <code>set_len()</code> on a <code>Vec</code> created with <code>new()</code> or <code>default()</code>\ncreates out-of-bound values that lead to heap memory corruption when used.</p>\n<h3>Known Problems</h3>\n<p>This lint only checks directly adjacent statements.</p>\n<h3>Example</h3>\n<pre><code>let mut vec: Vec<u8> = Vec::with_capacity(1000);\nunsafe { vec.set_len(1000); }\nreader.read(&mut vec); // undefined behavior!\n</code></pre>\n<h3>How to fix?</h3>\n<ol>\n<li>Use an initialized buffer:\n<pre><code>let mut vec: Vec<u8> = vec![0; 1000];\nreader.read(&mut vec);\n</code></pre>\n</li>\n<li>Wrap the content in <code>MaybeUninit</code>:\n<pre><code>let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\nvec.set_len(1000);  // `MaybeUninit` can be uninitialized\n</code></pre>\n</li>\n<li>If you are on 1.60.0 or later, <code>Vec::spare_capacity_mut()</code> is available:\n<pre><code>let mut vec: Vec<u8> = Vec::with_capacity(1000);\nlet remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`\n// perform initialization with `remaining`\nvec.set_len(...);  // Safe to call `set_len()` on initialized part\n</code></pre>\n</li>\n</ol>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "uninlined_format_args",
    "rule_name": "uninlined_format_args",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detect when a variable is not inlined in a format string,\nand suggests to inline it.</p>\n<h3>Why is this bad?</h3>\n<p>Non-inlined code is slightly more difficult to read and understand,\nas it requires arguments to be matched against the format string.\nThe inlined syntax, where allowed, is simpler.</p>\n<h3>Example</h3>\n<pre><code>format!(\"{}\", var);\nformat!(\"{v:?}\", v = var);\nformat!(\"{0} {0}\", var);\nformat!(\"{0:1$}\", var, width);\nformat!(\"{:.*}\", prec, var);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>format!(\"{var}\");\nformat!(\"{var:?}\");\nformat!(\"{var} {var}\");\nformat!(\"{var:width$}\");\nformat!(\"{var:.prec$}\");\n</code></pre>\n<p>If allow-mixed-uninlined-format-args is set to false in clippy.toml,\nthe following code will also trigger the lint:</p>\n<pre><code>format!(\"{} {}\", var, 1+2);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>format!(\"{var} {}\", 1+2);\n</code></pre>\n<h3>Known Problems</h3>\n<p>If a format string contains a numbered argument that cannot be inlined\nnothing will be suggested, e.g. <code>println!(\"{0}={1}\", var, 1+2)</code>.</p>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-mixed-uninlined-format-args</code>:  Whether to allow mixed uninlined format args, e.g. <code>format!(\"{} {}\", a, foo.bar)</code></p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unit_arg",
    "rule_name": "unit_arg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for passing a unit value as an argument to a function without using a\nunit literal (<code>()</code>).</p>\n<h3>Why is this bad?</h3>\n<p>This is likely the result of an accidental semicolon.</p>\n<h3>Example</h3>\n<pre><code>foo({\n    let a = bar();\n    baz(a);\n})\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unit_cmp",
    "rule_name": "unit_cmp",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for comparisons to unit. This includes all binary\ncomparisons (like <code>==</code> and <code><</code>) and asserts.</p>\n<h3>Why is this bad?</h3>\n<p>Unit is always equal to itself, and thus is just a\nclumsily written constant. Mostly this happens when someone accidentally\nadds semicolons at the end of the operands.</p>\n<h3>Example</h3>\n<pre><code>if {\n    foo();\n} == {\n    bar();\n} {\n    baz();\n}\n</code></pre>\n<p>is equal to</p>\n<pre><code>{\n    foo();\n    bar();\n    baz();\n}\n</code></pre>\n<p>For asserts:</p>\n<pre><code>assert_eq!({ foo(); }, { bar(); });\n</code></pre>\n<p>will always succeed</p>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "unit_hash",
    "rule_name": "unit_hash",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects <code>().hash(_)</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Hashing a unit value doesn\u2019t do anything as the implementation of <code>Hash</code> for <code>()</code> is a no-op.</p>\n<h3>Example</h3>\n<pre><code>match my_enum {\n\tEmpty => ().hash(&mut state),\n\tWithValue(x) => x.hash(&mut state),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match my_enum {\n\tEmpty => 0_u8.hash(&mut state),\n\tWithValue(x) => x.hash(&mut state),\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "unit_return_expecting_ord",
    "rule_name": "unit_return_expecting_ord",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions that expect closures of type\nFn(\u2026) -> Ord where the implemented closure returns the unit type.\nThe lint also suggests to remove the semi-colon at the end of the statement if present.</p>\n<h3>Why is this bad?</h3>\n<p>Likely, returning the unit type is unintentional, and\ncould simply be caused by an extra semi-colon. Since () implements Ord\nit doesn\u2019t cause a compilation error.\nThis is the same reasoning behind the unit_cmp lint.</p>\n<h3>Known problems</h3>\n<p>If returning unit is intentional, then there is no\nway of specifying this without triggering needless_return lint</p>\n<h3>Example</h3>\n<pre><code>let mut twins = vec![(1, 1), (2, 2)];\ntwins.sort_by_key(|x| { x.1; });\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "unnecessary_box_returns",
    "rule_name": "unnecessary_box_returns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for a return type containing a <code>Box<T></code> where <code>T</code> implements <code>Sized</code></p>\n<p>The lint ignores <code>Box<T></code> where <code>T</code> is larger than <code>unnecessary_box_size</code>,\nas returning a large <code>T</code> directly may be detrimental to performance.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s better to just return <code>T</code> in these cases. The caller may not need\nthe value to be boxed, and it\u2019s expensive to free the memory once the\n<code>Box<T></code> been dropped.</p>\n<h3>Example</h3>\n<pre><code>fn foo() -> Box<String> {\n    Box::new(String::from(\"Hello, world!\"))\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo() -> String {\n    String::from(\"Hello, world!\")\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>unnecessary-box-size</code>:  The byte size a <code>T</code> in <code>Box<T></code> can have, below which it triggers the <code>clippy::unnecessary_box</code> lint</p>\n<p>(default: <code>128</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_cast",
    "rule_name": "unnecessary_cast",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for casts to the same type, casts of int literals to integer\ntypes, casts of float literals to float types, and casts between raw\npointers that don\u2019t change type or constness.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s just unnecessary.</p>\n<h3>Known problems</h3>\n<p>When the expression on the left is a function call, the lint considers\nthe return type to be a type alias if it\u2019s aliased through a <code>use</code>\nstatement (like <code>use std::io::Result as IoResult</code>). It will not lint\nsuch cases.</p>\n<p>This check will only work on primitive types without any intermediate\nreferences: raw pointers and trait objects may or may not work.</p>\n<h3>Example</h3>\n<pre><code>let _ = 2i32 as i32;\nlet _ = 0.5 as f32;\n</code></pre>\n<p>Better:</p>\n<pre><code>let _ = 2_i32;\nlet _ = 0.5_f32;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_clippy_cfg",
    "rule_name": "unnecessary_clippy_cfg",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>#[cfg_attr(clippy, allow(clippy::lint))]</code>\nand suggests to replace it with <code>#[allow(clippy::lint)]</code>.</p>\n<h3>Why is this bad?</h3>\n<p>There is no reason to put clippy attributes behind a clippy <code>cfg</code> as they are not\nrun by anything else than clippy.</p>\n<h3>Example</h3>\n<pre><code>#![cfg_attr(clippy, allow(clippy::deprecated_cfg_attr))]\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#![allow(clippy::deprecated_cfg_attr)]\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_fallible_conversions",
    "rule_name": "unnecessary_fallible_conversions",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>TryInto::try_into</code> and <code>TryFrom::try_from</code> when their infallible counterparts\ncould be used.</p>\n<h3>Why is this bad?</h3>\n<p>In those cases, the <code>TryInto</code> and <code>TryFrom</code> trait implementation is a blanket impl that forwards\nto <code>Into</code> or <code>From</code>, which always succeeds.\nThe returned <code>Result<_, Infallible></code> requires error handling to get the contained value\neven though the conversion can never fail.</p>\n<h3>Example</h3>\n<pre><code>let _: Result<i64, _> = 1i32.try_into();\nlet _: Result<i64, _> = <_>::try_from(1i32);\n</code></pre>\n<p>Use <code>from</code>/<code>into</code> instead:</p>\n<pre><code>let _: i64 = 1i32.into();\nlet _: i64 = <_>::from(1i32);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_filter_map",
    "rule_name": "unnecessary_filter_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>filter_map</code> calls that could be replaced by <code>filter</code> or <code>map</code>.\nMore specifically it checks if the closure provided is only performing one of the\nfilter or map operations and suggests the appropriate option.</p>\n<h3>Why is this bad?</h3>\n<p>Complexity. The intent is also clearer if only a single\noperation is being performed.</p>\n<h3>Example</h3>\n<pre><code>let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n\n// As there is no transformation of the argument this could be written as:\nlet _ = (0..3).filter(|&x| x > 2);\n</code></pre>\n<pre><code>let _ = (0..4).filter_map(|x| Some(x + 1));\n\n// As there is no conditional check on the argument this could be written as:\nlet _ = (0..4).map(|x| x + 1);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_find_map",
    "rule_name": "unnecessary_find_map",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>find_map</code> calls that could be replaced by <code>find</code> or <code>map</code>. More\nspecifically it checks if the closure provided is only performing one of the\nfind or map operations and suggests the appropriate option.</p>\n<h3>Why is this bad?</h3>\n<p>Complexity. The intent is also clearer if only a single\noperation is being performed.</p>\n<h3>Example</h3>\n<pre><code>let _ = (0..3).find_map(|x| if x > 2 { Some(x) } else { None });\n\n// As there is no transformation of the argument this could be written as:\nlet _ = (0..3).find(|&x| x > 2);\n</code></pre>\n<pre><code>let _ = (0..4).find_map(|x| Some(x + 1));\n\n// As there is no conditional check on the argument this could be written as:\nlet _ = (0..4).map(|x| x + 1).next();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_first_then_check",
    "rule_name": "unnecessary_first_then_check",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks the usage of <code>.first().is_some()</code> or <code>.first().is_none()</code> to check if a slice is\nempty.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>.is_empty()</code> is shorter and better communicates the intention.</p>\n<h3>Example</h3>\n<pre><code>let v = vec![1, 2, 3];\nif v.first().is_none() {\n    // The vector is empty...\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let v = vec![1, 2, 3];\nif v.is_empty() {\n    // The vector is empty...\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_fold",
    "rule_name": "unnecessary_fold",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>fold</code> when a more succinct alternative exists.\nSpecifically, this checks for <code>fold</code>s which could be replaced by <code>any</code>, <code>all</code>,\n<code>sum</code> or <code>product</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Readability.</p>\n<h3>Example</h3>\n<pre><code>(0..3).fold(false, |acc, x| acc || x > 2);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>(0..3).any(|x| x > 2);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_get_then_check",
    "rule_name": "unnecessary_get_then_check",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks the usage of <code>.get().is_some()</code> or <code>.get().is_none()</code> on std map types.</p>\n<h3>Why is this bad?</h3>\n<p>It can be done in one call with <code>.contains()</code>/<code>.contains_key()</code>.</p>\n<h3>Example</h3>\n<pre><code>let s: HashSet<String> = HashSet::new();\nif s.get(\"a\").is_some() {\n    // code\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s: HashSet<String> = HashSet::new();\nif s.contains(\"a\") {\n    // code\n}\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_join",
    "rule_name": "unnecessary_join",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.collect::<Vec<String>>().join(\"\")</code> on iterators.</p>\n<h3>Why is this bad?</h3>\n<p><code>.collect::<String>()</code> is more concise and might be more performant</p>\n<h3>Example</h3>\n<pre><code>let vector = vec![\"hello\",  \"world\"];\nlet output = vector.iter().map(|item| item.to_uppercase()).collect::<Vec<String>>().join(\"\");\nprintln!(\"{}\", output);\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let vector = vec![\"hello\",  \"world\"];\nlet output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\nprintln!(\"{}\", output);\n</code></pre>\n<h3>Known problems</h3>\n<p>While <code>.collect::<String>()</code> is sometimes more performant, there are cases where\nusing <code>.collect::<String>()</code> over <code>.collect::<Vec<String>>().join(\"\")</code>\nwill prevent loop unrolling and will result in a negative performance impact.</p>\n<p>Additionally, differences have been observed between aarch64 and x86_64 assembly output,\nwith aarch64 tending to producing faster assembly in more cases when using <code>.collect::<String>()</code></p>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_lazy_evaluations",
    "rule_name": "unnecessary_lazy_evaluations",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>As the counterpart to <code>or_fun_call</code>, this lint looks for unnecessary\nlazily evaluated closures on <code>Option</code> and <code>Result</code>.</p>\n<p>This lint suggests changing the following functions, when eager evaluation results in\nsimpler code:</p>\n<ul>\n<li><code>unwrap_or_else</code> to <code>unwrap_or</code></li>\n<li><code>and_then</code> to <code>and</code></li>\n<li><code>or_else</code> to <code>or</code></li>\n<li><code>get_or_insert_with</code> to <code>get_or_insert</code></li>\n<li><code>ok_or_else</code> to <code>ok_or</code></li>\n<li><code>then</code> to <code>then_some</code> (for msrv >= 1.62.0)</li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>Using eager evaluation is shorter and simpler in some cases.</p>\n<h3>Known problems</h3>\n<p>It is possible, but not recommended for <code>Deref</code> and <code>Index</code> to have\nside effects. Eagerly evaluating them can change the semantics of the program.</p>\n<h3>Example</h3>\n<pre><code>let opt: Option<u32> = None;\n\nopt.unwrap_or_else(|| 42);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let opt: Option<u32> = None;\n\nopt.unwrap_or(42);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_literal_bound",
    "rule_name": "unnecessary_literal_bound",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects functions that are written to return <code>&str</code> that could return <code>&'static str</code> but instead return a <code>&'a str</code>.</p>\n<h3>Why is this bad?</h3>\n<p>This leaves the caller unable to use the <code>&str</code> as <code>&'static str</code>, causing unnecessary allocations or confusion.\nThis is also most likely what you meant to write.</p>\n<h3>Example</h3>\n<pre><code>impl MyType {\n    fn returns_literal(&self) -> &str {\n        \"Literal\"\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>impl MyType {\n    fn returns_literal(&self) -> &'static str {\n        \"Literal\"\n    }\n}\n</code></pre>\n<p>Or, in case you may return a non-literal <code>str</code> in future:</p>\n<pre><code>impl MyType {\n    fn returns_literal<'a>(&'a self) -> &'a str {\n        \"Literal\"\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_literal_unwrap",
    "rule_name": "unnecessary_literal_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.unwrap()</code> related calls on <code>Result</code>s and <code>Option</code>s that are constructed.</p>\n<h3>Why is this bad?</h3>\n<p>It is better to write the value directly without the indirection.</p>\n<h3>Examples</h3>\n<pre><code>let val1 = Some(1).unwrap();\nlet val2 = Ok::<_, ()>(1).unwrap();\nlet val3 = Err::<(), _>(1).unwrap_err();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let val1 = 1;\nlet val2 = 1;\nlet val3 = 1;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_map_on_constructor",
    "rule_name": "unnecessary_map_on_constructor",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Suggests removing the use of a <code>map()</code> (or <code>map_err()</code>) method when an <code>Option</code> or <code>Result</code>\nis being constructed.</p>\n<h3>Why is this bad?</h3>\n<p>It introduces unnecessary complexity. Instead, the function can be called before\nconstructing the <code>Option</code> or <code>Result</code> from its return value.</p>\n<h3>Example</h3>\n<pre><code>Some(4).map(i32::swap_bytes)\n</code></pre>\n<p>Use instead:</p>\n<pre><code>Some(i32::swap_bytes(4))\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_map_or",
    "rule_name": "unnecessary_map_or",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Converts some constructs mapping an Enum value for equality comparison.</p>\n<h3>Why is this bad?</h3>\n<p>Calls such as <code>opt.map_or(false, |val| val == 5)</code> are needlessly long and cumbersome,\nand can be reduced to, for example, <code>opt == Some(5)</code> assuming <code>opt</code> implements <code>PartialEq</code>.\nAlso, calls such as <code>opt.map_or(true, |val| val == 5)</code> can be reduced to\n<code>opt.is_none_or(|val| val == 5)</code>.\nThis lint offers readability and conciseness improvements.</p>\n<h3>Example</h3>\n<pre><code>pub fn a(x: Option<i32>) -> (bool, bool) {\n    (\n        x.map_or(false, |n| n == 5),\n        x.map_or(true, |n| n > 5),\n    )\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>pub fn a(x: Option<i32>) -> (bool, bool) {\n    (\n        x == Some(5),\n        x.is_none_or(|n| n > 5),\n    )\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_min_or_max",
    "rule_name": "unnecessary_min_or_max",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary calls to <code>min()</code> or <code>max()</code> in the following cases</p>\n<ul>\n<li>Either both side is constant</li>\n<li>One side is clearly larger than the other, like i32::MIN and an i32 variable</li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>In the aforementioned cases it is not necessary to call <code>min()</code> or <code>max()</code>\nto compare values, it may even cause confusion.</p>\n<h3>Example</h3>\n<pre><code>let _ = 0.min(7_u32);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = 0;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_mut_passed",
    "rule_name": "unnecessary_mut_passed",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects passing a mutable reference to a function that only\nrequires an immutable reference.</p>\n<h3>Why is this bad?</h3>\n<p>The mutable reference rules out all other references to\nthe value. Also the code misleads about the intent of the call site.</p>\n<h3>Example</h3>\n<pre><code>vec.push(&mut value);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.push(&value);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_operation",
    "rule_name": "unnecessary_operation",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for expression statements that can be reduced to a\nsub-expression.</p>\n<h3>Why is this bad?</h3>\n<p>Expressions by themselves often have no side-effects.\nHaving such expressions reduces readability.</p>\n<h3>Example</h3>\n<pre><code>compute_array()[0];\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_owned_empty_strings",
    "rule_name": "unnecessary_owned_empty_strings",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects cases of owned empty strings being passed as an argument to a function expecting <code>&str</code></p>\n<h3>Why is this bad?</h3>\n<p>This results in longer and less readable code</p>\n<h3>Example</h3>\n<pre><code>vec![\"1\", \"2\", \"3\"].join(&String::new());\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![\"1\", \"2\", \"3\"].join(\"\");\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_result_map_or_else",
    "rule_name": "unnecessary_result_map_or_else",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.map_or_else()</code> \u201cmap closure\u201d for <code>Result</code> type.</p>\n<h3>Why is this bad?</h3>\n<p>This can be written more concisely by using <code>unwrap_or_else()</code>.</p>\n<h3>Example</h3>\n<pre><code>let x: Result<u32, ()> = Ok(0);\nlet y = x.map_or_else(|err| handle_error(err), |n| n);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x: Result<u32, ()> = Ok(0);\nlet y = x.unwrap_or_else(|err| handle_error(err));\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_safety_comment",
    "rule_name": "unnecessary_safety_comment",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>// SAFETY: </code> comments on safe code.</p>\n<h3>Why restrict this?</h3>\n<p>Safe code has no safety requirements, so there is no need to\ndescribe safety invariants.</p>\n<h3>Example</h3>\n<pre><code>use std::ptr::NonNull;\nlet a = &mut 42;\n\n// SAFETY: references are guaranteed to be non-null.\nlet ptr = NonNull::new(a).unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::ptr::NonNull;\nlet a = &mut 42;\n\nlet ptr = NonNull::new(a).unwrap();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_safety_doc",
    "rule_name": "unnecessary_safety_doc",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the doc comments of publicly visible\nsafe functions and traits and warns if there is a <code># Safety</code> section.</p>\n<h3>Why restrict this?</h3>\n<p>Safe functions and traits are safe to implement and therefore do not\nneed to describe safety preconditions that users are required to uphold.</p>\n<h3>Examples</h3>\n<pre><code>/// # Safety\n///\n/// This function should not be called before the horsemen are ready.\npub fn start_apocalypse_but_safely(u: &mut Universe) {\n    unimplemented!();\n}\n</code></pre>\n<p>The function is safe, so there shouldn\u2019t be any preconditions\nthat have to be explained for safety reasons.</p>\n<pre><code>/// This function should really be documented\npub fn start_apocalypse(u: &mut Universe) {\n    unimplemented!();\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_self_imports",
    "rule_name": "unnecessary_self_imports",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for imports ending in <code>::{self}</code>.</p>\n<h3>Why restrict this?</h3>\n<p>In most cases, this can be written much more cleanly by omitting <code>::{self}</code>.</p>\n<h3>Known problems</h3>\n<p>Removing <code>::{self}</code> will cause any non-module items at the same path to also be imported.\nThis might cause a naming conflict (https://github.com/rust-lang/rustfmt/issues/3568). This lint makes no attempt\nto detect this scenario and that is why it is a restriction lint.</p>\n<h3>Example</h3>\n<pre><code>use std::io::{self};\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::io;\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_sort_by",
    "rule_name": "unnecessary_sort_by",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Vec::sort_by</code> passing in a closure\nwhich compares the two arguments, either directly or indirectly.</p>\n<h3>Why is this bad?</h3>\n<p>It is more clear to use <code>Vec::sort_by_key</code> (or <code>Vec::sort</code> if\npossible) than to use <code>Vec::sort_by</code> and a more complicated\nclosure.</p>\n<h3>Known problems</h3>\n<p>If the suggested <code>Vec::sort_by_key</code> uses Reverse and it isn\u2019t already\nimported by a use statement, then it will need to be added manually.</p>\n<h3>Example</h3>\n<pre><code>vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec.sort_by_key(|a| a.foo());\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_struct_initialization",
    "rule_name": "unnecessary_struct_initialization",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for initialization of an identical <code>struct</code> from another instance\nof the type, either by copying a base without setting any field or by\nmoving all fields individually.</p>\n<h3>Why is this bad?</h3>\n<p>Readability suffers from unnecessary struct building.</p>\n<h3>Example</h3>\n<pre><code>struct S { s: String }\n\nlet a = S { s: String::from(\"Hello, world!\") };\nlet b = S { ..a };\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct S { s: String }\n\nlet a = S { s: String::from(\"Hello, world!\") };\nlet b = a;\n</code></pre>\n<p>The struct literal <code>S { ..a }</code> in the assignment to <code>b</code> could be replaced\nwith just <code>a</code>.</p>\n<h3>Known Problems</h3>\n<p>Has false positives when the base is a place expression that cannot be\nmoved out of, see <a>#10547</a>.</p>\n<p>Empty structs are ignored by the lint.</p>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "unnecessary_to_owned",
    "rule_name": "unnecessary_to_owned",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary calls to <a><code>ToOwned::to_owned</code></a>\nand other <code>to_owned</code>-like functions.</p>\n<h3>Why is this bad?</h3>\n<p>The unnecessary calls result in useless allocations.</p>\n<h3>Known problems</h3>\n<p><code>unnecessary_to_owned</code> can falsely trigger if <code>IntoIterator::into_iter</code> is applied to an\nowned copy of a resource and the resource is later used mutably. See\n<a>#8148</a>.</p>\n<h3>Example</h3>\n<pre><code>let path = std::path::Path::new(\"x\");\nfoo(&path.to_string_lossy().to_string());\nfn foo(s: &str) {}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let path = std::path::Path::new(\"x\");\nfoo(&path.to_string_lossy());\nfn foo(s: &str) {}\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_unwrap",
    "rule_name": "unnecessary_unwrap",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls of <code>unwrap[_err]()</code> that cannot fail.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>if let</code> or <code>match</code> is more idiomatic.</p>\n<h3>Example</h3>\n<pre><code>if option.is_some() {\n    do_something_with(option.unwrap())\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>if let Some(value) = option {\n    do_something_with(value)\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnecessary_wraps",
    "rule_name": "unnecessary_wraps",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for private functions that only return <code>Ok</code> or <code>Some</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It is not meaningful to wrap values when no <code>None</code> or <code>Err</code> is returned.</p>\n<h3>Known problems</h3>\n<p>There can be false positives if the function signature is designed to\nfit some external requirement.</p>\n<h3>Example</h3>\n<pre><code>fn get_cool_number(a: bool, b: bool) -> Option<i32> {\n    if a && b {\n        return Some(50);\n    }\n    if a {\n        Some(0)\n    } else {\n        Some(10)\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn get_cool_number(a: bool, b: bool) -> i32 {\n    if a && b {\n        return 50;\n    }\n    if a {\n        0\n    } else {\n        10\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unneeded_field_pattern",
    "rule_name": "unneeded_field_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for structure field patterns bound to wildcards.</p>\n<h3>Why restrict this?</h3>\n<p>Using <code>..</code> instead is shorter and leaves the focus on\nthe fields that are actually bound.</p>\n<h3>Example</h3>\n<pre><code>let f = Foo { a: 0, b: 0, c: 0 };\n\nmatch f {\n    Foo { a: _, b: 0, .. } => {},\n    Foo { a: _, b: _, c: _ } => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let f = Foo { a: 0, b: 0, c: 0 };\n\nmatch f {\n    Foo { b: 0, .. } => {},\n    Foo { .. } => {},\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unneeded_wildcard_pattern",
    "rule_name": "unneeded_wildcard_pattern",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for tuple patterns with a wildcard\npattern (<code>_</code>) is next to a rest pattern (<code>..</code>).</p>\n<p><em>NOTE</em>: While <code>_, ..</code> means there is at least one element left, <code>..</code>\nmeans there are 0 or more elements left. This can make a difference\nwhen refactoring, but shouldn\u2019t result in errors in the refactored code,\nsince the wildcard pattern isn\u2019t used anyway.</p>\n<h3>Why is this bad?</h3>\n<p>The wildcard pattern is unneeded as the rest pattern\ncan match that element as well.</p>\n<h3>Example</h3>\n<pre><code>match t {\n    TupleStruct(0, .., _) => (),\n    _ => (),\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match t {\n    TupleStruct(0, ..) => (),\n    _ => (),\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unnested_or_patterns",
    "rule_name": "unnested_or_patterns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnested or-patterns, e.g., <code>Some(0) | Some(2)</code> and\nsuggests replacing the pattern with a nested one, <code>Some(0 | 2)</code>.</p>\n<p>Another way to think of this is that it rewrites patterns in\n<em>disjunctive normal form (DNF)</em> into <em>conjunctive normal form (CNF)</em>.</p>\n<h3>Why is this bad?</h3>\n<p>In the example above, <code>Some</code> is repeated, which unnecessarily complicates the pattern.</p>\n<h3>Example</h3>\n<pre><code>fn main() {\n    if let Some(0) | Some(2) = Some(0) {}\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn main() {\n    if let Some(0 | 2) = Some(0) {}\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unreachable",
    "rule_name": "unreachable",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>unreachable!</code>.</p>\n<h3>Why restrict this?</h3>\n<p>This macro, or panics in general, may be unwanted in production code.</p>\n<h3>Example</h3>\n<pre><code>unreachable!();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unreadable_literal",
    "rule_name": "unreadable_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if a long integral or floating-point constant does\nnot contain underscores.</p>\n<h3>Why is this bad?</h3>\n<p>Reading long numbers is difficult without separators.</p>\n<h3>Example</h3>\n<pre><code>61864918973511\n</code></pre>\n<p>Use instead:</p>\n<pre><code>61_864_918_973_511\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>unreadable-literal-lint-fractions</code>:  Should the fraction of a decimal be linted to include separators.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unsafe_derive_deserialize",
    "rule_name": "unsafe_derive_deserialize",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for deriving <code>serde::Deserialize</code> on a type that\nhas methods using <code>unsafe</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Deriving <code>serde::Deserialize</code> will create a constructor\nthat may violate invariants held by another constructor.</p>\n<h3>Example</h3>\n<pre><code>use serde::Deserialize;\n\n#[derive(Deserialize)]\npub struct Foo {\n    // ..\n}\n\nimpl Foo {\n    pub fn new() -> Self {\n        // setup here ..\n    }\n\n    pub unsafe fn parts() -> (&str, &str) {\n        // assumes invariants hold\n    }\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unsafe_removed_from_name",
    "rule_name": "unsafe_removed_from_name",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for imports that remove \u201cunsafe\u201d from an item\u2019s\nname.</p>\n<h3>Why is this bad?</h3>\n<p>Renaming makes it less clear which traits and\nstructures are unsafe.</p>\n<h3>Example</h3>\n<pre><code>use std::cell::{UnsafeCell as TotallySafeCell};\n\nextern crate crossbeam;\nuse crossbeam::{spawn_unsafe as spawn};\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unsafe_vector_initialization",
    "rule_name": "unsafe_vector_initialization",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p>The suggested alternative could be substantially slower.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "unseparated_literal_suffix",
    "rule_name": "unseparated_literal_suffix",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if literal suffixes are not separated by an\nunderscore.\nTo enforce unseparated literal suffix style,\nsee the <code>separated_literal_suffix</code> lint.</p>\n<h3>Why restrict this?</h3>\n<p>Suffix style should be consistent.</p>\n<h3>Example</h3>\n<pre><code>123832i32\n</code></pre>\n<p>Use instead:</p>\n<pre><code>123832_i32\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unsound_collection_transmute",
    "rule_name": "unsound_collection_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes between collections whose\ntypes have different ABI, size or alignment.</p>\n<h3>Why is this bad?</h3>\n<p>This is undefined behavior.</p>\n<h3>Known problems</h3>\n<p>Currently, we cannot know whether a type is a\ncollection, so we just lint the ones that come with <code>std</code>.</p>\n<h3>Example</h3>\n<pre><code>// different size, therefore likely out-of-bounds memory access\n// You absolutely do not want this in your code!\nunsafe {\n    std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n};\n</code></pre>\n<p>You must always iterate, map and collect the values:</p>\n<pre><code>vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "unstable_as_mut_slice",
    "rule_name": "unstable_as_mut_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>Vec::as_mut_slice</code> is now stable.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "unstable_as_slice",
    "rule_name": "unstable_as_slice",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>Vec::as_slice</code> is now stable.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "unused_async",
    "rule_name": "unused_async",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions that are declared <code>async</code> but have no <code>.await</code>s inside of them.</p>\n<h3>Why is this bad?</h3>\n<p>Async functions with no async code create overhead, both mentally and computationally.\nCallers of async methods either need to be calling from an async function themselves or run it on an executor, both of which\ncauses runtime overhead and hassle for the caller.</p>\n<h3>Example</h3>\n<pre><code>async fn get_random_number() -> i64 {\n    4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = get_random_number();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn get_random_number_improved() -> i64 {\n    4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = async { get_random_number_improved() };\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_collect",
    "rule_name": "unused_collect",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>Iterator::collect</code> is now marked as <code>#[must_use]</code>.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "unused_enumerate_index",
    "rule_name": "unused_enumerate_index",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for uses of the <code>enumerate</code> method where the index is unused (<code>_</code>)</p>\n<h3>Why is this bad?</h3>\n<p>The index from <code>.enumerate()</code> is immediately dropped.</p>\n<h3>Example</h3>\n<pre><code>let v = vec![1, 2, 3, 4];\nfor (_, x) in v.iter().enumerate() {\n    println!(\"{x}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let v = vec![1, 2, 3, 4];\nfor x in v.iter() {\n    println!(\"{x}\");\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unused_format_specs",
    "rule_name": "unused_format_specs",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects <a>formatting parameters</a> that have no effect on the output of\n<code>format!()</code>, <code>println!()</code> or similar macros.</p>\n<h3>Why is this bad?</h3>\n<p>Shorter format specifiers are easier to read, it may also indicate that\nan expected formatting operation such as adding padding isn\u2019t happening.</p>\n<h3>Example</h3>\n<pre><code>println!(\"{:.}\", 1.0);\n\nprintln!(\"not padded: {:5}\", format_args!(\"...\"));\n</code></pre>\n<p>Use instead:</p>\n<pre><code>println!(\"{}\", 1.0);\n\nprintln!(\"not padded: {}\", format_args!(\"...\"));\n// OR\nprintln!(\"padded: {:5}\", format!(\"...\"));\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "unused_io_amount",
    "rule_name": "unused_io_amount",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unused written/read amount.</p>\n<h3>Why is this bad?</h3>\n<p><code>io::Write::write(_vectored)</code> and\n<code>io::Read::read(_vectored)</code> are not guaranteed to\nprocess the entire buffer. They return how many bytes were processed, which\nmight be smaller\nthan a given buffer\u2019s length. If you don\u2019t need to deal with\npartial-write/read, use\n<code>write_all</code>/<code>read_exact</code> instead.</p>\n<p>When working with asynchronous code (either with the <code>futures</code>\ncrate or with <code>tokio</code>), a similar issue exists for\n<code>AsyncWriteExt::write()</code> and <code>AsyncReadExt::read()</code> : these\nfunctions are also not guaranteed to process the entire\nbuffer.  Your code should either handle partial-writes/reads, or\ncall the <code>write_all</code>/<code>read_exact</code> methods on those traits instead.</p>\n<h3>Known problems</h3>\n<p>Detects only common patterns.</p>\n<h3>Examples</h3>\n<pre><code>use std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n    w.write(b\"foo\")?;\n    Ok(())\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n    w.write_all(b\"foo\")?;\n    Ok(())\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "unused_peekable",
    "rule_name": "unused_peekable",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the creation of a <code>peekable</code> iterator that is never <code>.peek()</code>ed</p>\n<h3>Why is this bad?</h3>\n<p>Creating a peekable iterator without using any of its methods is likely a mistake,\nor just a leftover after a refactor.</p>\n<h3>Example</h3>\n<pre><code>let collection = vec![1, 2, 3];\nlet iter = collection.iter().peekable();\n\nfor item in iter {\n    // ...\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let collection = vec![1, 2, 3];\nlet iter = collection.iter();\n\nfor item in iter {\n    // ...\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_result_ok",
    "rule_name": "unused_result_ok",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>Result::ok()</code> without using the returned <code>Option</code>.</p>\n<h3>Why is this bad?</h3>\n<p>Using <code>Result::ok()</code> may look like the result is checked like <code>unwrap</code> or <code>expect</code> would do\nbut it only silences the warning caused by <code>#[must_use]</code> on the <code>Result</code>.</p>\n<h3>Example</h3>\n<pre><code>some_function().ok();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let _ = some_function();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_rounding",
    "rule_name": "unused_rounding",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects cases where a whole-number literal float is being rounded, using\nthe <code>floor</code>, <code>ceil</code>, or <code>round</code> methods.</p>\n<h3>Why is this bad?</h3>\n<p>This is unnecessary and confusing to the reader. Doing this is probably a mistake.</p>\n<h3>Example</h3>\n<pre><code>let x = 1f32.ceil();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let x = 1f32;\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_self",
    "rule_name": "unused_self",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks methods that contain a <code>self</code> argument but don\u2019t use it</p>\n<h3>Why is this bad?</h3>\n<p>It may be clearer to define the method as an associated function instead\nof an instance method if it doesn\u2019t require <code>self</code>.</p>\n<h3>Example</h3>\n<pre><code>struct A;\nimpl A {\n    fn method(&self) {}\n}\n</code></pre>\n<p>Could be written:</p>\n<pre><code>struct A;\nimpl A {\n    fn method() {}\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_trait_names",
    "rule_name": "unused_trait_names",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>use Trait</code> where the Trait is only used for its methods and not referenced by a path directly.</p>\n<h3>Why is this bad?</h3>\n<p>Traits imported that aren\u2019t used directly can be imported anonymously with <code>use Trait as _</code>.\nIt is more explicit, avoids polluting the current scope with unused names and can be useful to show which imports are required for traits.</p>\n<h3>Example</h3>\n<pre><code>use std::fmt::Write;\n\nfn main() {\n    let mut s = String::new();\n    let _ = write!(s, \"hello, world!\");\n    println!(\"{s}\");\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::fmt::Write as _;\n\nfn main() {\n    let mut s = String::new();\n    let _ = write!(s, \"hello, world!\");\n    println!(\"{s}\");\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unused_unit",
    "rule_name": "unused_unit",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unit (<code>()</code>) expressions that can be removed.</p>\n<h3>Why is this bad?</h3>\n<p>Such expressions add no value, but can make the code\nless readable. Depending on formatting they can make a <code>break</code> or <code>return</code>\nstatement look like a function call.</p>\n<h3>Example</h3>\n<pre><code>fn return_unit() -> () {\n    ()\n}\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>fn return_unit() {}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unusual_byte_groupings",
    "rule_name": "unusual_byte_groupings",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if hexadecimal or binary literals are not grouped\nby nibble or byte.</p>\n<h3>Why is this bad?</h3>\n<p>Negatively impacts readability.</p>\n<h3>Example</h3>\n<pre><code>let x: u32 = 0xFFF_FFF;\nlet y: u8 = 0b01_011_101;\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unwrap_in_result",
    "rule_name": "unwrap_in_result",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for functions of type <code>Result</code> that contain <code>expect()</code> or <code>unwrap()</code></p>\n<h3>Why restrict this?</h3>\n<p>These functions promote recoverable errors to non-recoverable errors,\nwhich may be undesirable in code bases which wish to avoid panics,\nor be a bug in the specific function.</p>\n<h3>Known problems</h3>\n<p>This can cause false positives in functions that handle both recoverable and non recoverable errors.</p>\n<h3>Example</h3>\n<p>Before:</p>\n<pre><code>fn divisible_by_3(i_str: String) -> Result<(), String> {\n    let i = i_str\n        .parse::<i32>()\n        .expect(\"cannot divide the input by three\");\n\n    if i % 3 != 0 {\n        Err(\"Number is not divisible by 3\")?\n    }\n\n    Ok(())\n}\n</code></pre>\n<p>After:</p>\n<pre><code>fn divisible_by_3(i_str: String) -> Result<(), String> {\n    let i = i_str\n        .parse::<i32>()\n        .map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n\n    if i % 3 != 0 {\n        Err(\"Number is not divisible by 3\")?\n    }\n\n    Ok(())\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "unwrap_or_default",
    "rule_name": "unwrap_or_default",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usages of the following functions with an argument that constructs a default value\n(e.g., <code>Default::default</code> or <code>String::new</code>):</p>\n<ul>\n<li><code>unwrap_or</code></li>\n<li><code>unwrap_or_else</code></li>\n<li><code>or_insert</code></li>\n<li><code>or_insert_with</code></li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>Readability. Using <code>unwrap_or_default</code> in place of <code>unwrap_or</code>/<code>unwrap_or_else</code>, or <code>or_default</code>\nin place of <code>or_insert</code>/<code>or_insert_with</code>, is simpler and more concise.</p>\n<h3>Known problems</h3>\n<p>In some cases, the argument of <code>unwrap_or</code>, etc. is needed for type inference. The lint uses a\nheuristic to try to identify such cases. However, the heuristic can produce false negatives.</p>\n<h3>Examples</h3>\n<pre><code>x.unwrap_or(Default::default());\nmap.entry(42).or_insert_with(String::new);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>x.unwrap_or_default();\nmap.entry(42).or_default();\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>unwrap_or_else_default</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "unwrap_used",
    "rule_name": "unwrap_used",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>.unwrap()</code> or <code>.unwrap_err()</code> calls on <code>Result</code>s and <code>.unwrap()</code> call on <code>Option</code>s.</p>\n<h3>Why restrict this?</h3>\n<p>It is better to handle the <code>None</code> or <code>Err</code> case,\nor at least call <code>.expect(_)</code> with a more helpful message. Still, for a lot of\nquick-and-dirty code, <code>unwrap</code> is a good choice, which is why this lint is\n<code>Allow</code> by default.</p>\n<p><code>result.unwrap()</code> will let the thread panic on <code>Err</code> values.\nNormally, you want to implement more sophisticated error handling,\nand propagate errors upwards with <code>?</code> operator.</p>\n<p>Even if you want to panic on errors, not all <code>Error</code>s implement good\nmessages on display. Therefore, it may be beneficial to look at the places\nwhere they may get displayed. Activate this lint to do just that.</p>\n<h3>Examples</h3>\n<pre><code>option.unwrap();\nresult.unwrap();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>option.expect(\"more helpful message\");\nresult.expect(\"more helpful message\");\n</code></pre>\n<p>If <a>expect_used</a> is enabled, instead:</p>\n<pre><code>option?;\n\n// or\n\nresult?;\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>option_unwrap_used</li>\n<li>result_unwrap_used</li>\n</ul>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-unwrap-in-tests</code>:  Whether <code>unwrap</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "upper_case_acronyms",
    "rule_name": "upper_case_acronyms",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for fully capitalized names and optionally names containing a capitalized acronym.</p>\n<h3>Why is this bad?</h3>\n<p>In CamelCase, acronyms count as one word.\nSee <a>naming conventions</a>\nfor more.</p>\n<p>By default, the lint only triggers on fully-capitalized names.\nYou can use the <code>upper-case-acronyms-aggressive: true</code> config option to enable linting\non all camel case names</p>\n<h3>Known problems</h3>\n<p>When two acronyms are contiguous, the lint can\u2019t tell where\nthe first acronym ends and the second starts, so it suggests to lowercase all of\nthe letters in the second acronym.</p>\n<h3>Example</h3>\n<pre><code>struct HTTPResponse;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>struct HttpResponse;\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>upper-case-acronyms-aggressive</code>:  Enables verbose mode. Triggers if there is more than one uppercase char next to each other</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "use_debug",
    "rule_name": "use_debug",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Debug</code> formatting. The purpose of this\nlint is to catch debugging remnants.</p>\n<h3>Why restrict this?</h3>\n<p>The purpose of the <code>Debug</code> trait is to facilitate debugging Rust code,\nand <a>no guarantees are made about its output</a>.\nIt should not be used in user-facing output.</p>\n<h3>Example</h3>\n<pre><code>println!(\"{:?}\", foo);\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "use_self",
    "rule_name": "use_self",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for unnecessary repetition of structure name when a\nreplacement with <code>Self</code> is applicable.</p>\n<h3>Why is this bad?</h3>\n<p>Unnecessary repetition. Mixed use of <code>Self</code> and struct\nname\nfeels inconsistent.</p>\n<h3>Known problems</h3>\n<ul>\n<li>Unaddressed false negative in fn bodies of trait implementations</li>\n</ul>\n<h3>Example</h3>\n<pre><code>struct Foo;\nimpl Foo {\n    fn new() -> Foo {\n        Foo {}\n    }\n}\n</code></pre>\n<p>could be</p>\n<pre><code>struct Foo;\nimpl Foo {\n    fn new() -> Self {\n        Self {}\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>\n<p>(default: <code>current version</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "used_underscore_binding",
    "rule_name": "used_underscore_binding",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of bindings with a single leading\nunderscore.</p>\n<h3>Why is this bad?</h3>\n<p>A single leading underscore is usually used to indicate\nthat a binding will not be used. Using such a binding breaks this\nexpectation.</p>\n<h3>Known problems</h3>\n<p>The lint does not work properly with desugaring and\nmacro, it has been allowed in the meantime.</p>\n<h3>Example</h3>\n<pre><code>let _x = 0;\nlet y = _x + 1; // Here we are using `_x`, even though it has a leading\n                // underscore. We should rename `_x` to `x`\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "used_underscore_items",
    "rule_name": "used_underscore_items",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of item with a single leading\nunderscore.</p>\n<h3>Why is this bad?</h3>\n<p>A single leading underscore is usually used to indicate\nthat a item will not be used. Using such a item breaks this\nexpectation.</p>\n<h3>Example</h3>\n<pre><code>fn _foo() {}\n\nstruct _FooStruct {}\n\nfn main() {\n    _foo();\n    let _ = _FooStruct{};\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn foo() {}\n\nstruct FooStruct {}\n\nfn main() {\n    foo();\n    let _ = FooStruct{};\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "useless_asref",
    "rule_name": "useless_asref",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>.as_ref()</code> or <code>.as_mut()</code> where the\ntypes before and after the call are the same.</p>\n<h3>Why is this bad?</h3>\n<p>The call is unnecessary.</p>\n<h3>Example</h3>\n<pre><code>let x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x.as_ref());\n</code></pre>\n<p>The correct use would be:</p>\n<pre><code>let x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x);\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "useless_attribute",
    "rule_name": "useless_attribute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>extern crate</code> and <code>use</code> items annotated with\nlint attributes.</p>\n<p>This lint permits lint attributes for lints emitted on the items themself.\nFor <code>use</code> items these lints are:</p>\n<ul>\n<li>ambiguous_glob_reexports</li>\n<li>dead_code</li>\n<li>deprecated</li>\n<li>hidden_glob_reexports</li>\n<li>unreachable_pub</li>\n<li>unused</li>\n<li>unused_braces</li>\n<li>unused_import_braces</li>\n<li>clippy::disallowed_types</li>\n<li>clippy::enum_glob_use</li>\n<li>clippy::macro_use_imports</li>\n<li>clippy::module_name_repetitions</li>\n<li>clippy::redundant_pub_crate</li>\n<li>clippy::single_component_path_imports</li>\n<li>clippy::unsafe_removed_from_name</li>\n<li>clippy::wildcard_imports</li>\n</ul>\n<p>For <code>extern crate</code> items these lints are:</p>\n<ul>\n<li><code>unused_imports</code> on items with <code>#[macro_use]</code></li>\n</ul>\n<h3>Why is this bad?</h3>\n<p>Lint attributes have no effect on crate imports. Most\nlikely a <code>!</code> was forgotten.</p>\n<h3>Example</h3>\n<pre><code>#[deny(dead_code)]\nextern crate foo;\n#[forbid(dead_code)]\nuse foo::bar;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>#[allow(unused_imports)]\nuse foo::baz;\n#[allow(unused_imports)]\n#[macro_use]\nextern crate baz;\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "useless_conversion",
    "rule_name": "useless_conversion",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>Into</code>, <code>TryInto</code>, <code>From</code>, <code>TryFrom</code>, or <code>IntoIter</code> calls\nwhich uselessly convert to the same type.</p>\n<h3>Why is this bad?</h3>\n<p>Redundant code.</p>\n<h3>Example</h3>\n<pre><code>// format!() returns a `String`\nlet s: String = format!(\"hello\").into();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let s: String = format!(\"hello\");\n</code></pre>\n<h3>Past names</h3>\n<ul>\n<li>identity_conversion</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "useless_format",
    "rule_name": "useless_format",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for the use of <code>format!(\"string literal with no argument\")</code> and <code>format!(\"{}\", foo)</code> where <code>foo</code> is a string.</p>\n<h3>Why is this bad?</h3>\n<p>There is no point of doing that. <code>format!(\"foo\")</code> can\nbe replaced by <code>\"foo\".to_owned()</code> if you really need a <code>String</code>. The even\nworse <code>&format!(\"foo\")</code> is often encountered in the wild. <code>format!(\"{}\", foo)</code> can be replaced by <code>foo.clone()</code> if <code>foo: String</code> or <code>foo.to_owned()</code>\nif <code>foo: &str</code>.</p>\n<h3>Examples</h3>\n<pre><code>let foo = \"foo\";\nformat!(\"{}\", foo);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let foo = \"foo\";\nfoo.to_owned();\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "useless_let_if_seq",
    "rule_name": "useless_let_if_seq",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for variable declarations immediately followed by a\nconditional affectation.</p>\n<h3>Why is this bad?</h3>\n<p>This is not idiomatic Rust.</p>\n<h3>Example</h3>\n<pre><code>let foo;\n\nif bar() {\n    foo = 42;\n} else {\n    foo = 0;\n}\n\nlet mut baz = None;\n\nif bar() {\n    baz = Some(42);\n}\n</code></pre>\n<p>should be written</p>\n<pre><code>let foo = if bar() {\n    42\n} else {\n    0\n};\n\nlet baz = if bar() {\n    Some(42)\n} else {\n    None\n};\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "useless_transmute",
    "rule_name": "useless_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes to the original type of the object\nand transmutes that could be a cast.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. The code tricks people into thinking that\nsomething complex is going on.</p>\n<h3>Example</h3>\n<pre><code>core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "useless_vec",
    "rule_name": "useless_vec",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>vec![..]</code> when using <code>[..]</code> would\nbe possible.</p>\n<h3>Why is this bad?</h3>\n<p>This is less efficient.</p>\n<h3>Example</h3>\n<pre><code>fn foo(_x: &[u8]) {}\n\nfoo(&vec![1, 2]);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>foo(&[1, 2]);\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>allow-useless-vec-in-tests</code>:  Whether <code>useless_vec</code> should ignore test functions or <code>#[cfg(test)]</code></p>\n<p>(default: <code>false</code>)</p>\n</li>\n<li>\n<p><code>too-large-for-stack</code>:  The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap</p>\n<p>(default: <code>200</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "vec_box",
    "rule_name": "vec_box",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>Vec<Box<T>></code> where T: Sized anywhere in the code.\nCheck the <a>Box documentation</a> for more information.</p>\n<h3>Why is this bad?</h3>\n<p><code>Vec</code> already keeps its contents in a separate area on\nthe heap. So if you <code>Box</code> its contents, you just add another level of indirection.</p>\n<h3>Known problems</h3>\n<p>Vec<Box<T: Sized>> makes sense if T is a large type (see <a>#3530</a>,\n1st comment).</p>\n<h3>Example</h3>\n<pre><code>struct X {\n    values: Vec<Box<i32>>,\n}\n</code></pre>\n<p>Better:</p>\n<pre><code>struct X {\n    values: Vec<i32>,\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n<li>\n<p><code>vec-box-size-threshold</code>:  The size of the boxed type in bytes, where boxing in a <code>Vec</code> is allowed</p>\n<p>(default: <code>4096</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "vec_init_then_push",
    "rule_name": "vec_init_then_push",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for calls to <code>push</code> immediately after creating a new <code>Vec</code>.</p>\n<p>If the <code>Vec</code> is created using <code>with_capacity</code> this will only lint if the capacity is a\nconstant and the number of pushes is greater than or equal to the initial capacity.</p>\n<p>If the <code>Vec</code> is extended after the initial sequence of pushes and it was default initialized\nthen this will only lint after there were at least four pushes. This number may change in\nthe future.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>vec![]</code> macro is both more performant and easier to read than\nmultiple <code>push</code> calls.</p>\n<h3>Example</h3>\n<pre><code>let mut v = Vec::new();\nv.push(0);\nv.push(1);\nv.push(2);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let v = vec![0, 1, 2];\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "vec_resize_to_zero",
    "rule_name": "vec_resize_to_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Finds occurrences of <code>Vec::resize(0, an_int)</code></p>\n<h3>Why is this bad?</h3>\n<p>This is probably an argument inversion mistake.</p>\n<h3>Example</h3>\n<pre><code>vec![1, 2, 3, 4, 5].resize(0, 5)\n</code></pre>\n<p>Use instead:</p>\n<pre><code>vec![1, 2, 3, 4, 5].clear()\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "verbose_bit_mask",
    "rule_name": "verbose_bit_mask",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for bit masks that can be replaced by a call\nto <code>trailing_zeros</code></p>\n<h3>Why is this bad?</h3>\n<p><code>x.trailing_zeros() > 4</code> is much clearer than <code>x & 15 == 0</code></p>\n<h3>Known problems</h3>\n<p>llvm generates better code for <code>x & 15 == 0</code> on x86</p>\n<h3>Example</h3>\n<pre><code>if x & 0b1111 == 0 { }\n</code></pre>\n<p>Use instead:</p>\n<pre><code>if x.trailing_zeros() > 4 { }\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>verbose-bit-mask-threshold</code>:  The maximum allowed size of a bit mask before suggesting to use \u2018trailing_zeros\u2019</p>\n<p>(default: <code>1</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "verbose_file_reads",
    "rule_name": "verbose_file_reads",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of File::read_to_end and File::read_to_string.</p>\n<h3>Why restrict this?</h3>\n<p><code>fs::{read, read_to_string}</code> provide the same functionality when <code>buf</code> is empty with fewer imports and no intermediate values.\nSee also: <a>fs::read docs</a>, <a>fs::read_to_string docs</a></p>\n<h3>Example</h3>\n<pre><code>let mut f = File::open(\"foo.txt\").unwrap();\nlet mut bytes = Vec::new();\nf.read_to_end(&mut bytes).unwrap();\n</code></pre>\n<p>Can be written more concisely as</p>\n<pre><code>let mut bytes = fs::read(\"foo.txt\").unwrap();\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "waker_clone_wake",
    "rule_name": "waker_clone_wake",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for usage of <code>waker.clone().wake()</code></p>\n<h3>Why is this bad?</h3>\n<p>Cloning the waker is not necessary, <code>wake_by_ref()</code> enables the same operation\nwithout extra cloning/dropping.</p>\n<h3>Example</h3>\n<pre><code>waker.clone().wake();\n</code></pre>\n<p>Should be written</p>\n<pre><code>waker.wake_by_ref();\n</code></pre>\n</div>",
    "lint_group": "perf",
    "lint_level": "warn"
  },
  {
    "rule_id": "while_float",
    "rule_name": "while_float",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for while loops comparing floating point values.</p>\n<h3>Why is this bad?</h3>\n<p>If you increment floating point values, errors can compound,\nso, use integers instead if possible.</p>\n<h3>Known problems</h3>\n<p>The lint will catch all while loops comparing floating point\nvalues without regarding the increment.</p>\n<h3>Example</h3>\n<pre><code>let mut x = 0.0;\nwhile x < 42.0 {\n    x += 1.0;\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let mut x = 0;\nwhile x < 42 {\n    x += 1;\n}\n</code></pre>\n</div>",
    "lint_group": "nursery",
    "lint_level": "allow"
  },
  {
    "rule_id": "while_immutable_condition",
    "rule_name": "while_immutable_condition",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks whether variables used within while loop condition\ncan be (and are) mutated in the body.</p>\n<h3>Why is this bad?</h3>\n<p>If the condition is unchanged, entering the body of the loop\nwill lead to an infinite loop.</p>\n<h3>Known problems</h3>\n<p>If the <code>while</code>-loop is in a closure, the check for mutation of the\ncondition variables in the body can cause false negatives. For example when only <code>Upvar</code> <code>a</code> is\nin the condition and only <code>Upvar</code> <code>b</code> gets mutated in the body, the lint will not trigger.</p>\n<h3>Example</h3>\n<pre><code>let i = 0;\nwhile i > 10 {\n    println!(\"let me loop forever!\");\n}\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "while_let_loop",
    "rule_name": "while_let_loop",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Detects <code>loop + match</code> combinations that are easier\nwritten as a <code>while let</code> loop.</p>\n<h3>Why is this bad?</h3>\n<p>The <code>while let</code> loop is usually shorter and more\nreadable.</p>\n<h3>Example</h3>\n<pre><code>let y = Some(1);\nloop {\n    let x = match y {\n        Some(x) => x,\n        None => break,\n    };\n    // ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let y = Some(1);\nwhile let Some(x) = y {\n    // ..\n};\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "while_let_on_iterator",
    "rule_name": "while_let_on_iterator",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>while let</code> expressions on iterators.</p>\n<h3>Why is this bad?</h3>\n<p>Readability. A simple <code>for</code> loop is shorter and conveys\nthe intent better.</p>\n<h3>Example</h3>\n<pre><code>while let Some(val) = iter.next() {\n    ..\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>for val in &mut iter {\n    ..\n}\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "wildcard_dependencies",
    "rule_name": "wildcard_dependencies",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for wildcard dependencies in the <code>Cargo.toml</code>.</p>\n<h3>Why is this bad?</h3>\n<p><a>As the edition guide says</a>,\nit is highly unlikely that you work with any possible version of your dependency,\nand wildcard dependencies would cause unnecessary breakage in the ecosystem.</p>\n<h3>Example</h3>\n<pre><code>[dependencies]\nregex = \"*\"\n</code></pre>\n</div>",
    "lint_group": "cargo",
    "lint_level": "allow"
  },
  {
    "rule_id": "wildcard_enum_match_arm",
    "rule_name": "wildcard_enum_match_arm",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for wildcard enum matches using <code>_</code>.</p>\n<h3>Why restrict this?</h3>\n<p>New enum variants added by library updates can be missed.</p>\n<h3>Known problems</h3>\n<p>Suggested replacements may be incorrect if guards exhaustively cover some\nvariants, and also may not use correct path to enum if it\u2019s not present in the current scope.</p>\n<h3>Example</h3>\n<pre><code>match x {\n    Foo::A(_) => {},\n    _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match x {\n    Foo::A(_) => {},\n    Foo::B(_) => {},\n}\n</code></pre>\n</div>",
    "lint_group": "restriction",
    "lint_level": "allow"
  },
  {
    "rule_id": "wildcard_imports",
    "rule_name": "wildcard_imports",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for wildcard imports <code>use _::*</code>.</p>\n<h3>Why is this bad?</h3>\n<p>wildcard imports can pollute the namespace. This is especially bad if\nyou try to import something through a wildcard, that already has been imported by name from\na different source:</p>\n<pre><code>use crate1::foo; // Imports a function named foo\nuse crate2::*; // Has a function named foo\n\nfoo(); // Calls crate1::foo\n</code></pre>\n<p>This can lead to confusing error messages at best and to unexpected behavior at worst.</p>\n<h3>Exceptions</h3>\n<p>Wildcard imports are allowed from modules that their name contains <code>prelude</code>. Many crates\n(including the standard library) provide modules named \u201cprelude\u201d specifically designed\nfor wildcard import.</p>\n<p><code>use super::*</code> is allowed in test modules. This is defined as any module with \u201ctest\u201d in the name.</p>\n<p>These exceptions can be disabled using the <code>warn-on-all-wildcard-imports</code> configuration flag.</p>\n<h3>Known problems</h3>\n<p>If macros are imported through the wildcard, this macro is not included\nby the suggestion and has to be added by hand.</p>\n<p>Applying the suggestion when explicit imports of the things imported with a glob import\nexist, may result in <code>unused_imports</code> warnings.</p>\n<h3>Example</h3>\n<pre><code>use crate1::*;\n\nfoo();\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use crate1::foo;\n\nfoo();\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li><code>allowed-wildcard-imports</code>:  List of path segments allowed to have wildcard imports.</li>\n</ul>\n<h4>Example</h4>\n<pre><code>allowed-wildcard-imports = [ \"utils\", \"common\" ]\n</code></pre>\n<h4>Noteworthy</h4>\n<ol>\n<li>This configuration has no effects if used with <code>warn_on_all_wildcard_imports = true</code>.</li>\n<li>Paths with any segment that containing the word \u2018prelude\u2019\nare already allowed by default.</li>\n</ol>\n<p>(default: <code>[]</code>)</p>\n<ul>\n<li>\n<p><code>warn-on-all-wildcard-imports</code>:  Whether to allow certain wildcard imports (prelude, super in tests).</p>\n<p>(default: <code>false</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "wildcard_in_or_patterns",
    "rule_name": "wildcard_in_or_patterns",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for wildcard pattern used with others patterns in same match arm.</p>\n<h3>Why is this bad?</h3>\n<p>Wildcard pattern already covers any other pattern as it will match anyway.\nIt makes the code less readable, especially to spot wildcard pattern use in match arm.</p>\n<h3>Example</h3>\n<pre><code>match s {\n    \"a\" => {},\n    \"bar\" | _ => {},\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>match s {\n    \"a\" => {},\n    _ => {},\n}\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "write_literal",
    "rule_name": "write_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns about the use of literals as <code>write!</code>/<code>writeln!</code> args.</p>\n<h3>Why is this bad?</h3>\n<p>Using literals as <code>writeln!</code> args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)</p>\n<h3>Example</h3>\n<pre><code>writeln!(buf, \"{}\", \"foo\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>writeln!(buf, \"foo\");\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "write_with_newline",
    "rule_name": "write_with_newline",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns when you use <code>write!()</code> with a format\nstring that\nends in a newline.</p>\n<h3>Why is this bad?</h3>\n<p>You should use <code>writeln!()</code> instead, which appends the\nnewline.</p>\n<h3>Example</h3>\n<pre><code>write!(buf, \"Hello {}!\\n\", name);\n</code></pre>\n<p>Use instead:</p>\n<pre><code>writeln!(buf, \"Hello {}!\", name);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "writeln_empty_string",
    "rule_name": "writeln_empty_string",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>This lint warns when you use <code>writeln!(buf, \"\")</code> to\nprint a newline.</p>\n<h3>Why is this bad?</h3>\n<p>You should use <code>writeln!(buf)</code>, which is simpler.</p>\n<h3>Example</h3>\n<pre><code>writeln!(buf, \"\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>writeln!(buf);\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "wrong_pub_self_convention",
    "rule_name": "wrong_pub_self_convention",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Nothing. This lint has been deprecated</p>\n<h3>Deprecation reason</h3>\n<p><code>clippy::wrong_self_convention</code> now covers this case via the <code>avoid-breaking-exported-api</code> config.</p>\n</div>",
    "lint_group": "deprecated",
    "lint_level": "none"
  },
  {
    "rule_id": "wrong_self_convention",
    "rule_name": "wrong_self_convention",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for methods with certain name prefixes or suffixes, and which\ndo not adhere to standard conventions regarding how <code>self</code> is taken.\nThe actual rules are:</p>\n<table><thead><tr><th>Prefix</th><th>Postfix</th><th><code>self</code> taken</th><th><code>self</code> type</th></tr></thead><tbody>\n<tr><td><code>as_</code></td><td>none</td><td><code>&self</code> or <code>&mut self</code></td><td>any</td></tr>\n<tr><td><code>from_</code></td><td>none</td><td>none</td><td>any</td></tr>\n<tr><td><code>into_</code></td><td>none</td><td><code>self</code></td><td>any</td></tr>\n<tr><td><code>is_</code></td><td>none</td><td><code>&mut self</code> or <code>&self</code> or none</td><td>any</td></tr>\n<tr><td><code>to_</code></td><td><code>_mut</code></td><td><code>&mut self</code></td><td>any</td></tr>\n<tr><td><code>to_</code></td><td>not <code>_mut</code></td><td><code>self</code></td><td><code>Copy</code></td></tr>\n<tr><td><code>to_</code></td><td>not <code>_mut</code></td><td><code>&self</code></td><td>not <code>Copy</code></td></tr>\n</tbody></table>\n<p>Note: Clippy doesn\u2019t trigger methods with <code>to_</code> prefix in:</p>\n<ul>\n<li>Traits definition.\nClippy can not tell if a type that implements a trait is <code>Copy</code> or not.</li>\n<li>Traits implementation, when <code>&self</code> is taken.\nThe method signature is controlled by the trait and often <code>&self</code> is required for all types that implement the trait\n(see e.g. the <code>std::string::ToString</code> trait).</li>\n</ul>\n<p>Clippy allows <code>Pin<&Self></code> and <code>Pin<&mut Self></code> if <code>&self</code> and <code>&mut self</code> is required.</p>\n<p>Please find more info here:\nhttps://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv</p>\n<h3>Why is this bad?</h3>\n<p>Consistency breeds readability. If you follow the\nconventions, your users won\u2019t be surprised that they, e.g., need to supply a\nmutable reference to a <code>as_..</code> function.</p>\n<h3>Example</h3>\n<pre><code>impl X {\n    fn as_str(self) -> &'static str {\n        // ..\n    }\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>impl X {\n    fn as_str(&self) -> &'static str {\n        // ..\n    }\n}\n</code></pre>\n<h3>Configuration</h3>\n<ul>\n<li>\n<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>\n<p>(default: <code>true</code>)</p>\n</li>\n</ul>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "wrong_transmute",
    "rule_name": "wrong_transmute",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for transmutes that can\u2019t ever be correct on any\narchitecture.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s basically guaranteed to be undefined behavior.</p>\n<h3>Known problems</h3>\n<p>When accessing C, users might want to store pointer\nsized objects in <code>extradata</code> arguments to save an allocation.</p>\n<h3>Example</h3>\n<pre><code>let ptr: *const T = core::intrinsics::transmute('x')\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  },
  {
    "rule_id": "zero_divided_by_zero",
    "rule_name": "zero_divided_by_zero",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>0.0 / 0.0</code>.</p>\n<h3>Why is this bad?</h3>\n<p>It\u2019s less readable than <code>f32::NAN</code> or <code>f64::NAN</code>.</p>\n<h3>Example</h3>\n<pre><code>let nan = 0.0f32 / 0.0;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let nan = f32::NAN;\n</code></pre>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "zero_prefixed_literal",
    "rule_name": "zero_prefixed_literal",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Warns if an integral constant literal starts with <code>0</code>.</p>\n<h3>Why is this bad?</h3>\n<p>In some languages (including the infamous C language\nand most of its\nfamily), this marks an octal constant. In Rust however, this is a decimal\nconstant. This could\nbe confusing for both the writer and a reader of the constant.</p>\n<h3>Example</h3>\n<p>In Rust:</p>\n<pre><code>fn main() {\n    let a = 0123;\n    println!(\"{}\", a);\n}\n</code></pre>\n<p>prints <code>123</code>, while in C:</p>\n<pre><code>#include <stdio.h>\n\nint main() {\n    int a = 0123;\n    printf(\"%d\\n\", a);\n}\n</code></pre>\n<p>prints <code>83</code> (as <code>83 == 0o123</code> while <code>123 == 0o173</code>).</p>\n</div>",
    "lint_group": "complexity",
    "lint_level": "warn"
  },
  {
    "rule_id": "zero_ptr",
    "rule_name": "zero_ptr",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Catch casts from <code>0</code> to some pointer type</p>\n<h3>Why is this bad?</h3>\n<p>This generally means <code>null</code> and is better expressed as\n{<code>std</code>, <code>core</code>}<code>::ptr::</code>{<code>null</code>, <code>null_mut</code>}.</p>\n<h3>Example</h3>\n<pre><code>let a = 0 as *const u32;\n</code></pre>\n<p>Use instead:</p>\n<pre><code>let a = std::ptr::null::<u32>();\n</code></pre>\n</div>",
    "lint_group": "style",
    "lint_level": "warn"
  },
  {
    "rule_id": "zero_repeat_side_effects",
    "rule_name": "zero_repeat_side_effects",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for array or vec initializations which call a function or method,\nbut which have a repeat count of zero.</p>\n<h3>Why is this bad?</h3>\n<p>Such an initialization, despite having a repeat length of 0, will still call the inner function.\nThis may not be obvious and as such there may be unintended side effects in code.</p>\n<h3>Example</h3>\n<pre><code>fn side_effect() -> i32 {\n    println!(\"side effect\");\n    10\n}\nlet a = [side_effect(); 0];\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn side_effect() -> i32 {\n    println!(\"side effect\");\n    10\n}\nside_effect();\nlet a: [i32; 0] = [];\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "zero_sized_map_values",
    "rule_name": "zero_sized_map_values",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for maps with zero-sized value types anywhere in the code.</p>\n<h3>Why is this bad?</h3>\n<p>Since there is only a single value for a zero-sized type, a map\ncontaining zero sized values is effectively a set. Using a set in that case improves\nreadability and communicates intent more clearly.</p>\n<h3>Known problems</h3>\n<ul>\n<li>A zero-sized type cannot be recovered later if it contains private fields.</li>\n<li>This lints the signature of public items</li>\n</ul>\n<h3>Example</h3>\n<pre><code>fn unique_words(text: &str) -> HashMap<&str, ()> {\n    todo!();\n}\n</code></pre>\n<p>Use instead:</p>\n<pre><code>fn unique_words(text: &str) -> HashSet<&str> {\n    todo!();\n}\n</code></pre>\n</div>",
    "lint_group": "pedantic",
    "lint_level": "allow"
  },
  {
    "rule_id": "zombie_processes",
    "rule_name": "zombie_processes",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Looks for code that spawns a process but never calls <code>wait()</code> on the child.</p>\n<h3>Why is this bad?</h3>\n<p>As explained in the <a>standard library documentation</a>,\ncalling <code>wait()</code> is necessary on Unix platforms to properly release all OS resources associated with the process.\nNot doing so will effectively leak process IDs and/or other limited global resources,\nwhich can eventually lead to resource exhaustion, so it\u2019s recommended to call <code>wait()</code> in long-running applications.\nSuch processes are called \u201czombie processes\u201d.</p>\n<p>To reduce the rate of false positives, if the spawned process is assigned to a binding, the lint actually works the other way around; it\nconservatively checks that all uses of a variable definitely don\u2019t call <code>wait()</code> and only then emits a warning.\nFor that reason, a seemingly unrelated use can get called out as calling <code>wait()</code> in help messages.</p>\n<h3>Control flow</h3>\n<p>If a <code>wait()</code> call exists in an if/then block but not in the else block (or there is no else block),\nthen this still gets linted as not calling <code>wait()</code> in all code paths.\nLikewise, when early-returning from the function, <code>wait()</code> calls that appear after the return expression\nare also not accepted.\nIn other words, the <code>wait()</code> call must be unconditionally reachable after the spawn expression.</p>\n<h3>Example</h3>\n<pre><code>use std::process::Command;\n\nlet _child = Command::new(\"ls\").spawn().expect(\"failed to execute child\");\n</code></pre>\n<p>Use instead:</p>\n<pre><code>use std::process::Command;\n\nlet mut child = Command::new(\"ls\").spawn().expect(\"failed to execute child\");\nchild.wait().expect(\"failed to wait on child\");\n</code></pre>\n</div>",
    "lint_group": "suspicious",
    "lint_level": "warn"
  },
  {
    "rule_id": "zst_offset",
    "rule_name": "zst_offset",
    "rule_description_html": "<div><h3>What it does</h3>\n<p>Checks for <code>offset(_)</code>, <code>wrapping_</code>{<code>add</code>, <code>sub</code>}, etc. on raw pointers to\nzero-sized types</p>\n<h3>Why is this bad?</h3>\n<p>This is a no-op, and likely unintended</p>\n<h3>Example</h3>\n<pre><code>unsafe { (&() as *const ()).offset(1) };\n</code></pre>\n</div>",
    "lint_group": "correctness",
    "lint_level": "deny"
  }
]